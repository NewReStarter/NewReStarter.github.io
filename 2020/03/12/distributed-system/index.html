<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="分布式,">










<meta name="description" content="[toc] 分布式系统原则拜占庭将军问题 口信消息型拜占庭问题之解 n 位将军，最多能容忍 (n - 1) / 3 位叛将。   签名消息型拜占庭问题之解 忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现； 任何人都能验证将军签名的真伪。    CAP 一致性（Consistency） 一致性说的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失">
<meta name="keywords" content="分布式">
<meta property="og:type" content="article">
<meta property="og:title" content="distributed system">
<meta property="og:url" content="NewReStarter.github.io/2020/03/12/distributed-system/index.html">
<meta property="og:site_name" content="Restartercc">
<meta property="og:description" content="[toc] 分布式系统原则拜占庭将军问题 口信消息型拜占庭问题之解 n 位将军，最多能容忍 (n - 1) / 3 位叛将。   签名消息型拜占庭问题之解 忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现； 任何人都能验证将军签名的真伪。    CAP 一致性（Consistency） 一致性说的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/3c/f5/3cb21a553580afbc840b68d4c6b128f5.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-af31c33db7daa0761da1ed03327154fd_1440w.jpg">
<meta property="og:image" content="https://image.jiqizhixin.com/uploads/editor/3ad43d47-e95f-4144-b3b8-d2181394d449/640.png">
<meta property="og:updated_time" content="2020-04-24T05:37:53.981Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="distributed system">
<meta name="twitter:description" content="[toc] 分布式系统原则拜占庭将军问题 口信消息型拜占庭问题之解 n 位将军，最多能容忍 (n - 1) / 3 位叛将。   签名消息型拜占庭问题之解 忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现； 任何人都能验证将军签名的真伪。    CAP 一致性（Consistency） 一致性说的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/3c/f5/3cb21a553580afbc840b68d4c6b128f5.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="NewReStarter.github.io/2020/03/12/distributed-system/">





  <title>distributed system | Restartercc</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Restartercc</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习计算机科学和数学，尝试了解这个世界</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2020/03/12/distributed-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">distributed system</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-12T16:07:25+08:00">
                2020-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[toc]</p>
<h2 id="分布式系统原则"><a href="#分布式系统原则" class="headerlink" title="分布式系统原则"></a>分布式系统原则</h2><h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h4><ul>
<li>口信消息型拜占庭问题之解<ul>
<li>n 位将军，最多能容忍 (n - 1) / 3 位叛将。</li>
</ul>
</li>
<li>签名消息型拜占庭问题之解<ul>
<li>忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现；</li>
<li>任何人都能验证将军签名的真伪。</li>
</ul>
</li>
</ul>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><ul>
<li>一致性（Consistency）<ul>
<li>一致性说的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失败。</li>
<li>一致性强调的是各节点间的数据一致。</li>
</ul>
</li>
<li>可用性（Availability）<ul>
<li>可用性说的是任何来自客户端的请求，不管访问哪个节点，都能得到响应数据，但不保证是同一份最新数据。我尽力给你返回数据，不会不响应你，但是我不保证每个节点给你的数据都是最新的。</li>
<li>这个指标强调的是服务可用，但不保证数据的一致。</li>
</ul>
</li>
<li>分区容错性（Partition Tolerance）<ul>
<li>当节点间出现任意数量的消息丢失或高延迟的时候，系统仍然可以继续提供服务。也就是说，分布式系统在告诉访问本系统的客户端：不管我的内部出现什么样的数据同步问题，我会一直运行，提供服务。</li>
<li>这个指标，强调的是集群对分区故障的容错能力。</li>
</ul>
</li>
</ul>
<p>CAP 不可能三角说的是对于一个分布式系统而言，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）3 个指标不可兼得，只能在 3 个指标中选择 2 个。节点间的分区故障是必然发生的。也就是说，分区容错性（P）是前提，是必须要保证的。</p>
<p>现在就只剩下一致性（C）和可用性（A）可以选择了：要么选择一致性，保证数据绝对一致；要么选择可用性，保证服务可用。那么 CP 和 AP 的含义是什么呢？</p>
<ul>
<li>当选择了一致性（C）的时候，如果因为消息丢失、延迟过高发生了网络分区，那么这个时候，当集群节点接收到来自客户端的写请求时，因为无法保证所有节点都是最新信息，所以系统将返回写失败错误，也就是说集群拒绝新数据写入。<ul>
<li>CP 模型，采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写入，典型的应用是 ZooKeeper，Etcd 和 HBase。</li>
</ul>
</li>
<li>当选择了可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点将无法返回最新的特定信息，它们将返回自己当前的相对新的信息。<ul>
<li>AP 模型，采用 AP 模型的分布式系统，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误，但当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。典型应用就比如 Cassandra 和 DynamoDB。</li>
</ul>
</li>
</ul>
<p>在不存在网络分区的情况下，也就是分布式系统正常运行时（这也是系统在绝大部分时候所处的状态），就是说在不需要 P 时，C 和 A 能够同时保证。只有当发生分区故障的时候，也就是说需要 P 时，才会在 C 和 A 之间做出选择。而且如果各节点数据不一致，影响到了系统运行或业务运行（也就是说会有负面的影响），推荐选择 C，否则选 A。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>二阶段提交<ul>
<li>提交请求（投票阶段），提交执行（完成阶段）</li>
<li>为了原子性</li>
<li>“协调者故障，参与者长期锁定资源”的痛点</li>
</ul>
</li>
<li>TCC（Try-Confirm-Cancel）<ul>
<li>TCC 是 Try（预留）、Confirm（确认）、Cancel（撤销）</li>
<li>它的核心思想是针对每个操作都要注册一个与其对应的确认操作和补偿操作（也就是撤销操作）。</li>
</ul>
</li>
</ul>
<h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><ul>
<li>基本可用（Basically Available）</li>
<li>最终一致性（Eventually consistent）</li>
<li>软状态（Soft state）</li>
</ul>
<h5 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h5><p>可以把基本可用理解成，当系统节点出现大规模故障的时候，比如专线的光纤被挖断、突发流量导致系统过载（出现了突发事件，服务被大量访问），这个时候可以通过服务降级，牺牲部分功能的可用性，保障系统的核心功能可用。</p>
<ul>
<li>流量削峰</li>
<li>延迟响应</li>
<li>体验降级， 比如用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。</li>
<li>过载保护， 比如把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求</li>
</ul>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性是说，系统中所有的数据副本在经过一段时间的同步后，最终能够达到一个一致的状态。也就是说，在数据一致性上，存在一个短暂的延迟。</p>
<p>你可以将强一致性理解为最终一致性的特例，也就是说，你可以把强一致性看作是不存在延迟的一致性。在实践中，你也可以这样思考： 如果业务的某功能无法容忍一致性的延迟（比如分布式锁对应的数据），需要实现的是强一致性；如果能容忍短暂的一致性的延迟（比如 QQ 状态数据），就可以考虑最终一致性。</p>
<p>那么如何实现最终一致性呢？你首先要知道它以什么为准，因为这是实现最终一致性的关键。一般来说，在实际工程实践中有这样几种方式：</p>
<ul>
<li>以最新写入的数据为准，比如 AP 模型的 KV 存储采用的就是这种方式；</li>
<li>以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准。</li>
</ul>
<p>那实现最终一致性的具体方式是什么呢？常用的有这样几种。</p>
<ul>
<li>读时修复：在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>
<li>写时修复：在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li>异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
<h2 id="一致哈希"><a href="#一致哈希" class="headerlink" title="一致哈希"></a>一致哈希</h2><p>我们通过 Raft 算法实现了 KV 存储，虽然领导者模型简化了算法实现和共识协商，但写请求只能限制在领导者节点上处理，导致了集群的接入性能约等于单机，那么随着业务发展，集群的性能可能就扛不住了，会造成系统过载和服务不可用，这时该怎么办呢？其实这是一个非常常见的问题。在我看来，这时我们就要通过分集群，突破单集群的性能限制了。</p>
<p>说到这儿，有同学可能会说了，分集群还不简单吗？加个 Proxy 层，由 Proxy 层处理来自客户端的读写请求，接收到读写请求后，通过对 Key 做哈希找到对应的集群就可以了啊。是的，哈希算法的确是个办法，但它有个明显的缺点：当需要变更集群数时（比如从 2 个集群扩展为 3 个集群），这时大部分的数据都需要迁移，重新映射，数据的迁移成本是非常高的。那么如何解决哈希算法，数据迁移成本高的痛点呢？答案就是一致哈希（Consistent Hashing）。</p>
<p>迁移成本是非常高昂的，这在实际生产环境中也是无法想象的。那我们如何通过一致哈希解决这个问题呢？</p>
<p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算。你可以想象下，一致哈希算法，将整个哈希值空间组织成一个虚拟的圆环，也就是哈希环：</p>
<p><img src="https://static001.geekbang.org/resource/image/3c/f5/3cb21a553580afbc840b68d4c6b128f5.jpg" alt="img"></p>
<p>从图 4 中你可以看到，哈希环的空间是按顺时针方向组织的，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、5、6……直到 2^32-1，也就是说 0 点左侧的第一个点代表 2^32-1。</p>
<p>在一致哈希中，你可以通过执行哈希算法（为了演示方便，假设哈希算法函数为“c-hash()”），将节点映射到哈希环上，比如选择节点的主机名作为参数执行 c-hash()，那么每个节点就能确定其在哈希环上的位置了：</p>
<p>当需要对指定 key 的值进行读写的时候，你可以通过下面 2 步进行寻址：</p>
<ul>
<li>首先，将 key 作为参数执行 c-hash() 计算哈希值，并确定此 key 在环上的位置；</li>
<li>然后，从这个位置沿着哈希环顺时针“行走”，遇到的第一节点就是 key 对应的节点。</li>
</ul>
<p>在一致哈希中，如果节点太少，容易因为节点分布不均匀造成数据访问的冷热不均，也就是说大多数访问请求都会集中少量几个节点上：</p>
<p>其实，就是对每一个服务器节点计算多个哈希值，在每个计算结果位置上，都放置一个虚拟节点，并将虚拟节点映射到实际节点。比如，可以在主机名的后面增加编号，分别计算 “Node-A-01”“Node-A-02”“Node-B-01”“Node-B-02”“Node-C-01”“Node-C-02”的哈希值，于是形成 6 个虚拟节点</p>
<h2 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h2><h4 id="Gossip-三板斧"><a href="#Gossip-三板斧" class="headerlink" title="Gossip 三板斧"></a>Gossip 三板斧</h4><ul>
<li><p>直接邮寄（Direct Mail）</p>
<ul>
<li>就是直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。</li>
</ul>
</li>
<li><p>反熵（Anti-entropy）</p>
<ul>
<li>如何实现最终一致性呢？答案就是反熵。本质上，反熵是一种通过异步修复实现最终一致性的方法反熵指的是集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性</li>
<li>推、拉和推拉三种方式</li>
<li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵</li>
<li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵</li>
<li>这个方式就是同时修复自己副本和对方副本中的熵</li>
</ul>
</li>
<li><p>谣言传播（Rumor mongering）</p>
<ul>
<li><p>如果是一个动态变化或节点数比较多的分布式环境（比如在 DevOps 环境中检测节点故障，并动态维护集群节点状态），这时反熵就不适用了。那么当你面临这个情况要怎样实现最终一致性呢？答案就是谣言传播。</p>
</li>
<li><p>广泛地散播谣言，它指的是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据</p>
</li>
</ul>
</li>
</ul>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce既是一个编程模型，又是一个计算框架。也就是说，开发人员必须基于MapReduce编程模型进行编程开发，然后将程序通过MapReduce计算框架分发到Hadoop集群中运行。</p>
<p>简单在于其编程模型只包含map和reduce两个过程，map的主要输入是一对&lt;key , value&gt;值，经过map计算后输出一对&lt;key , value&gt;值；然后将相同key合并，形成&lt;key , value集合&gt;；再将这个&lt;key , value集合&gt;输入reduce，经过计算输出零个或多个&lt;key , value&gt;对。</p>
<p>第一类称为Master，Master是负责调度的，相当于工地的工头。第二类叫Worker，相当于干活儿的工人。Woker进一步分为两种，一种Worker叫Mapper，另一种叫Reducer。假设我们有一个巨大的数据集，里面有海量规模的元素，元素的个数为M，每个元素都需要进行同一个函数处理。于是Master将M分成许多小份，然后每一份分给一个Mapper来做，Mapper干完活儿（执行完函数），将自己那一份儿活儿的结果传给Reducer。Reducer之后统计汇总各个Mapper传过来的结果，得到最后的任务的答案。</p>
<h3 id="WC为例"><a href="#WC为例" class="headerlink" title="WC为例"></a>WC为例</h3><h4 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">  line = line.strip()</span><br><span class="line">  word = line.split()</span><br><span class="line">  <span class="keyword">for</span> w <span class="keyword">in</span> words():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>对，就这么简单，你看到了，对于输入进来的每一行，我们做完切分之后，都会输出(单词，1)这样一个kv对，表明这个单词出现过。</p>
<h4 id="排序阶段"><a href="#排序阶段" class="headerlink" title="排序阶段"></a>排序阶段</h4><p>中间会有一个对上述结果进行排序的过程，以保证所有相同的单词都在一起，不过不用担心，这个过程是系统会自动完成的，因此不用我们编写额外的代码。</p>
<h4 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">current_word = <span class="literal">None</span></span><br><span class="line">current_count = <span class="number">0</span></span><br><span class="line">word = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依旧是标准输入过来的数据</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    <span class="comment"># 去除左右空格</span></span><br><span class="line">    line = line.strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照tab键对行切分，得到word和次数1</span></span><br><span class="line">    word, count = line.split(<span class="string">'\t'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你得到的1是一个字符串，需要对它进行类型转化</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        count = int(count)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="comment">#如果不能转成数字，输入有问题，调到下一行</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果本次读取的单词和上一次一样，对次数加1</span></span><br><span class="line">    <span class="keyword">if</span> current_word == word:</span><br><span class="line">        current_count += count</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> current_word:</span><br><span class="line">            <span class="comment"># 输出统计结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (current_word, current_count)</span><br><span class="line">        current_count = count</span><br><span class="line">        current_word = word</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要忘了最后一个词哦，也得输出结果</span></span><br><span class="line"><span class="keyword">if</span> current_word == word:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (current_word, current_count)</span><br></pre></td></tr></table></figure>

<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop的核心，说白了，就是HDFS和MapReduce。HDFS为海量数据提供了<strong>存储</strong>，而MapReduce为海量数据提供了<strong>计算框架</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-af31c33db7daa0761da1ed03327154fd_1440w.jpg" alt="img"></p>
<p>首先看看<strong>HDFS</strong></p>
<p>整个HDFS有三个重要角色：<strong>NameNode</strong>（名称节点）、<strong>DataNode</strong>（数据节点）和<strong>Client</strong>（客户机）。</p>
<p><strong>NameNode：</strong>是Master节点（主节点），可以看作是分布式文件系统中的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Meta-data存储在内存中，这些信息主要包括了文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode的信息等。</p>
<p><strong>DataNode：</strong>是Slave节点（从节点），是文件存储的基本单元，它将Block存储在本地文件系统中，保存了Block的Meta-data，同时周期性地将所有存在的Block信息发送给NameNode。</p>
<p><strong>Client：</strong>切分文件；访问HDFS；与NameNode交互，获得文件位置信息；与DataNode交互，读取和写入数据。 </p>
<p>还有一个<strong>Block（块）</strong>的概念：Block是HDFS中的基本读写单元；HDFS中的文件都是被切割为block（块）进行存储的；这些块被复制到多个DataNode中；块的大小（通常为64MB）和复制的块数量在创建文件时由Client决定。</p>
<p><strong>HBase</strong>：来源于Google的BigTable；是一个高可靠性、高性能、面向列、可伸缩的分布式数据库。</p>
<p><strong>高效性</strong>：Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。</p>
<p><strong>高容错性</strong>：Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。这个其实也算是高可靠性。</p>
<p><strong>MapReduce是面向磁盘的</strong>。因此，受限于磁盘读写性能的约束，MapReduce在处理迭代计算、实时计算、交互式数据查询等方面并不高效。但是，这些计算却在图计算、数据挖掘和<strong>机器学习</strong>等相关应用领域中非常常见。</p>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>而<strong>Spark是面向内存的</strong>。这使得Spark能够为多个不同数据源的数据提供近乎实时的处理性能，适用于需要多次操作特定数据集的应用场景。</p>
<p>Spark 基于 Hadoop MapReduce 算法实现的分布式计算，拥有 Hadoop MapReduce 所具有的优点，并且具有更高的运算速度。Spark 能够比 Hadoop 运算更快，主要原因是：Hadoop 在一次 MapReduce 运算之后，会将数据的运算结果从内存写入到磁盘中，第二次 MapReduce 运算时在从磁盘中读取数据，两次对磁盘的操作，增加了多余的 IO 消耗；而 Spark 则是将数据一直缓存在内存中，运算时直接从内存读取数据，只有在必要时，才将部分数据写入到磁盘中。除此之外，Spark 使用最先进的 DAG（Directed Acyclic Graph,有向无环图）调度程序、查询优化器和物理执行引擎，在处理批量处理以及处理流数据时具有较高的性能。按照<a href="https://spark.apache.org/" target="_blank" rel="noopener">Spark 官网</a>的说法，Spark 相对于 Hadoop 而言，Spark 能够达到 100 倍以上的运行负载。</p>
<p><strong>SparkContext：</strong>是 Spark 所有功能的主要入口点，它是用户逻辑与 Spark 集群主要的交互接口。通过<strong>SparkContext</strong>，可以连接到集群管理器（<strong>Cluster Manager</strong>），能够直接与集群 Master 节点进行交互，并能够向 Master 节点申请计算资源，也能够将应用程序用到的 JAR 包或 Python 文件发送到多个执行器（<strong>Executor</strong>）节点上。</p>
<p><strong>Cluster Manager：</strong>即集群管理器，它存在于 Master 进程中，主要用来对应用程序申请的资源进行管理。</p>
<p><strong>Worker Node：</strong>任何能够在集群中能够运行 Spark 应用程序的节点。</p>
<p><strong>Task：</strong>由<strong>SparkContext</strong>发送到<strong>Executor</strong>节点上执行的一个工作单元。</p>
<p><strong>Executor：</strong>也即执行器节点，它是在一个在工作节点（<strong>Worker Node</strong>）上为<strong>Application</strong>启动的进程，它能够运行 Task 并将数据保存在内存或磁盘存储中，也能够将结果数据返回给<strong>Driver</strong>。</p>
<h4 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h4><p>即弹性分布式数据集（Resilient Distributed Datasets），是一种容错的、可以被并行操作的元素集合，它是 Spark 中最重要的一个概念，是 Spark 对所有数据处理的一种基本抽象。Spark 中的计算过程可以简单抽象为对 RDD 的创建、转换和返回操作结果的过程：</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/3ad43d47-e95f-4144-b3b8-d2181394d449/640.png" alt="img"></p>
<p><strong>makeRDD：</strong>可以通过访问外部物理存储（如 HDFS），通过调用 SparkContext.textFile()方法来读取文件并创建一个 RDD，也可以对输入数据集合通过调用 SparkContext.parallelize()方法来创建一个 RDD。<strong>RDD 被创建后不可被改变，只可以对 RDD 执行 Transformation 及 Action 操作。</strong></p>
<p><strong>Transformation（转换）：</strong>对已有的 RDD 中的数据执行计算进行转换，并产生新的 RDD，在这个过程中有时会产生中间 RDD。Spark 对于<strong>Transformation</strong>采用惰性计算机制，即在 Transformation 过程并不会立即计算结果，而是在 Action 才会执行计算过程。如<strong>map</strong>、<strong>filter</strong>、<strong>groupByKey、cache</strong>等方法，只执行<strong>Transformation</strong>操作，而不计算结果。</p>
<p><strong>Action（执行）：</strong>对已有的 RDD 中的数据执行计算产生结果，将结果返回 Driver 程序或写入到外部物理存储（如 HDFS）。如<strong>reduce</strong>、<strong>collect</strong>、<strong>count</strong>、<strong>saveAsTextFile</strong>等方法，会对 RDD 中的数据执行计算。</p>
<p><strong>partition（分区）</strong>是 Spark 中的重要概念，它是<strong>RDD</strong>的最小单元，<strong>RDD</strong>是由分布在各个节点上的<strong>partition</strong> 组成的。<strong>partition</strong>的数量决定了<strong>task</strong>的数量，每个<strong>task</strong>对应着一个<strong>partition</strong>。</p>
<p>例如，使用 Spark 来读取本地文本文件内容，读取完后，这些内容将会被分成多个<strong>partition</strong>，这些<strong>partition</strong>就组成了一个<strong>RDD</strong>，同时这些<strong>partition</strong>可以分散到不同的机器上执行。RDD 的 partition 描述如下图所示：</p>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>从本质上说，Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。raft解决的问题就是如何让多个副本的<strong>日志</strong>数据达成一致。</p>
<h4 id="为什么要51"><a href="#为什么要51" class="headerlink" title="为什么要51%"></a>为什么要51%</h4><ol>
<li>考虑 2N+1 个节点。一份数据，至少需要复制到 N+1 个节点上才算是提交（commit），否则可能出现冲突。比方说事件 x=1 发到 N 个节点，同时事件 x=2 发到另外 N 个节点。如果 x=1 和 x=2 同时提交了，最终 x 的值是多少很难说清。这和多线程锁是一样的。2N 个节点的情况也同理。</li>
<li>一份数据复制到 N 个节点上，如果要容忍 K 个错误，需要 K &lt; N，这样才能保证复制到 N 个节点满足数据提交的要求。也就是说，N 个节点，最多容忍 N-1 个错误。</li>
</ol>
<p>我也时常在想一个问题，为什么多数一致性协议都要求过半节点复制成功才算提交？3 个节点，复制到 2 个才算提交（2/3）；5 个节点，复制到 3 个才算提交（3/5）。为什么没有一个专门优化 4/6 或者 4/5 的协议？</p>
<p>我觉得可能是“<strong>过半</strong>”这个 constraint 足够松，它能够最大程度容忍错误，能够最小程度上保证提交。</p>
<h4 id="如何选举领导者"><a href="#如何选举领导者" class="headerlink" title="如何选举领导者"></a>如何选举领导者</h4><p>成员身份，又叫做服务器节点状态，Raft 算法支持<strong>领导者（Leader）、跟随者（Follower）和候选人（Candidate）</strong> 3 种状态。</p>
<p>跟随者：就相当于普通群众，默默地接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。</p>
<p>候选人：候选人将向其他节点发送请求投票（RequestVote）RPC 消息，通知其他节点来投票，如果赢得了大多数选票，就晋升当领导者。</p>
<p>领导者：蛮不讲理的霸道总裁，一切以我为准，平常的主要工作内容就是 3 部分，处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们现在不要发起新的选举，找个新领导者来替代我。”</p>
<p><strong>Raft 算法是强领导者模型，集群中只能有一个“霸道总裁”。</strong></p>
<h5 id="选举领导者的过程"><a href="#选举领导者的过程" class="headerlink" title="选举领导者的过程"></a>选举领导者的过程</h5><p>每个节点等待领导者节点心跳信息的超时时间间隔是随机的。通过上面的图片你可以看到，集群中没有领导者，而节点 A 的等待超时时间最小（150ms），它会最先因为没有等到领导者的心跳信息，发生超时。</p>
<p>这个时候，节点 A 就增加自己的任期编号，并推举自己为候选人，先给自己投上一张选票，然后向其他节点发送请求投票 RPC 消息，请它们选举自己为领导者</p>
<p>如果其他节点接收到候选人 A 的请求投票 RPC 消息，在编号为 1 的这届任期内，也还没有进行过投票，那么它将把选票投给节点 A，并增加自己的任期编号。</p>
<p>如果候选人在选举超时时间内赢得了大多数的选票，那么它就会成为本届任期内新的领导者。</p>
<p>节点 A 当选领导者后，他将周期性地发送心跳消息，通知其他服务器我是领导者，阻止跟随者发起新的选举，篡权。</p>
<h5 id="节点间如何通讯？"><a href="#节点间如何通讯？" class="headerlink" title="节点间如何通讯？"></a>节点间如何通讯？</h5><p>在 Raft 算法中，服务器节点间的沟通联络采用的是远程过程调用（RPC），在领导者选举中，需要用到这样两类的 RPC：</p>
<ol>
<li>请求投票（RequestVote）RPC，是由候选人在选举期间发起，通知各节点进行投票；</li>
<li>日志复制（AppendEntries）RPC，是由领导者发起，用来复制日志和提供心跳消息。</li>
</ol>
<p><strong>日志复制 RPC 只能由领导者发起</strong></p>
<h5 id="什么是任期"><a href="#什么是任期" class="headerlink" title="什么是任期"></a>什么是任期</h5><ol>
<li>跟随者在等待领导者心跳信息超时后，推举自己为候选人时，会增加自己的任期号，比如节点 A 的当前任期编号为 0，那么在推举自己为候选人时，会将自己的任期编号增加为 1。</li>
<li>如果一个服务器节点，发现自己的任期编号比其他节点小，那么它会更新自己的编号到较大的编号值。比如节点 B 的任期编号是 0，当收到来自节点 A 的请求投票 RPC 消息时，因为消息中包含了节点 A 的任期编号，且编号为 1，那么节点 B 将把自己的任期编号更新为 1。</li>
</ol>
<p>Raft 算法中的任期不只是时间段，而且任期编号的大小，会影响领导者选举和请求的处理。</p>
<ol>
<li>在 Raft 算法中约定，如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态。比如分区错误恢复后，任期编号为 3 的领导者节点 B，收到来自新领导者的，包含任期编号为 4 的心跳消息，那么节点 B 将立即恢复成跟随者状态。</li>
<li>还约定如果一个节点接收到一个包含较小的任期编号值的请求，那么它会直接拒绝这个请求。比如节点 C 的任期编号为 4，收到包含任期编号为 3 的请求投票 RPC 消息，那么它将拒绝这个消息。</li>
</ol>
<h5 id="选举有哪些规则"><a href="#选举有哪些规则" class="headerlink" title="选举有哪些规则"></a>选举有哪些规则</h5><ol>
<li>领导者周期性地向所有跟随者发送心跳消息（即不包含日志项的日志复制 RPC 消息），通知大家我是领导者，阻止跟随者发起新的选举。</li>
<li>如果在指定时间内，跟随者没有接收到来自领导者的消息，那么它就认为当前没有领导者，推举自己为候选人，发起领导者选举。</li>
<li>在一次选举中，赢得大多数选票的候选人，将晋升为领导者。</li>
<li>在一个任期内，领导者一直都会是领导者，直到它自身出现问题（比如宕机），或者因为网络延迟，其他节点发起一轮新的选举。</li>
<li>在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，并且按照“先来先服务”的原则进行投票。比如节点 C 的任期编号为 3，先收到了 1 个包含任期编号为 4 的投票请求（来自节点 A），然后又收到了 1 个包含任期编号为 4 的投票请求（来自节点 B）。那么节点 C 将会把唯一一张选票投给节点 A，当再收到节点 B 的投票请求 RPC 消息时，对于编号为 4 的任期，已没有选票可投了。</li>
<li>当任期编号相同时，日志完整性高的跟随者（也就是最后一条日志项对应的任期编号值更大，索引号更大），拒绝投票给日志完整性低的候选人。比如节点 B、C 的任期编号都是 3，节点 B 的最后一条日志项对应的任期编号为 3，而节点 C 为 2，那么当节点 C 请求节点 B 投票给自己时，节点 B 将拒绝投票。</li>
<li>选举是跟随者发起的，推举自己为候选人；大多数选票是指集群成员半数以上的选票；大多数选票规则的目标，是为了保证在一个给定的任期内最多只有一个领导者。</li>
</ol>
<p>其实在选举中，除了选举规则外，我们还需要避免一些会导致选举失败的情况，比如同一任期内，多个候选人同时发起选举，导致选票被瓜分，选举失败。那么在 Raft 算法中，如何避免这个问题呢？答案就是随机超时时间。</p>
<h5 id="随机超时时间"><a href="#随机超时时间" class="headerlink" title="随机超时时间"></a>随机超时时间</h5><p>在议会选举中，常出现未达到指定票数，选举无效，需要重新选举的情况。在 Raft 算法的选举中，也存在类似的问题，那它是如何处理选举无效的问题呢？</p>
<ol>
<li>跟随者等待领导者心跳信息超时的时间间隔，是随机的；</li>
<li>当没有候选人赢得过半票数，选举无效了，这时需要等待一个随机时间间隔，也就是说，等待选举超时的时间间隔，是随机的。</li>
</ol>
<p>Raft 算法和兰伯特的 Multi-Paxos 不同之处，主要有 2 点。首先，在 Raft 中，不是所有节点都能当选领导者，只有日志最完整的节点，才能当选领导者；其次，在 Raft 中，日志必须是连续的。</p>
<p>本质上，Raft 算法以领导者为中心，选举出的领导者，以“一切以我为准”的方式，达成值的共识，和实现各节点日志的一致。</p>
<h4 id="如何复制日志"><a href="#如何复制日志" class="headerlink" title="如何复制日志"></a>如何复制日志</h4><h5 id="如何理解日志"><a href="#如何理解日志" class="headerlink" title="如何理解日志"></a>如何理解日志</h5><p>副本数据是以日志的形式存在的，日志是由日志项组成，日志项究竟是什么样子呢？</p>
<p>其实，日志项是一种数据格式，它主要包含用户指定的数据，也就是指令（Command），还包含一些附加信息，比如索引值（Log index）、任期编号（Term）。那你该怎么理解这些信息呢？</p>
<ul>
<li><p>指令：一条由客户端请求指定的、状态机需要执行的指令。你可以将指令理解成客户端指定的数据。</p>
</li>
<li><p>索引值：日志项对应的整数索引值。它其实就是用来标识日志项的，是一个连续的、单调递增的整数号码。</p>
</li>
<li><p>任期编号：创建这条日志项的领导者的任期编号。</p>
</li>
</ul>
<h5 id="如何复制"><a href="#如何复制" class="headerlink" title="如何复制"></a>如何复制</h5><p>你可以把 Raft 的日志复制理解成一个优化后的二阶段提交（将二阶段优化成了一阶段），减少了一半的往返消息，也就是降低了一半的消息延迟。那日志复制的具体过程是什么呢？</p>
<p>首先，领导者进入第一阶段，通过日志复制（AppendEntries）RPC 消息，将日志项复制到集群其他节点上。</p>
<p>接着，如果领导者接收到大多数的“复制成功”响应后，它将日志项提交到它的状态机，并返回成功给客户端。如果领导者没有接收到大多数的“复制成功”响应，那么就返回错误给客户端。</p>
<p>学到这里，有同学可能有这样的疑问了，领导者将日志项提交到它的状态机，怎么没通知跟随者提交日志项呢？</p>
<p>这是 Raft 中的一个优化，领导者不直接发送消息通知其他节点提交指定日志项。因为领导者的日志复制 RPC 消息或心跳消息，包含了当前最大的，将会被提交的日志项索引值。所以通过日志复制 RPC 消息或心跳消息，跟随者就可以知道领导者的日志提交位置信息。</p>
<p>因此，当其他节点接受领导者的心跳消息，或者新的日志复制 RPC 消息后，就会将这条日志项提交到它的状态机。而这个优化，降低了处理客户端请求的延迟，将二阶段提交优化为了一段提交，降低了一半的消息延迟。</p>
<ol>
<li>接收到客户端请求后，领导者基于客户端请求中的指令，创建一个新日志项，并附加到本地日志中。</li>
<li>领导者通过日志复制 RPC，将新的日志项复制到其他的服务器。</li>
<li>当领导者将日志项，成功复制到大多数的服务器上的时候，领导者会将这条日志项提交到它的状态机中。</li>
<li>领导者将执行的结果返回给客户端。</li>
<li>当跟随者接收到心跳信息，或者新的日志复制 RPC 消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没提交，那么跟随者就将这条日志项提交到本地的状态机中。</li>
</ol>
<h5 id="如何实现日志的一致"><a href="#如何实现日志的一致" class="headerlink" title="如何实现日志的一致"></a>如何实现日志的一致</h5><p>在 Raft 算法中，领导者通过强制跟随者直接复制自己的日志项，处理不一致日志。也就是说，Raft 是通过以领导者的日志为准，来实现各节点日志的一致的。具体有 2 个步骤。</p>
<ol>
<li>首先，领导者通过日志复制 RPC 的一致性检查，找到跟随者节点上，与自己相同日志项的最大索引值。也就是说，这个索引值之前的日志，领导者和跟随者是一致的，之后的日志是不一致的了。</li>
<li>然后，领导者强制跟随者更新覆盖的不一致日志项，实现日志的一致。</li>
</ol>
<h4 id="如何解决成员变更"><a href="#如何解决成员变更" class="headerlink" title="如何解决成员变更"></a>如何解决成员变更</h4><p>因为 Raft 的领导者选举，建立在“大多数”的基础之上，那么当成员变更时，集群成员发生了变化，就可能同时存在新旧配置的 2 个“大多数”，出现 2 个领导者，破坏了 Raft 集群的领导者唯一性，影响了集群的运行。</p>
<p>而关于成员变更，不仅是 Raft 算法中比较难理解的一部分，非常重要，也是 Raft 算法中唯一被优化和改进的部分。比如，最初实现成员变更的是联合共识（Joint Consensus），但这个方法实现起来难，后来 Raft 的作者就提出了一种改进后的方法，单节点变更（single-server changes）。</p>
<p>在我看来，在集群中进行成员变更的最大风险是，可能会同时出现 2 个领导者。比如在进行成员变更时，节点 A、B 和 C 之间发生了分区错误，节点 A、B 组成旧配置中的“大多数”，也就是变更前的 3 节点集群中的“大多数”，那么这时的领导者（节点 A）依旧是领导者。</p>
<h5 id="如何通过单节点变更解决成员变更的问题？"><a href="#如何通过单节点变更解决成员变更的问题？" class="headerlink" title="如何通过单节点变更解决成员变更的问题？"></a>如何通过单节点变更解决成员变更的问题？</h5><p>单节点变更，就是通过一次变更一个节点实现成员变更。如果需要变更多个节点，那你需要执行多次单节点变更。比如将 3 节点集群扩容为 5 节点集群，这时你需要执行 2 次单节点变更，先将 3 节点集群变更为 4 节点集群，然后再将 4 节点集群变更为 5 节点集群</p>
<p>目前的集群配置为[A, B, C]，我们先向集群中加入节点 D，这意味着新配置为[A, B, C, D]。成员变更，是通过这么两步实现的：</p>
<ol>
<li>领导者（节点 A）向新节点（节点 D）同步数据；</li>
<li>领导者（节点 A）将新配置[A, B, C, D]作为一个日志项，复制到新配置中所有节点（节点 A、B、C、D）上，然后将新配置的日志项提交到本地状态机，完成单节点变更。</li>
</ol>
<p>管旧的集群配置是怎么组成的，旧配置的“大多数”和新配置的“大多数”都会有一个节点是重叠的。 也就是说，不会同时存在旧配置和新配置 2 个“大多数”</p>
<p>不管集群是偶数节点，还是奇数节点，不管是增加节点，还是移除节点，新旧配置的“大多数”都会存在重叠</p>
<p>在分区错误、节点故障等情况下，如果我们并发执行单节点变更，那么就可能出现一次单节点变更尚未完成，新的单节点变更又在执行，导致集群出现 2 个领导者的情况。如果你遇到这种情况，可以在领导者启动时，创建一个 NO_OP 日志项（也就是空日志项），只有当领导者将 NO_OP 日志项提交后，再执行成员变更请求。</p>
<p>有很多同学把 Raft 当成一致性算法，其实 Raft 不是一致性算法而是共识算法，是一个 Multi-Paxos 算法，实现的是如何就一系列值达成共识。并且，Raft 能容忍少数节点的故障。虽然 Raft 算法能实现强一致性，也就是线性一致性（Linearizability），但需要客户端协议的配合。在实际场景中，我们一般需要根据场景特点，在一致性强度和实现复杂度之间进行权衡。比如 Consul 实现了三种一致性模型。</p>
<ol>
<li>default：客户端访问领导者节点执行读操作，领导者确认自己处于稳定状态时（在 leader leasing 时间内），返回本地数据给客户端，否则返回错误给客户端。在这种情况下，客户端是可能读到旧数据的，比如此时发生了网络分区错误，新领导者已经更新过数据，但因为网络故障，旧领导者未更新数据也未退位，仍处于稳定状态。</li>
<li>consistent：客户端访问领导者节点执行读操作，领导者在和大多数节点确认自己仍是领导者之后返回本地数据给客户端，否则返回错误给客户端。在这种情况下，客户端读到的都是最新数据。</li>
<li>stale：从任意节点读数据，不局限于领导者节点，客户端可能会读到旧数据。</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h5><p>生产流程：</p>
<p>1）生产者将生产消息的请求发往Leader的Raft模块。</p>
<p>2）Raft模块完成Entry的创建和同步。</p>
<p>3）大多数节点上持久化并返回成功后Entry标记为Committed。</p>
<p>4）所有节点的State Machine应用该日志，取出实际的生产请求，将消息内容写入磁盘，更新ApplyIndex。该步骤不需要刷盘。</p>
<p>5）Leader回复客户端Confirm，通知生产成功。</p>
<p>6）如果此后机器重启，通过raft日志恢复生产消息，保证了已Confirm的消息不丢失。</p>
<p>消费流程：</p>
<p>1）消费者从Leader节点拉取消息。</p>
<p>2）Leader收到后从磁盘加载未删除的消息投递给客户端。</p>
<p>3）客户端处理完成后Ack消息，通知服务器删除消息。</p>
<p>4）Ack请求经Raft同步后标记为Committed。</p>
<p>5）各节点状态机应用该日志，将消息对应的bit置位，将其设置为已删除并更新ApplyIndex。</p>
<p>6）通知客户端删除成功。</p>
<p>7）如果机器重启，通过Raft日志恢复Ack请求，保证了已删除的消息不会再投递。</p>
<p>##PoW</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/分布式/" rel="tag"># 分布式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/11/tree-structure/" rel="next" title="【面试系列】- 常用树结构">
                <i class="fa fa-chevron-left"></i> 【面试系列】- 常用树结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/24/os-simple/" rel="prev" title="【面试准备简明版】- 操作系统">
                【面试准备简明版】- 操作系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ReStartercc</p>
              <p class="site-description motion-element" itemprop="description">Contact restartercc@gmail.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式系统原则"><span class="nav-number">1.</span> <span class="nav-text">分布式系统原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拜占庭将军问题"><span class="nav-number">1.0.1.</span> <span class="nav-text">拜占庭将军问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAP"><span class="nav-number">1.0.2.</span> <span class="nav-text">CAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID"><span class="nav-number">1.0.3.</span> <span class="nav-text">ACID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BASE"><span class="nav-number">1.0.4.</span> <span class="nav-text">BASE</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本可用"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">基本可用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最终一致性"><span class="nav-number">1.0.5.</span> <span class="nav-text">最终一致性</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#一致哈希"><span class="nav-number">2.</span> <span class="nav-text">一致哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gossip-协议"><span class="nav-number">3.</span> <span class="nav-text">Gossip 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Gossip-三板斧"><span class="nav-number">3.0.1.</span> <span class="nav-text">Gossip 三板斧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce"><span class="nav-number">4.</span> <span class="nav-text">MapReduce</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WC为例"><span class="nav-number">4.1.</span> <span class="nav-text">WC为例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map阶段"><span class="nav-number">4.1.1.</span> <span class="nav-text">Map阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序阶段"><span class="nav-number">4.1.2.</span> <span class="nav-text">排序阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reduce阶段"><span class="nav-number">4.1.3.</span> <span class="nav-text">Reduce阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hadoop"><span class="nav-number">5.</span> <span class="nav-text">Hadoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spark"><span class="nav-number">6.</span> <span class="nav-text">Spark</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDD"><span class="nav-number">6.0.1.</span> <span class="nav-text">RDD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft"><span class="nav-number">7.</span> <span class="nav-text">Raft</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要51"><span class="nav-number">7.0.1.</span> <span class="nav-text">为什么要51%</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何选举领导者"><span class="nav-number">7.0.2.</span> <span class="nav-text">如何选举领导者</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#选举领导者的过程"><span class="nav-number">7.0.2.1.</span> <span class="nav-text">选举领导者的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#节点间如何通讯？"><span class="nav-number">7.0.2.2.</span> <span class="nav-text">节点间如何通讯？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是任期"><span class="nav-number">7.0.2.3.</span> <span class="nav-text">什么是任期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选举有哪些规则"><span class="nav-number">7.0.2.4.</span> <span class="nav-text">选举有哪些规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#随机超时时间"><span class="nav-number">7.0.2.5.</span> <span class="nav-text">随机超时时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何复制日志"><span class="nav-number">7.0.3.</span> <span class="nav-text">如何复制日志</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何理解日志"><span class="nav-number">7.0.3.1.</span> <span class="nav-text">如何理解日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何复制"><span class="nav-number">7.0.3.2.</span> <span class="nav-text">如何复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何实现日志的一致"><span class="nav-number">7.0.3.3.</span> <span class="nav-text">如何实现日志的一致</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决成员变更"><span class="nav-number">7.0.4.</span> <span class="nav-text">如何解决成员变更</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何通过单节点变更解决成员变更的问题？"><span class="nav-number">7.0.4.1.</span> <span class="nav-text">如何通过单节点变更解决成员变更的问题？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用场景"><span class="nav-number">7.0.5.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MQ"><span class="nav-number">7.0.5.1.</span> <span class="nav-text">MQ</span></a></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ReStartercc</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
