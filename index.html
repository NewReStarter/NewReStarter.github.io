<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Contact restartercc@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Restartercc">
<meta property="og:url" content="NewReStarter.github.io/index.html">
<meta property="og:site_name" content="Restartercc">
<meta property="og:description" content="Contact restartercc@gmail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Restartercc">
<meta name="twitter:description" content="Contact restartercc@gmail.com">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="NewReStarter.github.io/">





  <title>Restartercc</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Restartercc</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习计算机科学和数学，尝试了解这个世界</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2020/03/24/database-simple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/24/database-simple/" itemprop="url">【面试准备简明版】- 数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T13:45:49+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h1><h3 id="1-数据库引擎类型"><a href="#1-数据库引擎类型" class="headerlink" title="1. 数据库引擎类型"></a>1. 数据库引擎类型</h3><ol>
<li><p>INNODB：</p>
<ol>
<li>支持事务，行级锁和表级锁，默认为行级锁，支持外键。</li>
<li>ACID事务支持</li>
<li>支持B+树索引、全文索引、哈希索引（<strong>InnoDB用户无法手动创建哈希索引</strong>，<strong>InnoDB自己会建立相关哈希索引</strong>）</li>
<li>InnoDB 存储引擎采用“聚集索引”的数据存储方式实现B+Tree索引 主键索引 既存储索引值,又在叶子中存储行的数据。聚簇索引的文件存放在主键索引的叶子节点上。</li>
<li>而对于辅助索引，InnoDB采用的方式是在叶子页中保存主键值，通过这个主键值来回表（上图）查询到一条完整记录，因此按辅助索引检索实际上进行了二次查询，效率肯定是没有按照主键检索高的。</li>
<li>因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li>
</ol>
</li>
<li><p>MyISAM</p>
<ol>
<li><p>通常是MySQL的默认引擎，不支持外键</p>
</li>
<li><p>非事务安全型，采用表级锁，并发支持差</p>
</li>
<li><p>提供高速存储和检索，以及全文搜索能力</p>
</li>
<li><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些地址来读取页，进而读取被索引的行。</p>
</li>
<li><p>myisam的主键索引的叶子节点只存放数据在物理磁盘上的指针，其他次索引也是一样的；<br>innodb的主键索引的叶子节点下面直接存放数据，其他次索引的叶子节点指向主键id；</p>
</li>
<li><p>支持RTree 索引 和 Fulltext索引</p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>Memory</p>
<ol>
<li>将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。</li>
<li>数据部分以<strong>数组</strong>的方式单独存放，主键索引（采用<strong>哈希索引</strong>）存的是<strong>数据位置</strong></li>
<li>Memory表也支持B-Tree索引</li>
<li>不支持行锁，<strong>只支持表锁</strong>（并不是MDL锁），<strong>对并发访问的支持不够好</strong></li>
<li>支持哈希和b-tree索引</li>
</ol>
</li>
</ol>
<h3 id="MyISAM-为什么读比-InnoDB块"><a href="#MyISAM-为什么读比-InnoDB块" class="headerlink" title="MyISAM 为什么读比 InnoDB块"></a>MyISAM 为什么读比 InnoDB块</h3><ol>
<li>INNODB要缓存数据块，MyISAM只缓存索引块，换进换出少</li>
<li>innodb寻址映射到数据块，再到行，MyISAM直接记录文件的OFFSET，定位更快</li>
<li></li>
</ol>
<h1 id="数据库数据存在哪里"><a href="#数据库数据存在哪里" class="headerlink" title="数据库数据存在哪里"></a>数据库数据存在哪里</h1><ul>
<li>索引加快数据查询速度，提高数据库查询性能。</li>
</ul>
<ol>
<li><h5 id="弊："><a href="#弊：" class="headerlink" title="弊："></a>弊：</h5></li>
</ol>
<ul>
<li>数据库中索引是以文件的方式存储的，需要用的时候读取到内存中，因此索引的I/O操作会影响数据库的性能；</li>
<li>此外插入和更新操作会更改索引，因此会影响数据库插入和更新的性能，并且索引会占用一定的磁盘空间，使数据库变大。</li>
</ul>
<h1 id="数据库语法"><a href="#数据库语法" class="headerlink" title="数据库语法"></a>数据库语法</h1><h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接(Natural join)是一种特殊的等值连接，要求两个关系表中进行比较的属性组必须是名称相同的属性组，并且在结果中把重复的属性列去掉（即：留下名称相同的属性组中的其中一组）</p>
<p>自然连接将两个关系组中在相同名称的属性上具有相同的值的行记录进行匹配（表A和表B中的Bid属性相等的行记录），并且重复的属性列去掉，这样新的一行将出现在查询结果中，而那些没被匹配的行不出现在结果中（结合A、B表和查询的结果可以看出来）。因此自然连接的结果会有数据丢失，这些丢失的数据就是那些没有匹配的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> A <span class="keyword">natural</span> <span class="keyword">join</span> B</span><br></pre></td></tr></table></figure>

<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a,stu <span class="keyword">as</span> b <span class="keyword">where</span> a.sutid = b.stuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h4><p>以左表为基准，将a.stuid = b.stuid的数据进行连接，然后将左表没有的对应项显示，右表的列为NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">left</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h4 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h4><p>是以右表为基准，将a.stuid = b.stuid的数据进行连接，然以将右表没有的对应项显示，左表的列为NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">right</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h4 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h4><p>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h3 id="交叉连接（笛卡尔积）"><a href="#交叉连接（笛卡尔积）" class="headerlink" title="交叉连接（笛卡尔积）"></a>交叉连接（笛卡尔积）</h3><p>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from book as a cross join stu as b order by a.id</span><br></pre></td></tr></table></figure>

<h3 id="on-和-where-的区别"><a href="#on-和-where-的区别" class="headerlink" title="on 和 where 的区别"></a>on 和 where 的区别</h3><p>inner join中on和where没区别，</p>
<p>使用left join时on后面的条件只对右表有效</p>
<p>right join 时后面的条件只对左表有效</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>所以数据库引入事务的主要目的是事务会把数据库会从一种一致状态转换到另一种一致状态，数据库提交工作时可以确保要么所有修改都保存，要么所有修改都不保存。</p>
<h4 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h4><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<h4 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h4><p> 数据库总是从一个一致性的状态转换到另一个一致性的状态。在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，前面执行的语句也不会生效。因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。</p>
<h4 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h4><p> 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。当执行完第三条语句、第四条语句还未开始时，此时有另外一个程序开始运行，则看不到第三条语句做出的改变。</p>
<h4 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h4><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证策略。</p>
<h4 id="undo-log-保证原子性"><a href="#undo-log-保证原子性" class="headerlink" title="undo log 保证原子性"></a>undo log 保证原子性</h4><p>undo log主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p>
<h4 id="redo-log保证持久性和一致性"><a href="#redo-log保证持久性和一致性" class="headerlink" title="redo log保证持久性和一致性"></a>redo log保证持久性和一致性</h4><p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p>
<p>在系统启动的时候，就已经为redo log分配了一块连续的存储空间,以顺序追加的方式记录Redo Log,通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</p>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><h3 id="四个隔离级别"><a href="#四个隔离级别" class="headerlink" title="四个隔离级别"></a>四个隔离级别</h3><h4 id="读未提交-Read-uncommitted"><a href="#读未提交-Read-uncommitted" class="headerlink" title="读未提交  Read uncommitted"></a>读未提交  Read uncommitted</h4><p>其隔离级别最低，允许脏读。换句话说就是，如果一个事务正在处理某一数据，并对其进行了更新，但是同时没有提交事务，允许另一个事务也可以访问</p>
<p>事务在读数据的时候并未对数据加锁。</p>
<p>事务在修改数据的时候只对数据增加行级共享锁。</p>
<p>该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</p>
<h4 id="读已提交-Read-committed"><a href="#读已提交-Read-committed" class="headerlink" title="读已提交  Read committed"></a>读已提交  Read committed</h4><p>和读未提交的区别就是。读未提交可以读取到别人没有提交的数据，但是读已提交只能读取到别人提交后的值，事务进行的中间值不会读取到</p>
<p>事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；</p>
<p>事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</p>
<p>这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。导致这种情况的原因可能有：</p>
<ul>
<li><p>有一个交叉的事务有新的commit，导致了数据的改变;</p>
</li>
<li><p>一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</p>
</li>
</ul>
<h4 id="可重复读-Repeatable-read"><a href="#可重复读-Repeatable-read" class="headerlink" title="可重复读  Repeatable read"></a>可重复读  Repeatable read</h4><p>简单来说就是事务处理过程中多次读取同一个数据的时候，这个值不会发生改变，其值都和第一次查询到的数据是一致的，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p>
<p>它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</p>
<p>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；</p>
<p>事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</p>
<p>此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” </p>
<p>InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决幻读问题；InnoDB还通过间隙锁解决幻读问题。</p>
<h4 id="可串行化-Serializable"><a href="#可串行化-Serializable" class="headerlink" title="可串行化  Serializable"></a>可串行化  Serializable</h4><p>是最严格的隔离级别，他要求所有的事务都被串行执行，既事务只能一个接一个的进行处理，不能并发执行</p>
<p>事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</p>
<p>事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</p>
<h3 id="MVCC-和-间歇锁"><a href="#MVCC-和-间歇锁" class="headerlink" title="MVCC 和 间歇锁"></a>MVCC 和 间歇锁</h3><p>MVCC（在2 3 级运行）的实现是通过保存数据在某一个时间点快照来实现的。也就是说不管实现时间多长，每个事物看到的数据都是一致的。</p>
<p>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>
<ul>
<li>SELECT</li>
</ul>
<p>InnoDB会根据以下条件检查每一行记录：</p>
<ol>
<li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ol>
<p>保存这两个版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且能保证只会读取到复合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<p>可以认为MVCC是行级锁一个变种，但是他很多情况下避免了加锁操作，开销更低。虽然不同数据库的实现机制有所不同，但大都实现了非阻塞的读操作（读不用加锁，且能避免出现不可重复读和幻读），写操作也只锁定必要的行（写必须加锁，否则不同事务并发写会导致数据不一致）。</p>
<p> Repeatable Read隔离级别： 采用Next-key Lock(间隙锁) </p>
<p>间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。</p>
<p> Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。 </p>
<h3 id="默认隔离级别"><a href="#默认隔离级别" class="headerlink" title="默认隔离级别"></a>默认隔离级别</h3><p>MySQL的默认隔离级别是可重复读。</p>
<p>Oracle 是 读已调教 </p>
<p>Sqllite3是 可串行化</p>
<h3 id="什么时候使用乐观锁？"><a href="#什么时候使用乐观锁？" class="headerlink" title="什么时候使用乐观锁？"></a>什么时候使用乐观锁？</h3><p>资源提交冲突，其他使用方需要重新读取资源，会增加读的次数，但是可以面对高并发场景，前提是如果出现提交失败，用户是可以接受的。因此一般乐观锁只用在高并发、多读少写的场景。<br> 其中：GIT,SVN,CVS等代码版本控制管理器，就是一个乐观锁使用很好的场景，例如：A、B程序员，同时从SVN服务器上下载了code.html文件，当A完成提交后，此时B再提交，那么会报版本冲突，此时需要B进行版本处理合并后，再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁，那么意味者所有程序员都必须一个一个等待操作提交完，才能访问文件，这是难以接受的。</p>
<h3 id="什么时候使用悲观锁？"><a href="#什么时候使用悲观锁？" class="headerlink" title="什么时候使用悲观锁？"></a>什么时候使用悲观锁？</h3><p>一旦通过悲观锁锁定一个资源，那么其他需要操作该资源的使用方，只能等待直到锁被释放，好处在于可以减少并发，但是当并发量非常大的时候，由于锁消耗资源，并且可能锁定时间过长，容易导致系统性能下降，资源消耗严重。因此一般我们可以在并发量不是很大，并且出现并发情况导致的异常用户和系统都很难以接受的情况下，会选择悲观锁进行。</p>
<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><ol>
<li><p>唯一索引/非唯一索引</p>
<ol>
<li>唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中不可以重复。</li>
<li>非唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中可以重复，不要求唯一。</li>
</ol>
</li>
<li><p>主键索引（主索引）</p>
<ol>
<li>主键索引（主索引）是唯一索引的特定类型。表中创建主键时自动创建的索引 。一个表只能建立一个主索引。</li>
</ol>
</li>
<li><p>聚集索引/非聚集索引</p>
<ol>
<li><p>聚集索引（聚簇索引），表中记录的物理顺序与键值的索引顺序相同。一个表只能有一个聚集索引。当你在表中创建了一个PRIMARY KEY时，InnoDB就将该索引作为了聚集索引，因此最好为任何一个你创建的表添加PRIMARY KEY。</p>
</li>
<li><p>优点是查询速度快，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理的紧跟其后。</p>
<p>缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，降低了执行速度。在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效。</p>
</li>
<li><p>聚集索引和非聚集索引都采用了 B+树的结构，但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。聚集索引的叶节点就是数据节点，而非聚集索引的叶节点仍然是索引节点。</p>
</li>
<li><p>非聚集索引添加记录时，不会引起数据顺序的重组。</p>
</li>
</ol>
</li>
<li><p>组合索引</p>
<ol>
<li>基于多个字段而创建的索引就称为组合索引。</li>
<li>目的 <ol>
<li><strong>减少开销</strong>，建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引</strong>。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select <em>from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w</em>10%</em> 10% *10%=1w，效率提升可想而知！</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>index(a,b,c)<br>where a=3    只使用了a<br>where a=3 and b=5    使用了a,b<br>where a=3 and b=5 and c=4    使用了a,b,c<br>where b=3 or where c=4    没有使用索引<br>where a=3 and c=4    仅使用了a<br>where a=3 and b&gt;10 and c=7    使用了a,b<br>where a=3 and b like ‘xx%’ and c=7    使用了a,b</p>
<h1 id="MySQL-主从同步"><a href="#MySQL-主从同步" class="headerlink" title="MySQL 主从同步"></a>MySQL 主从同步</h1><p>其中Master负责写操作的负载，也就是说一切写的操作都在Master上进行，而读的操作则分摊到Slave上进行。这样一来的可以大大提高读取的效率。在一般的互联网应用中，经过一些数据调查得出结论，读/写的比例大概在 10：1左右 ，也就是说大量的数据操作是集中在读的操作，这也就是为什么我们会有多个Slave的原因。但是为什么要分离读和写呢？熟悉DB的研发人员都知道，写操作涉及到锁的问题，不管是行锁还是表锁还是块锁，都是比较降低系统执行效率的事情。我们这样的分离是把写操作集中在一个节点上，而读操作其其他的N个节点上进行，从另一个方面有效的提高了读的效率，保证了系统的高可用性。</p>
<p>(2) 基本过程<br>1)、Mysql的主从同步就是当master（主库）发生数据变化的时候，会实时同步到slave（从库）。<br>2)、主从复制可以水平扩展数据库的负载能力，容错，高可用，数据备份。</p>
<p>3)、不管是delete、update、insert，还是创建函数、存储过程，都是在master上，当master有操作的时候，slave会快速的接受到这些操作，从而做同步。</p>
<p>1.业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</p>
<p>2.单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</p>
<p>3.服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</p>
<p>4.不同业务的mysql物理上放在不同机器，分散压力。</p>
<p>5.使用比主库更好的硬件设备作为slave总结，mysql压力小，延迟自然会变小。</p>
<p><strong>binlog是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。</strong></p>
<p>1、Master将数据改变记录到二进制日志(binary log)中，也就是配置文件log-bin指定的文件，这些记录叫做二进制日志事件(binary log events)<br> 2、Slave通过I/O线程读取Master中的binary log events并写入到它的中继日志(relay log)<br> 3、Slave重做中继日志中的事件，把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储，从而实现将改变反映到它自己的数据(数据重放)</p>
<p><strong>异步复制（Asynchronous replication）</strong></p>
<p>MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p>
<p><strong>全同步复制（Fully synchronous replication）</strong></p>
<p>指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p>
<p><strong>半同步复制（Semisynchronous replication）</strong></p>
<p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</p>
<h1 id="数据库分页分表"><a href="#数据库分页分表" class="headerlink" title="数据库分页分表"></a>数据库分页分表</h1><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4><p>假设QQ的用户有100亿，如果只有一张表，每个用户登录的时候数据库都要从这100亿中查找，会很慢很慢。如果将这一张表分成100份，每张表有1亿条，就小了很多，比如qq0,qq1,qq1…qq99表。</p>
<p>用户登录的时候，可以将用户的id%100，那么会得到0-99的数，查询表的时候，将表名qq跟取模的数连接起来，就构建了表名。比如123456789用户，取模的89，那么就到qq89表查询，查询的时间将会大大缩短。</p>
<p>水平拆分的优点：</p>
<p>◆表关联基本能够在数据库端全部完成；</p>
<p>◆不会存在某些超大型数据量和高负载的表遇到瓶颈的问题；</p>
<p>◆应用程序端整体<strong><a href="https://link.zhihu.com/?target=http%3A//lib.csdn.net/base/architecture" target="_blank" rel="noopener">架构</a></strong>改动相对较少；</p>
<p>◆事务处理相对简单；</p>
<p>◆只要切分规则能够定义好，基本上较难遇到扩展性限制；</p>
<p>水平切分的缺点：</p>
<p>◆切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则；</p>
<p>◆后期数据的维护难度有所增加，人为手工定位数据更困难；</p>
<p>◆应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难。</p>
<h4 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h4><p>如果一张表某个字段，信息量大，但是我们很少查询，则可以考虑把这些字段，单独的放入到一张表中，这种方式称为垂直分割.</p>
<p>作文字段的内容较多，可能影响查询的速率，单独抽出来放在一张表中，和主表之间保持关系</p>
<p>垂直切分的优点</p>
<p>◆ 数据库的拆分简单明了，拆分规则明确；</p>
<p>◆ 应用程序模块清晰明确，整合容易；</p>
<p>◆ 数据维护方便易行，容易定位；</p>
<p>垂直切分的缺点</p>
<p>◆ 对于访问极其频繁且数据量超大的表仍然存在性能平静，不一定能满足要求；</p>
<p>◆ 事务处理相对更为复杂；</p>
<p>◆ 切分达到一定程度之后，扩展性会遇到限制；</p>
<p>◆ 过读切分可能会带来系统过渡复杂而难以维护。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h4 id="一般的分页查询"><a href="#一般的分页查询" class="headerlink" title="一般的分页查询"></a>一般的分页查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure>

<p>IMIT 子句可以被用于指定 SELECT 语句返回的记录数。需注意以下几点：</p>
<ul>
<li>第一个参数指定第一个返回记录行的偏移量</li>
<li>第二个参数指定返回记录行的最大数目</li>
<li>如果只给定一个参数：它表示返回最大的记录行数目</li>
<li>第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行</li>
<li>初始记录行的偏移量是 0(而不是 1)</li>
</ul>
<p>下面是一个应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type=8 limit 1000,10;</span><br></pre></td></tr></table></figure>

<p>该条语句将会从表 orders_history 中查询第1000条数据之后的10条数据，也就是第1001条到第1010条数据。</p>
<h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><p>1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num is null</p>
<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<p>select id from t where num=0</p>
<p>4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p>select id from t where num=10 or num=20</p>
<p>可以这样查询：</p>
<p>select id from t where num=10</p>
<p>union all</p>
<p>select id from t where num=20</p>
<p>5、下面的查询也将导致全表扫描：(不能前置百分号)</p>
<p>select id from t where name like ‘%c%’</p>
<p>下面走索引</p>
<p>select id from t where name like ‘c%’</p>
<p>若要提高效率，可以考虑全文检索。</p>
<p>6、in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<p>select id from t where num in(1,2,3)</p>
<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<p>select id from t where num between 1 and 3</p>
<p>7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<p>select id from t where num=@num</p>
<p>可以改为强制查询使用索引：</p>
<p>select id from t with(index(索引名)) where num=@num</p>
<p>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num/2=100</p>
<p>应改为:</p>
<p>select id from t where num=100*2</p>
<p>9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where substring(name,1,3)=’abc’ –name以abc开头的id</p>
<p>select id from t where datediff(day,createdate,’2005-11-30′)=0 –’2005-11-30′生成的id</p>
<p>应改为:</p>
<p>select id from t where name like ‘abc%’</p>
<p>select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</p>
<p>10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>12、不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<p>select col1,col2 into #t from t where 1=0</p>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<p>create table #t(…)</p>
<p>13、很多时候用 exists 代替 in 是一个好的选择：</p>
<p>select num from a where num in(select num from b)</p>
<p>用下面的语句替换：</p>
<p>select num from a where exists(select 1 from b where num=a.num)</p>
<p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
<p>15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数较好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
<p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2020/03/24/network-simple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/24/network-simple/" itemprop="url">【面试准备简明版】- 操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T13:44:35+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="分层要点"><a href="#分层要点" class="headerlink" title="分层要点"></a>分层要点</h1><h2 id="1-OSI七层模型-TCP-IP-四五层"><a href="#1-OSI七层模型-TCP-IP-四五层" class="headerlink" title="1. OSI七层模型 TCP/IP 四五层"></a>1. OSI七层模型 TCP/IP 四五层</h2><ol>
<li>应用层</li>
<li>表示层</li>
<li>会话层<ol>
<li>前三层合并起来为 TCP/IP  的第一层 统称应用层</li>
</ol>
</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层<ol>
<li>后两层合并起来为 四层协议的最底层 称为网络接口层</li>
</ol>
</li>
</ol>
<h2 id="2-各层功能"><a href="#2-各层功能" class="headerlink" title="2. 各层功能"></a>2. 各层功能</h2><h3 id="A-bottom-up-approach"><a href="#A-bottom-up-approach" class="headerlink" title="A bottom up approach"></a><strong>A bottom up approach</strong></h3><h4 id="物理层（比特流-bit）"><a href="#物理层（比特流-bit）" class="headerlink" title="物理层（比特流 bit）"></a>物理层（比特流 bit）</h4><p>物理传输、硬件、物理特性。中间的物理链接可以是<strong>光缆、电缆、双绞线、无线电波</strong>。中间传的是电信号，即010101这样的比特流</p>
<h4 id="数据链路层（帧-frame）"><a href="#数据链路层（帧-frame）" class="headerlink" title="数据链路层（帧 frame）"></a>数据链路层（帧 frame）</h4><p>怎么使一串二进制的比特流有意义呢？我们需要对比特流（电信号）进行分组，</p>
<p>早期的时候，<strong>数据链路层就是来对电信号来做分组的</strong>。以前每个公司都有自己的分组方式，非常的乱，后来形成了统一的标准（标准就是协议），即以太网协议Ethernet。</p>
<p>Ethernet规定</p>
<p>一组电信号称之为一个数据包，或者叫做一个<strong>“帧”</strong>。每一帧分为报头head和数据data两部分。</p>
<p>head（固定18个字节）里包含：</p>
<ul>
<li>发送者（源地址）6个字节</li>
<li>接受者（目标地址）6个字节</li>
<li>数据类型 6个字节</li>
</ul>
<p>data包含：</p>
<ul>
<li>最短46字节，最长1500字节</li>
</ul>
<p>源地址和目标地址指的是<strong>mac地址</strong>。</p>
<p>为什么要mac地址呢，因为Ethernet规定接入Internet的设备都必须具备网卡，发送端的和接收端的地址便是指网卡的地址，即Mac地址。每块网卡出厂时都被烧录上一个实际上唯一的Mac地址，长度为48位2进制，通常由12位16进制数表示，（前六位是厂商编码，后六位是流水线号）。</p>
<p>现在有了发送者和接受者，直接局域网内广播。计算机底层，只要在一个局域网内，都是靠广播通信。互联网就是由一个个局域网组成，局域网内的计算机不管是对内还是对外都是靠吼，这就是数据链路层的工作方式—–广播。</p>
<p>广播出去所有人都能看到，所有人都会拆包，读发送者和接受者是谁，只要接受者不是自己就丢弃掉。</p>
<p>对于局域网内的通信是靠广播，不同局域网内的计算机靠什么呢？这个时候跨网络交流的需求就出现了，也就有了网络层。</p>
<h4 id="网络层（数据包-分组-packet）"><a href="#网络层（数据包-分组-packet）" class="headerlink" title="网络层（数据包/分组 packet）"></a>网络层（数据包/分组 packet）</h4><p>你想，我是这个教室的一个学生，我想找隔壁教室一个叫老王的学生，我也不认识老王，那怎么办，我吼？老王在另外一个教室肯定是听不到的。找教室的负责人，这个教室的负责人就负责和隔壁教室的负责人说话，说我们教室的有个学生要找你们教室的老王。往外传的东西交给负责人就可以了，内部的话上面已经提到，通过广播的方式，对外的东西广播失效。<strong>教室的负责人就是网关，网关即网络关口的意思。</strong></p>
<p><strong>Mac地址</strong>是用来标识你这个教室的某个位置，<strong>IP地址</strong>是用来标识你在哪个教室（哪个局域网）。你要跨网络发包你是不是要知道对方的IP地址，比如你要访问百度，你肯定得知道百度服务器的IP地址。计算机在发包前，会判断你在哪个教室，对方在哪个教室，如果在一个教室，基于mac地址的广播发包就OK了；如果不在一个教室，即跨网络发包，那么就会把你的包交给教室负责人（网关）来转发。Mac地址及IP地址唯一标识了你在互联网中的位置。</p>
<p>数据链路层中会把网络层的数据包封装到数数据链路层的数据位置，然后再添加上自己的包头，再发给物理层，物理层发给网关，网关再发给对方教室的网关，对方教室的网关收到后在那个教室做广播。</p>
<p>IP head一般长20字节，除非有选项字段，包含：</p>
<ul>
<li>版本IPV4 IPV6</li>
<li>head长度，总长度</li>
<li>生存时间TTL</li>
<li>checksum</li>
<li>源地址</li>
<li>目标地址</li>
</ul>
<p>在吼之前怎么知道对方的Mac地址？这就得靠ARP协议。你的机器必须先发一个ARP包出去，ARP也是靠广播的方式发，目标mac写为FF:FF:FF:FF:FF:FF，源ip目标ip均已知。目标ip改为目标的网关地址，网关在目标局域网（子网段）里面广播，所有人解包，只有对应者回应。这样网关就会把它自己的Mac地址返回给你，然后正常发包。</p>
<p>所以在最终发送的数据报里，</p>
<p>目标mac是自己网关的mac，而非目标的mac，但目标ip是目标自己的ip</p>
<p>网关帮你去找飞哥，但对用户来说，我们根本就感觉不到网关的存在。</p>
<p>代理ARP由网络中的网关设备来执行，包括路由器、多层交换机、无线路由器、防火墙等设备。并且，网关即便有代理ARP功能，也未必一定执行，还必须满足两个条件：<strong>①网关已经开启代理ARP功能；②网关有目标的路由信息。</strong></p>
<p><strong>网关（Gateway）、下一跳（Next-hop）、路由器（Router）都指的是离发送方最近的三层（或多层）设备，具备三层和路由转发功能。</strong>举例：我们通过WiFi上网时，网关就是无线路由器，它帮忙将电脑和手机的数据转发到互联网；<strong>所以，我们访问互联网时（无论访问谁），电脑和手机采用的目的MAC，都是无线路由器的MAC</strong></p>
<h4 id="传输层-Segment-Datagram"><a href="#传输层-Segment-Datagram" class="headerlink" title="传输层(Segment / Datagram)"></a>传输层(Segment / Datagram)</h4><p>输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，</p>
<p>那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。</p>
<p>传输层功能：建立端口到端口的通信，端口范围0-65535，0-1023为系统占用端口。（因为TCP UDP head有16位用来标记源端口号和目标端口号，所以端口个数是2^16-1=65535个。</p>
<p>TCP对应 Segment 叫数据段:</p>
<p>TCP首部长20字节 + 4N 字节作为选项</p>
<p>包含source port, dest port, SeqNum, AckNum, 报头长度, 保留用以后开发，编码位(六种bit)，窗口（自己一方的接受窗口，即明确指明对方允许发送的数据量），checksum，紧急指针（本报文段的紧急数据字节数） 选项（最长40字节）</p>
<p>可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<p>UDP对应 datagram 叫数据报：</p>
<p>UDP首部8个字节，source port，dest port，长度，checksum</p>
<p>不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
<h4 id="应用层-message-消息"><a href="#应用层-message-消息" class="headerlink" title="应用层(message 消息)"></a>应用层(message 消息)</h4><p>户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 。</p>
<p>应用层功能：规定应用程序的数据格式。比如HTTP FTP etc</p>
<p>TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>总的来说网络传输信息都是在传输信息的时候每一层提供自己的封装，在解读信息的时候层层解封。</p>
<p>以HTTP为例的信息的传输为例</p>
<p>HTTP在应用层为数据包装上了HTTP head，目的是目标服务器能解读这个HTTP Request。在传输层TCP为数据又加包了TCP头，形成了segment，目的是信息能传往正确的端口，被正确的应用程序接收。这个时候时候为了在子网段间通信，在网络层加上了ip head，数据被封装成packet。packet再次通过被加上以太网头，在数据链路层，被封装成帧。最后帧被转化成比特流在物理层传输。</p>
<h1 id="TCP要点"><a href="#TCP要点" class="headerlink" title="TCP要点"></a>TCP要点</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ol>
<li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li>
<li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
<li>TCP包最大1500-20（IP head）-20（TCP head） = 1460 bytes</li>
</ol>
<p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p>
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>
<ul>
<li><p>第一次握手(SYNbit=1, seq=x)</p>
<ul>
<li>客户端执行<code>connect()</code>发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</li>
<li>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li>
</ul>
</li>
<li><p>第二次握手(SYNbit=1, ACKbit=1, seq=y, ACKNum=x+1):</p>
<ul>
<li>服务器执行<code>listen()</code>发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
</ul>
</li>
<li><p>第三次握手(SYNbit = 0, ACKbit=1，ACKnum=y+1)</p>
<ul>
<li>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</li>
<li>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>
</ul>
</li>
</ul>
<p>三次握手的过程的示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png" alt="three-way-handshake"></p>
<h3 id="为什么一定要是三次"><a href="#为什么一定要是三次" class="headerlink" title="为什么一定要是三次"></a>为什么一定要是三次</h3><h4 id="为什么不是两次：B不知道A是否收到同步信号"><a href="#为什么不是两次：B不知道A是否收到同步信号" class="headerlink" title="为什么不是两次：B不知道A是否收到同步信号"></a>为什么不是两次：B不知道A是否收到同步信号</h4><ol>
<li>A 发送同步信号<strong>SYN</strong> + Seq Number</li>
<li>B 发送同步信号SYN + Seq Number + ACK + ACKnum</li>
</ol>
<p>这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。<strong>但是</strong>B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，<strong>A和B就B的初始序列号将无法达成一致。</strong></p>
<p>有童鞋会说，如果A发给B的确认丢了，该如何？A会超时重传这个ACK吗？不会！<strong>TCP不会为没有数据的ACK超时重传</strong>。</p>
<p>那该如何是好？<strong>B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</strong></p>
<h4 id="为什么不是四次：记录A的ISN达成一致和发送B的ISN可以合并"><a href="#为什么不是四次：记录A的ISN达成一致和发送B的ISN可以合并" class="headerlink" title="为什么不是四次：记录A的ISN达成一致和发送B的ISN可以合并"></a>为什么不是四次：记录A的ISN达成一致和发送B的ISN可以合并</h4><ol>
<li>A 发送同步信号<strong>SYN</strong> + <strong>A’sInitial sequence number</strong></li>
<li>B 确认收到A的同步信号，并记录A’s ISN 到本地，命名 B’s ACK sequence number</li>
<li>B发送同步信号<strong>SYN</strong> + <strong>B’s Initial sequence number</strong> </li>
<li>A确认收到B的同步信号，并记录B’s ISN 到本地，命名 <strong>A’s ACK sequence number</strong></li>
</ol>
<p>很显然1.2和1.3 这两个步骤可以合并，<strong>只需要三次握手，</strong>可以提高连接的速度与效率。</p>
<h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><ul>
<li><strong>A发给B的SYN 中途被丢，没有到达B</strong><ul>
<li>A会周期性超时重传，直到收到B的确认</li>
</ul>
</li>
<li><strong>即B发给A的SYN +ACK 中途被丢，没有到达A</strong><ul>
<li>B会周期性超时重传，直到收到A的确认</li>
</ul>
</li>
<li><strong>即A发给B的ACK 中途被丢，没有到达B</strong><ul>
<li>A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态。A不会超时重传，因为ATCP不会为没有数据的ACK超时重传。</li>
<li>假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包</li>
<li>假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data</li>
<li>假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</li>
</ul>
</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>第一次挥手(FIN=1，seq=x)</p>
<ul>
<li><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>
<p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p>
</li>
</ul>
</li>
<li><p>第二次挥手(ACK=1，ACKnum=x+1)</p>
<ul>
<li><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>
<p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p>
<p>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
</li>
</ul>
</li>
<li><p>第三次挥手(FIN=1，seq=y)</p>
<ul>
<li>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</li>
<li>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</li>
</ul>
</li>
<li><p>第四次挥手(ACK=1，ACKnum=y+1)</p>
<ul>
<li><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p>
<p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png" alt="four-way-handshake"></p>
<h3 id="为什么一定要四次"><a href="#为什么一定要四次" class="headerlink" title="为什么一定要四次"></a>为什么一定要四次</h3><p>确保数据能够完成传输。</p>
<p>但关闭连接时，当收到对方的<em>FIN</em>报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭<em>SOCKET,</em>也即你可能还需要发送一些数据给对方之后，再发送<em>FIN</em>报文给对方来表示你同意现在可以关闭连接了，所以它这里的<em>ACK</em>报文和<em>FIN</em>报文多数情况下都是分开发送的。</p>
<p>因为TCP是全双工通信的，即两向均可发送 接受数据</p>
<p>   （1）第一次挥手</p>
<pre><code> 因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。

（2）第二次挥手

 被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。</code></pre><p>   （3）第三次挥手</p>
<pre><code>被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。</code></pre><p>   （4）第四挥手</p>
<pre><code>如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</code></pre><p>如果双方都没有数据要发送 那三次挥手也是可以的。</p>
<h3 id="为什么建立是三次断开就是四次"><a href="#为什么建立是三次断开就是四次" class="headerlink" title="为什么建立是三次断开就是四次"></a>为什么建立是三次断开就是四次</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h3 id="为什么要等2MSL"><a href="#为什么要等2MSL" class="headerlink" title="为什么要等2MSL"></a>为什么要等2MSL</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h3 id="故障处理-1"><a href="#故障处理-1" class="headerlink" title="故障处理"></a>故障处理</h3><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="TCP重发"><a href="#TCP重发" class="headerlink" title="TCP重发"></a>TCP重发</h2><h4 id="Acknowledgement-of-delay"><a href="#Acknowledgement-of-delay" class="headerlink" title="Acknowledgement of delay"></a>Acknowledgement of delay</h4><p>通常TCP在收到数据的时候不会立刻发送一个ACK确认，它会延迟发送，可以和对方需要的数据一起发送（数据捎带ACK）或者是等待第二个数据来了直接回复第二个ACK，通常的实现采用的延迟是200ms(就是说它会等待200ms有没有数据一起发送)</p>
<h4 id="Nagle"><a href="#Nagle" class="headerlink" title="Nagle"></a>Nagle</h4><p>在数据传输过程中，通常会遇到一些小分组的传输（比如 41 bit的数据分组，除去TCP首部和IP首部真正传输的数据只有1 bit），这里的小分组指的是报文长度小于MSS(Max Segment Size)长度的分组，像这种小分组多的话，在网络上传输就加大了造成网络拥塞的可能。为了提传输效率，所以提出了Nagle算法。<br> 这个算法要求一个TCP连接最多只能有一个未被确认的未完成的小分组，在该分组到达之前不能发送其他的小分组。然后，TCP会收集这些小分组，并在确认到来时以一个分组的方式发送出去，这样就可以有效的减少了小分组。 在一些实时性要求比较高的场景下，采用了Nagle算法会让用户感觉到时延，所以我们可以选择关闭Nagle算法，Socket API 可以用 TCP_NODELAY 选项来关闭，nginx上的 tcp_nodely也是采用的这个系统调用。</p>
<h4 id="Retransmission"><a href="#Retransmission" class="headerlink" title="Retransmission"></a>Retransmission</h4><p>TCP为了保证数据不丢失所采用的重传策略。 TCP超时重传比较严重，它表示已经超时了还没有收到数据确认的回复，所以他会进入到慢启动，而快速重传则不用。<br> TCP超时重传：TCP发送方首先会维护一个TCP的重传定时器(有的也叫超时时间RTO)，这个定时器是根据往返时间（RTT）进行计算，具体算法的实现可以参考 <a href="https://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC 6298</a>，当RTO到了还没有收到数据的确认，那么TCP就认为数据已经丢失了。TCP会重传数据，接着进入到拥塞控制里的慢启动（关于拥塞控制会在后面讲）。<br> TCP快速重传：<strong>它主要是收到了三个重复的ACK后</strong>（接受方如果收到的数据是乱序的。它会重发自己最近接收到的正确顺序的ACK）进行重传，因为收到重复的ACK代表数据已经发送过去了，其中的一个数据可能因为其他原因（如数据传输中换了比较远的路由，或者是数据干脆直接丢了）造成数据没有收到。所以这个情况不算太严重，它不会进入到慢启动，它会进入到快速恢复。<br> TCP 在收到连续重复ACK后会重传最后顺序确认包的下一个，这样原先已经正确传输的包可能会重复发送，降低了TCP性能。为改善这种情况，发展出SACK（Selective Acknowledgement）技术，使用SACK选项可以告知发包方收到了哪些数据，发包方收到这些信息后就会知道哪些数据丢失，然后立即重传丢失的部分。</p>
<h2 id="拥堵控制"><a href="#拥堵控制" class="headerlink" title="拥堵控制"></a>拥堵控制</h2><h3 id="滑窗"><a href="#滑窗" class="headerlink" title="滑窗"></a>滑窗</h3><p>我们能不能把第一个和第二个包发过去后，收到第一个确认包就把第三个包发过去呢？而不是去等到第二个包的确认包才去发第三个包。这样就很自然的产生了我们”滑动窗口”的实现。</p>
<h4 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h4><p><img src="https://user-gold-cdn.xitu.io/2019/3/30/169cd8c84c05c552?imageslim" alt="img"></p>
<p>可以看到4号包对方已经被接收到，所以被涂成了灰色。“窗口”就往右移一格，这里只要保证“窗口”是7格的。 我们就把11号包读进了我们的缓存。进入了“待发送”的状态。8、9号包已经变成了黄色，表示已经发送出去了。接下来的操作就是一样的了，确认包后，窗口往后移继续将未发送的包读进缓存，把“待发送“状态的包变为”已发送“。</p>
<h4 id="丢包情况"><a href="#丢包情况" class="headerlink" title="丢包情况"></a>丢包情况</h4><p>有可能我们包发过去，对方的Ack丢了。也有可能我们的包并没有发送过去。从发送方角度看就是我们没有收到Ack。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/30/169cd8c84c92d41b?imageslim" alt="img"></p>
<p>发生的情况：一直在等Ack。如果一直等不到的话，我们也会把读进缓存的待发送的包也一起发过去。但是，这个时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的Ack。</p>
<h5 id="超时重发"><a href="#超时重发" class="headerlink" title="超时重发"></a>超时重发</h5><p>这时候我们有个解决方法：<code>超时重传</code> 这里有一点要说明：这个Ack是要按顺序的。必须要等到5的Ack收到，才会把6-11的Ack发送过去。这样就保证了滑动窗口的一个顺序。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/30/169cd8c84caf97fd?imageslim" alt="img"></p>
<h3 id="慢启动和拥塞避免"><a href="#慢启动和拥塞避免" class="headerlink" title="慢启动和拥塞避免"></a>慢启动和拥塞避免</h3><p><strong>慢启动算法的思路</strong>：主机开发发送数据报时，如果立即将大量的数据注入到网络中，可能会出现网络的拥塞。慢启动算法就是在主机刚开始发送数据报的时候先探测一下网络的状况，如果网络状况良好，发送方每发送一次文段都能正确的接受确认报文段。那么就从小到大的增加拥塞窗口的大小，即增加发送窗口的大小。</p>
<p>timeout + delay of ack 在慢启动第一个包体现得很明显。</p>
<p>ssthresh最初等于8 MSS 。 拥塞窗口在慢启动期间以指数方式快速上升并在第三次传输时达到ssthresh。 然后，拥塞窗口线性地爬升，直到发生丢失（超时），就在发送7之后。当发生丢失时，拥塞窗口是12 MSS 。 然后将ssthresh设置为6 MSS并且将cwnd设置为1，并且该过程继续。</p>
<p><img src="https://img-blog.csdn.net/20160909153411895?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="快速重传和快速恢复-Fast-Re-transmit-Fast-Restore"><a href="#快速重传和快速恢复-Fast-Re-transmit-Fast-Restore" class="headerlink" title="快速重传和快速恢复 Fast Re-transmit / Fast Restore"></a>快速重传和快速恢复 <strong>Fast Re-transmit / Fast Restore</strong></h3><p>快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。接收方成功的接受了发送方发送来的M1、M2并且分别给发送了ACK，现在接收方没有收到M3，而接收到了M4，显然接收方不能确认M4，因为M4是失序的报文段。如果根据可靠性传输原理接收方什么都不做，但是按照快速重传算法，在收到M4、M5等报文段的时候，不断重复的向发送方发送M2的ACK,如果接收方一连收到三个重复的ACK,那么发送方不必等待重传计时器到期，由于发送方尽早重传未被确认的报文段。</p>
<p>即受到多个duplicate，立即重传M2</p>
<p>当发送发连续接收到三个确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）减半，但是接下来并不执行慢开始算法。</p>
<p><img src="https://img-blog.csdn.net/20160909153222894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h2 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h2><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作</p>
<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p>
<p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</p>
<p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>
<ol>
<li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li>
<li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>
<li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li>
</ol>
<p>从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。</p>
<h1 id="TCP-C-S-模型"><a href="#TCP-C-S-模型" class="headerlink" title="TCP C/S 模型"></a>TCP C/S 模型</h1><h4 id="5-5-1-服务器端"><a href="#5-5-1-服务器端" class="headerlink" title="5.5.1 服务器端"></a>5.5.1 服务器端</h4><h5 id="创建套接字socket"><a href="#创建套接字socket" class="headerlink" title="创建套接字socket()"></a>创建套接字socket()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>; 　　　</span><br><span class="line"> 　　 　返回：非负描述字－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

<p>第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF_INET(IPv4协议)和AF_INET6(IPv6协议)；第二个参数指明套接口类型，有三种类型可选：SOCK_STREAM(字节流套接口)、SOCK_DGRAM(数据报套接口)和SOCK_RAW(原始套接口)；如果套接口类型不是原始套接口，那么第三个参数就为0。</p>
<h5 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * server, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"> 返回：<span class="number">0</span>－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

<p>把一个套接字地址（本机IP和端口号）绑定到创建的套接字上。绑定套接字时可以选择指定IP地址和端口，也可以不指定。通配的IP地址用INADDR_ANY表示，通配的端口用0表示，通配的情况下由内核为其指定相应的IP地址和端口号。<br>对于客户端可以绑定套接字，但是一般不需要，因为客户端的端口号只是临时的，由内核来分配更合理。但是对服务器而言，一般要使用知名端口号，如果不进行绑定，客户端不知道目的端口号，连接不能完成。</p>
<h5 id="监听listen"><a href="#监听listen" class="headerlink" title="监听listen()"></a>监听listen()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>

<h5 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h5><p>accept函数从已完成连接的队列中取走一个套接字，如果该队列为空，则accept函数阻塞。accept函数的返回值称为已连接套接字，已连接的套接字就建立一个完整的TCP连接，源IP地址，源端口号，目的IP地址，目的端口号都是唯一确定了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; 　　 　 　 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *client, <span class="keyword">socklen_t</span> * addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="read-函数用于数据的接收"><a href="#read-函数用于数据的接收" class="headerlink" title="read() 函数用于数据的接收"></a>read() <strong>函数用于数据的接收</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; 　　 　 　 　</span><br><span class="line"> int read(int sockfd, char *buf, intlen); 　</span><br><span class="line">  回：非负－－－成功　　　-1－－－失败</span><br></pre></td></tr></table></figure>

<h5 id="write-函数用于数据的发送"><a href="#write-函数用于数据的发送" class="headerlink" title="write() 函数用于数据的发送"></a>write() <strong>函数用于数据的发送</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; 　　 　 　 　</span><br><span class="line"> int write(int sockfd, char *buf, int len);　</span><br><span class="line">  回：非负－－－成功　　　-1－－－失败</span><br></pre></td></tr></table></figure>

<p>send和recv函数：TCP套接字提供了send()和recv()函数，用来发送和接收操作。这两个函数与write()和read()函数很相似，只是多了一个附加的参数。</p>
<h5 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt; sys/socket.h &gt; 　　 　 　 　</span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>

<h5 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt; sys/socket.h &gt; 　　 　 　 　</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>

<h5 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h5><p>close函数关闭套接字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int sockfd);</span><br></pre></td></tr></table></figure>

<h4 id="5-5-2-TCP-客户端"><a href="#5-5-2-TCP-客户端" class="headerlink" title="5.5.2 TCP 客户端"></a>5.5.2 TCP 客户端</h4><h5 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h5><p>创建套接字</p>
<h5 id="connect-创建连接"><a href="#connect-创建连接" class="headerlink" title="connect() 创建连接"></a>connect() 创建连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;　　 　 　</span><br><span class="line">int connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<h5 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h5><h5 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h5><h1 id="UDP-要点"><a href="#UDP-要点" class="headerlink" title="UDP 要点"></a>UDP 要点</h1><p>UDP只在IP的数据报服务之上增加了一点的功能，这就是复用和分用的功能以及差错检测的功能，UDP的主要特点是：</p>
<ul>
<li>UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表</li>
<li>UDP是面向报文（message）的。发送方的UDP对应程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界。</li>
<li>UDP没有拥塞控制</li>
<li>UDP支持一对一，一对多，多对一和多对多交换通信。</li>
<li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短</li>
<li>UDP包最大1500-20-8= 1472 bytes</li>
</ul>
<p>即通过UDP实现类似TCP的可靠性</p>
<p>KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。本文传输协议之考虑UDP的情况。</p>
<p>比较两者的区别主要应该是说TCP比UDP多了什么？</p>
<p><strong>面向连接</strong>：TCP接收方与发送方维持了一个状态（建立连接，断开连接），双方知道对方还在。<br><strong>可靠的</strong>：发送出去的数据对方一定能够接收到，而且是按照发送的顺序收到的。<br><strong>流量控制与拥塞控制</strong>：TCP靠谱通过滑动窗口确保，发送的数据接收方来得及收。<strong>TCP无私</strong>，发生数据包丢失的时候认为整个网络比较堵，自己放慢数据发送速度。</p>
<ul>
<li>1、添加seq/ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
<p>UDP本身是不可靠的，所以需要额外信息来保证传输数据的可靠性。因此，我们需要在传输的数据上增加一个包头。用于确保数据的可靠、有序。</p>
<p>再加上TCP式的超时重传、流量控制和拥堵控制。</p>
<p>conv:连接号。UDP是无连接的，conv用于表示来自于哪个客户端。对连接的一种替代<br>cmd:命令字。如，IKCP_CMD_ACK确认命令，IKCP_CMD_WASK接收窗口大小询问命令，IKCP_CMD_WINS接收窗口大小告知命令，<br>frg:分片，用户数据可能会被分成多个KCP包，发送出去<br>wnd:接收窗口大小，发送方的发送窗口不能超过接收方给出的数值<br>ts:时间序列<br>sn:序列号<br>una:下一个可接收的序列号。其实就是确认号，收到sn=10的包，una为11<br>len：数据长度<br>data:用户数据</p>
<h1 id="UDP-C-S-模型"><a href="#UDP-C-S-模型" class="headerlink" title="UDP C/S 模型"></a>UDP C/S 模型</h1><p><img src="https://img-blog.csdn.net/20160213204452771" alt="这里写图片描述"></p>
<h1 id="HTTP-要点"><a href="#HTTP-要点" class="headerlink" title="HTTP 要点"></a>HTTP 要点</h1><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p>200：请求被正常处理<br>204：请求被受理但没有资源可以返回<br>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。<br>301：永久性重定向<br>302：临时重定向<br>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上<br>304：发送附带条件的请求时，条件不满足时返回，与重定向无关<br>307：临时重定向，与302类似，只是强制要求使用POST方法<br>400：请求报文语法有误，服务器无法识别<br>401：请求需要认证<br>403：请求的对应资源禁止被访问<br>404：服务器无法找到对应资源<br>500：服务器内部错误<br>503：服务器正忙</p>
<h3 id="GET-POST-区别"><a href="#GET-POST-区别" class="headerlink" title="GET/POST 区别"></a>GET/POST 区别</h3><p>区别一：<br>get重点在从服务器上获取资源，post重点在向服务器发送数据；<br>区别二：<br>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；" target="_blank" rel="noopener">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；</a><br>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；<br>区别三：<br>Get传输的数据量小，因为受URL长度限制，但效率较高；<br>Post可以传输大量数据，所以上传文件时只能用Post方式；<br>区别四：<br>GET请求返回的内容可以被浏览器缓存起来。而每次提交的<strong>POST</strong>，浏览器在你按下<strong>F5</strong>的时候会跳出确认框，浏览器不会缓存<strong>POST</strong>请求返回的内容。</p>
<p>GET 有个安全隐患在于 url 可能被服务器的 access log 记录并保存。在浏览器也能查到历史记录，但是post请求的参数都在body里面，服务器日志记录不到，浏览器历史也记录不到。前端安全上POST可能确实更好。</p>
<p>但根据RFC官方的定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。但这里的意思是GET不会改变服务端的数据，不会有副作用。关键还是在正确的地方使用GET/POST</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS</p>
<p>HTTPS相比HTTP，在请求前多了一个「握手」的环节。在握手时，你和你想访问的网站会交换一个密钥；握手完成后，你的请求先用密钥加密才会发出去，网站服务器的响应会先用密钥加密再传给你。由于整条链路上的节点拿到的数据都是加密过的，所以他们即无法分析出源数据的内容，也无法篡改这个加密过的数据（如果一个节点篡改了加密后的数据，你和服务器都没办法用密钥解密出来，会认为数据是无效的）。</p>
<p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL/TLS层（在传输层），HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><ol>
<li>Client发起一个HTTPS的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。</li>
<li>Server把事先配置好的公钥证书（public key certificate）返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li>
<li>Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li>
<li>Server使用对称密钥加密“明文内容A”，发送给Client。</li>
<li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li>
<li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</li>
</ol>
<h5 id="为什么HTTPS-可以防御住中间人攻击"><a href="#为什么HTTPS-可以防御住中间人攻击" class="headerlink" title="为什么HTTPS 可以防御住中间人攻击"></a>为什么HTTPS 可以防御住中间人攻击</h5><p>因为中间人没有私钥，没有办法解密公钥加密的对称密码。</p>
<h5 id="和HTTP的区别"><a href="#和HTTP的区别" class="headerlink" title="和HTTP的区别"></a>和HTTP的区别</h5><ol>
<li><p>https协议需要到CA申请证书（包含公钥和私钥，因此是非对称加密），用户证书的发放是基于相关机构的。</p>
<ol>
<li><p>公钥加密，私钥解密。</p>
<p>私钥数字签名，公钥验证。</p>
</li>
</ol>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p>
</li>
<li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议</p>
</li>
<li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议</p>
</li>
</ol>
<h5 id="客户端解析证书"><a href="#客户端解析证书" class="headerlink" title="客户端解析证书"></a>客户端解析证书</h5><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>
<p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h3 id="SQL-注入怎么防御"><a href="#SQL-注入怎么防御" class="headerlink" title="SQL 注入怎么防御"></a>SQL 注入怎么防御</h3><p>不要直接执行plain sql</p>
<p>加字符串过滤</p>
<p>使用安全的函数</p>
<h3 id="DDOS-怎么防御"><a href="#DDOS-怎么防御" class="headerlink" title="DDOS 怎么防御"></a>DDOS 怎么防御</h3><p>按照发起的方式，DDoS可以简单分为三类。</p>
<ul>
<li>第一类以力取胜，海量数据包从互联网的各个角落蜂拥而来，堵塞IDC入口，让各种强大的硬件防御系统、快速高效的应急流程无用武之地。这种类型的攻击典型代表是ICMP Flood和UDP Flood，现在已不常见。</li>
<li>第二类以巧取胜，灵动而难以察觉，每隔几分钟发一个包甚至只需要一个包，就可以让豪华配置的服务器不再响应。这类攻击主要是利用协议或者软件的漏洞发起，例如Slowloris攻击、Hash冲突攻击等，需要特定环境机缘巧合下才能出现。</li>
<li>第三类是上述两种的混合，轻灵浑厚兼而有之，既利用了协议、系统的缺陷，又具备了海量的流量，例如SYN Flood攻击、DNS Query Flood攻击，是当前的主流攻击方式。</li>
</ul>
<ol>
<li>HTTP拦截 防火墙拦截固定的ip</li>
<li>用CDN</li>
<li>SYN cookie</li>
</ol>
<h3 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h3><p>XSS原称为CSS(Cross-Site Scripting)，因为和层叠样式表(Cascading Style Sheets)重名，所以改称为XSS(X一般有未知的含义，还有扩展的含义)。XSS攻击涉及到三方：攻击者，用户，web server。用户是通过浏览器来访问web server上的网页，XSS攻击就是攻击者通过各种办法，在用户访问的网页中插入自己的脚本，让其在用户访问网页时在其浏览器中进行执行。攻击者通过插入的脚本的执行，来获得用户的信息，比如cookie，发送到攻击者自己的网站(跨站了)。所以称为<strong>跨站脚本攻击</strong>。XSS可以分为反射型XSS和持久性XSS，还有DOM Based XSS。(一句话，XSS就是在用户的浏览器中执行攻击者自己定制的脚本。)</p>
<ol>
<li><strong>对输入(和URL参数)进行过滤，对输出进行编码</strong></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2020/03/24/os-simple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/24/os-simple/" itemprop="url">【面试准备简明版】- 操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T13:41:36+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="内存-寻址要点"><a href="#内存-寻址要点" class="headerlink" title="内存/寻址要点"></a>内存/寻址要点</h1><h3 id="1-物理地址-逻辑地址-和-虚拟地址"><a href="#1-物理地址-逻辑地址-和-虚拟地址" class="headerlink" title="1. 物理地址 逻辑地址 和 虚拟地址"></a>1. 物理地址 逻辑地址 和 虚拟地址</h3><p>物理地址</p>
<p>指CPU外部地址总线上寻址物理内存的地址信号，是地址变换的最终结果。</p>
<p>逻辑地址</p>
<p>指由程序产生的段内偏移。有时候直接把逻辑地址当做虚拟地址。</p>
<p>虚拟地址</p>
<p>指由程序产生的由段选择符和段内偏移地址组成的地址。linux实现的是“虚拟内存系统”，对用户而言，所有内存都是虚拟的，也就是说程序并不是直接运行在物理内存上，而是运行在虚拟内存上，然后由虚拟内存转换到物理内存。linux将所有的内存都以页为单位进行划分，通常每一页是4KB</p>
<p>线性地址</p>
<p>指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间中的地址。程序代码会产生逻辑地址，也就是段中的偏移地址，加上相应的段基址就成了线性地址。如果开启了分页机制，那么线性地址需要再经过变换，转为为物理地址。如果无分页机制，那么线性地址就是物理地址。</p>
<p>MMU通过查询段表，可以将逻辑地址转化为线性地址。无分页机制时，线性地址就是物理地址，有分页时，MMU还需要查询页表来将线性地址转化为物理地址：逻辑地址（段表）-&gt;线性地址（页表）-&gt;物理地址。</p>
<h4 id="为什么需要虚拟内存"><a href="#为什么需要虚拟内存" class="headerlink" title="为什么需要虚拟内存"></a>为什么需要虚拟内存</h4><p> 之前的计算机系统，是使用物理地址来使用内存的，这样，CPU就根据某个寄存器中相应的值，直接到物理内存去取值了。</p>
<p>   这样的好处就是非常直接，非常容易理解。</p>
<p>  而缺点是，我们需要知道物理地址的值，每次程序开始执行，也就是执行程序从磁盘被load到物理内存中之后，我们必须告诉CPU，程序是从哪一个地址开始执行的(即PC寄存器的值)；还有一个致命的缺点是：程序使用的内存会被物理内存所限制，比如我们的机器上只有512M内存，那我们的程序就不能使用需占1G内存的程序了。这点或许是催生虚拟内存产生的最主要原因。</p>
<h3 id="2-内存管理（分页与分段）"><a href="#2-内存管理（分页与分段）" class="headerlink" title="2. 内存管理（分页与分段）"></a>2. 内存管理（分页与分段）</h3><ol>
<li>固定分区<ol>
<li>主存被分为很多大小固定的分区，进程可以装载到大于等于自身大小的分区。</li>
<li>1.有内部碎片，活动进程的数目是固定的</li>
</ol>
</li>
<li>动态分区<ol>
<li>分区是被动态创建的，进程可以装载到正好等于自身大小的分区</li>
<li>没有内部碎片，内存使用更完全；有外部碎片，需要压缩外部碎片</li>
<li>为了实现分区分配，系统中必须配置相应的数据结构，用来描述空闲分区和已分配分区的情况，为分配提供依据。常用的数据结构有以下两种形式：<ol>
<li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。</li>
<li>空闲分区链：为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。</li>
<li>First Fit / 循环首次适应算法 / 最佳适应算法 / 最坏适应算法 / 快速适应算法(对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。<br>  空闲分区的分类是根据进程常用的空间大小进行划分，如2 KB、4 KB、8 KB等，对于其它大小的分区，如7 KB这样的空闲区，既可以放在8 KB的链表中，也可以放在一个特殊的空闲区链表中。<br>  该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。<br>  该算法的缺点是在分区归还主存时算法复杂，系统开销较大。)</li>
</ol>
</li>
</ol>
</li>
<li>简单分页<ol>
<li>主存被分为很多大小相同的帧，进程被分为很多与帧大小相同的页。要装入一个进程，需要将进程所有的页装入主存，可以是不连续的帧中。</li>
<li>没有外部碎片， 有很少的内部碎片（仅出现在进程的最后一页）</li>
</ol>
</li>
<li>简单分段<ol>
<li>进程被分为很多的段，要装入一个进程，需要将进程所有的段装入主存中不一定连续的动态分区。</li>
<li>没有内部碎片，比较与动态分区，内存利用率更高，开销小， 有外部碎片，需要压缩外部碎片</li>
</ol>
</li>
<li>虚拟内存分页<ol>
<li>与简单分页相比，不需要将进程的所有页装入主存</li>
<li>没有外部碎片</li>
<li>巨大的虚拟内存空间</li>
<li>更高程度的多到程序设计</li>
</ol>
</li>
<li>虚拟内存分段<ol>
<li>与简单分段相比，不需要将进程所有的段都装入主存</li>
<li>具有虚拟内存分页的三个优点，并且支持保护和共享</li>
</ol>
</li>
</ol>
<h3 id="3-Slab和伙伴算法"><a href="#3-Slab和伙伴算法" class="headerlink" title="3. Slab和伙伴算法"></a>3. Slab和伙伴算法</h3><h4 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h4><p>一种物理内存分配和回收的方法，物理内存所有空闲页都记录在BUDDY链表中。首选，系统建立一个链表，链表中的每个元素代表一类大小的物理内存，分别为2的0次方、1次方、2次方，个页大小，对应4K、8K、16K的内存，没一类大小的内存又有一个链表，表示目前可以分配的物理内存。例如现在仅存需要分配8K的物理内存，系统首先从8K那个链表中查询有无可分配的内存，若有直接分配；否则查找16K大小的链表，若有，首先将16K一分为二，将其中一个分配给进程，另一个插入8K的链表中，若无，继续查找32K，若有，首先把32K一分为二，其中一个16K大小的内存插入16K链表中，然后另一个16K继续一分为二，将其中一个插入8K的链表中，另一个分配给进程……..以此类推。当内存释放时，查看相邻内存有无空闲，若存在两个联系的8K的空闲内存，直接合并成一个16K的内存，插入16K链表中。（伙伴算法用于物理内存分配方案）</p>
<h4 id="Linux的slab层-amp-VAM"><a href="#Linux的slab层-amp-VAM" class="headerlink" title="Linux的slab层 &amp; VAM"></a>Linux的slab层 &amp; VAM</h4><p>SLAB 算法是一种对伙伴算的一种补充，对于用户进程的内存分配，伙伴算法已经够好了，但对于内核进程，还需要存在一类很小的数据（字节大小，比如进程描述符、虚拟内存描述符等），若每次给几个字节的数据分配一个4KB的页，实在太浪费，于是就有了SLBA算法，SLAB算法其实就是把一个页用力劈成一小块一小块，然后再分配。</p>
<h3 id="4-高端内存"><a href="#4-高端内存" class="headerlink" title="4. 高端内存"></a>4. 高端内存</h3><p> 高端内存HIGH_MEM对应的虚拟地址空间范围为0xF8000000 ~ 0xFFFFFFFF，那么内核是如何借助128MB的空间范围实现访问到所有物理内存呢？</p>
<p> 当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑（虚拟）地址空间，借用这段逻辑地址空间，建立到想访问的那段物理内存（即填充内核PTE页面表）的映射，临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，这就实现了使用有限的地址空间，访问所有所有物理内存。</p>
<h1 id="进程-线程-协程要点"><a href="#进程-线程-协程要点" class="headerlink" title="进程/线程/协程要点"></a>进程/线程/协程要点</h1><h3 id="1-进程和线程的区别"><a href="#1-进程和线程的区别" class="headerlink" title="1. 进程和线程的区别"></a>1. 进程和线程的区别</h3><ol>
<li>进程的划分尺度大于线程的划分尺度，<strong>一个程序至少有一个进程,一个进程至少有一个线程.</strong></li>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</li>
<li>进程有自己独立的地址空间（如c++的内存分布，分为栈，堆，BSS（未初始化的全局和静态变量，程序执行前自动清零），DATA（初始化的全局和静态变量），文字），线程只有自己的独立栈，没有自己的地址空间；线程不拥有系统资源，但可以访问隶属于进程的资源。</li>
<li>不同进程间数据很难共享，同一进程下不同线程间数据很容易共享</li>
</ol>
<h3 id="2-进程切换的开销和线程切换的开销"><a href="#2-进程切换的开销和线程切换的开销" class="headerlink" title="2. 进程切换的开销和线程切换的开销"></a>2. 进程切换的开销和线程切换的开销</h3><p>进程切换：</p>
<ol>
<li><strong>切换页目录以使用新的地址空间</strong></li>
<li><strong>切换内核栈和硬件上下文</strong></li>
<li>刷新TLB（页表缓存）</li>
<li>系统调度器的代码执行</li>
</ol>
<p>线程切换：</p>
<ol>
<li>上下文切换</li>
<li>页表和TLB该换的也要换</li>
<li>对于linux 的 CPU来讲多线程与多进程一样，都有不同的标识（一样的pid不一样的tpid）和不同的上下文，为了保证一致性，TLB刷新就省不了。</li>
</ol>
<h3 id="3-协程切换的开销为什么小"><a href="#3-协程切换的开销为什么小" class="headerlink" title="3. 协程切换的开销为什么小"></a>3. 协程切换的开销为什么小</h3><ol>
<li>协程切换<strong>完全在用户空间进行</strong>，线程切换涉及<strong>特权模式切换，需要在内核空间完成</strong>；</li>
<li>协程切换相比线程切换<strong>做的事情更少</strong>。</li>
</ol>
<p>协程切换只涉及基本的<strong>CPU上下文切换</strong>，所谓的 CPU 上下文，就是一堆寄存器，里面保存了 CPU运行任务所需要的信息：从哪里开始运行，协程切换非常简单，就是把<strong>当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上</strong>就 ok 了。而且<strong>完全在用户态进行</strong>，一般来说一次协程上下文切换最多就是<strong>几十ns</strong> 这个量级。</p>
<p>系统内核调度的对象是线程，因为线程是调度的基本单元，而<strong>线程的调度只有拥有最高权限的内核空间才可以完成</strong>，所以线程的切换涉及到<strong>用户空间和内核空间的切换</strong>，也就是特权模式切换，然后需要操作系统调度模块完成<strong>线程调度（task*</strong>struct），*而且除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等，说白了就是上下文比协程多一些</p>
<h3 id="4-进程和线程的通信"><a href="#4-进程和线程的通信" class="headerlink" title="4. 进程和线程的通信"></a>4. 进程和线程的通信</h3><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><ul>
<li><strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。（半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。）</li>
<li><strong>命名管道 (FIFO)</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>主要原因是由于在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达MySQL，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误。通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。点对点、发布/订阅、PUSH/PULL</li>
<li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。(原理一定要清楚，常考)</li>
<li><strong>信号量</strong>：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据，有XSI信号量和POSIX信号量，POSIX信号量更加完善。</li>
<li><strong>信号 ( signal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。</li>
<li><strong>套接字( socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li><strong>共享文件映射mmap</strong><br>mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。</li>
<li>mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里（但是会占掉你的 virutal memory）, 然后你就可以用memcpy等操作写文件, 而不用write()了.写完后，内存中的内容并不会立即更新到文件中，而是有一段时间的延迟，你可以调用msync()来显式同步一下, 这样你所写的内容就能立即保存到文件里了.这点应该和驱动相关。<br>mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过MMU将逻辑地址转换成物理地址</li>
<li>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上</li>
</ul>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><ul>
<li>互斥锁（mutex）</li>
<li>条件变量（condition variable）</li>
<li>信号量（Semaphore）</li>
<li>临界区（Critical Section）</li>
<li>自旋锁（Spinlock）</li>
<li>读写锁（readers-writer lock）</li>
<li>屏障（Memory barrier）</li>
</ul>
<h3 id="5-进程调度算法"><a href="#5-进程调度算法" class="headerlink" title="5. 进程调度算法"></a>5. 进程调度算法</h3><ol>
<li><p>FCFS</p>
</li>
<li><p>SJF</p>
</li>
<li><p>时间片轮转调度算法(Round Robin，RR)</p>
</li>
<li><p>多级反馈队列调度算法（MLFQ：Multi-level Feedback Queue）</p>
<ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，第i+1个队列的时间片要比第i个队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列</li>
<li>仅当<strong><em>\</em>第一队列空闲时**</strong>，调度程序<strong><em>\</em>才调度第二队列中的进程运行**</strong>；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。</li>
</ol>
</li>
<li><p>优先级调度算法</p>
<ol>
<li>非抢占式优先权算法<ol>
<li>系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便<strong><em>\</em>一直执行下去，直至完成**</strong>；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程</li>
</ol>
</li>
<li>抢占式优先权调度算法<ol>
<li>系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，<strong>*\</strong>*只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程**(**原优先权最高的进程****)****的执行，重新将处理机分配给新到的优先权最高的进程。**<em>**</em></li>
</ol>
</li>
</ol>
</li>
<li><p>CFS</p>
<ol>
<li><p>vruntime。如果一个进程得以执行，随着时间的增长（即一个个tick的到来），其vruntime将不断增大。没有得到执行的进程vruntime不变。<br>  调度器总是选择vruntime值最低的进程执行。这就是所谓的“完全公平”。对于不同进程，优先级高的进程vruntime增长慢，以至于它能得到更多的运行时间。</p>
</li>
<li><p>nice 值 静态优先级</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRI是比较好理解的，即进程的优先级，或者通俗点说就是程序被CPU执行的先后顺序，此值越小进程的优先级别越高。那NI呢？就是我们所要说的nice值了，其表示进程可被执行的优先级的修正数值。如前面所说，PRI值越小越快被执行，那么加入nice值后，将会使得PRI变为：PRI(new)=PRI(old)+nice。由此看出，PR是根据NICE排序的，规则是NICE越小PR越前（小，优先权更大），即其优先级会变高，则其越快被执行。如果NICE相同则进程uid是root的优先权更大。</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="6-linux子进程"><a href="#6-linux子进程" class="headerlink" title="6. linux子进程"></a>6. linux子进程</h3><h4 id="父子进程之间的关系"><a href="#父子进程之间的关系" class="headerlink" title="父子进程之间的关系"></a>父子进程之间的关系</h4><p>关于资源：子进程得到的是除了代码段是与父进程共享的意外，其他所有的都是得到父进程的一个副本，子进程的所有资源都继承父进程，得到父进程资源的副本，既然为副本，也就是说，二者并不共享地址空间。，两个是单独的进程，继承了以后二者就没有什么关联了，子进程单独运行。（采用写时复制技术）<br>关于文件描述符：继承父进程的文件描述符时，相当于调用了dup函数，父子进程共享文件表项，即共同操作同一个文件，一个进程修改了文件，另一个进程也知道此文件被修改了。</p>
<p>fork之后，<strong>操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置</strong>（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p>
<p><strong>僵尸进程</strong>：一个子进程在其父进程没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。如果其父进程还存在而一直不调用wait，则该僵尸进程将无法回收，等到其父进程退出后该进程将被init回收。<br><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<h4 id="7-fork-vfork和clone"><a href="#7-fork-vfork和clone" class="headerlink" title="7. fork vfork和clone"></a>7. fork vfork和clone</h4><ol>
<li>fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容</li>
<li>vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行</li>
<li>Linux上创建线程一般使用的是pthread库 实际上linux也给我们提供了创建线程的系统调用，就是clone，是创造新的空间。clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。</li>
</ol>
<p>fork 创造的子进程复制了父亲进程的资源（写时复制技术），包括内存的内容task_struct内容（2个进程的pid不同）。这里是资源的复制不是指针的复制。</p>
<p>copy-on-write</p>
<p> 我们都知道fork创建进程的时候，并没有真正的copy内存（听着好像矛盾了，资源的赋值为什么有没有真正的赋值呢？），因为我们知道，对于fork来讲，有一个很讨厌的东西叫exec系列的系统调用，它会勾引子进程另起炉灶。如果创建子进程就要内存拷贝的的话，一执行exec，辛辛苦苦拷贝的内存又被完全放弃了。由于fork()后会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，处于效率考虑，linux中引入了“写时复制技术-Copy-On-Write”。</p>
<pre><code>换言之，在fork()之后exec之前两个进程用的是相同的物理空间（内存区），先把页表映射关系建立起来，并不真正将内存拷贝。子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父进程中有更改相应段的行为发生时，如进程写访问，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。fork时子进程获得父进程数据空间、堆和栈的复制所以变量的地址（当然是虚拟地址）是一样的。</code></pre><p> vfork是一个过时的应用，vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。vfork最初是因为fork没有实现COW机制，而很多情况下fork之后会紧接着exec，而exec的执行相当于之前fork复制的空间全部变成了无用功，所以设计了vfork。而现在fork使用了COW机制，唯一的代价仅仅是复制父进程页表的代价，所以vfork不应该出现在新的代码之中。      </p>
<pre><code>vfork创建出来的不是真正意义上的进程，而是一个线程，因为它缺少经常要素（4），独立的内存资源</code></pre><p> clone是Linux为创建线程设计的（虽然也可以用clone创建进程）。所以可以说clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等。</p>
<h3 id="阻塞的进程不占用资源"><a href="#阻塞的进程不占用资源" class="headerlink" title="阻塞的进程不占用资源"></a>阻塞的进程不占用资源</h3><p>当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象（如下图）。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。</p>
<p>当程序执行到recv时，操作系统会将进程A从工作队列移动到该socket的等待队列中（如下图）。由于工作队列只剩下了进程B和C，依据进程调度，cpu会轮流执行这两个进程的程序，不会执行进程A的程序。所以进程A被阻塞，不会往下执行代码，也不会占用cpu资源。</p>
<p><strong>唤醒进程</strong></p>
<p>当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于socket的接收缓冲区已经有了数据，recv可以返回接收到的数据。</p>
<h3 id="8-惊群效应"><a href="#8-惊群效应" class="headerlink" title="8. 惊群效应"></a>8. 惊群效应</h3><p>方法一：要想避免如上线程池设计中的惊群问题，在仍然共用一个线程互斥锁的条件下，给每一个消费者线程创建一个线程条件变量，生产者线程在添加任务时，找到空闲的消费者线程，将任务置入该消费者的任务队列中，同时只通知 (pthread_cond_signal) 该消费者的线程条件变量，消费者线程与生产者线程虽然共用相同的线程互斥锁（因为有全局资源及调用 pthread_cond_wait 所需），但线程条件变量的通知过程却是定向通知的，未被通知的消费者线程不会被唤醒，这样惊群现象也就不会产生了。当然，还有一些设计上的细节需要注意，比如：当没有空闲消费者线程时，需要将任务添加进线程池的全局任务队列中，消费者线程处理完自己的任务后需要查看一下线程池中的全局任务队列中是否还有未处理的任务。</p>
<p>【大意】：在线程池中，增加一组线程条件变量，对应于每一个线程。增加任务的时候，如果有空闲线程，那么只通知某一个空闲线程，并且将其置忙。忙与闲，可以通过条件变量来表征，用一个链表表示(类似连接池)。</p>
<p>如果所有线程都忙，那么就将任务加入全局队列，并且通知所有消费者（这时惊群是很小的，除非所有线程都刚好同一时刻完成任务，同一时刻争夺资源，否则只有极少数线程会发生惊群）。</p>
<h1 id="LRU（页面置换算法）"><a href="#LRU（页面置换算法）" class="headerlink" title="LRU（页面置换算法）"></a>LRU（页面置换算法）</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0wOWYwMzc2MDhiMWIyZGU3MGI1MmQxMzEyZWYzYjMwN19oZC5qcGc?x-oss-process=image/format,png" alt="img"></p>
<h1 id="linux-细节要点"><a href="#linux-细节要点" class="headerlink" title="linux 细节要点"></a>linux 细节要点</h1><h4 id="删除大于50MB的文件"><a href="#删除大于50MB的文件" class="headerlink" title="删除大于50MB的文件"></a>删除大于50MB的文件</h4><p>显示当前路径下，大于50M的文件。（包含子文件夹内的文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -size +50M</span><br></pre></td></tr></table></figure>

<p>删除当前路径下，大于50M的文件。（包含子文件夹内的文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -size +50M -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h4 id="关闭一个进程"><a href="#关闭一个进程" class="headerlink" title="关闭一个进程"></a>关闭一个进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep firefox</span><br><span class="line">kill -s 9 1827</span><br><span class="line">ps -ef | grep firefox | grep -v grep | cut -c 9-15 | xargs kill -s 9</span><br><span class="line">kill -s 9 `ps -aux | grep firefox | awk &apos;&#123;print $2&#125;&apos;`</span><br></pre></td></tr></table></figure>

<h4 id="查找一个带有关键字的进程"><a href="#查找一个带有关键字的进程" class="headerlink" title="查找一个带有关键字的进程"></a>查找一个带有关键字的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep some_string</span><br><span class="line">输出时，不仅会输出将要查找的进程数据，清空包括grep进程本身的数据，因为查找串包含在grep调用中。过滤grep本身方法有：</span><br><span class="line">ps -ef | grep some_string |grep -v grep</span><br><span class="line"></span><br><span class="line">按内存升序排列：ps aux --sort=rss </span><br><span class="line">按CPU降序排列：ps aux --sort=-%cpu</span><br><span class="line"></span><br><span class="line">top</span><br><span class="line">按内存排序 shift + M</span><br><span class="line">按cpiu排序 shift + P</span><br></pre></td></tr></table></figure>

<h4 id="netstat查询占用端口号"><a href="#netstat查询占用端口号" class="headerlink" title="netstat查询占用端口号"></a>netstat查询占用端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulp |grep 端口号</span><br></pre></td></tr></table></figure>

<h4 id="cpu-memory-查询"><a href="#cpu-memory-查询" class="headerlink" title="cpu memory 查询"></a>cpu memory 查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU占用率查看命令：top</span><br><span class="line">内存占用率：free -m</span><br></pre></td></tr></table></figure>

<h4 id="Linux下-proc目录简介"><a href="#Linux下-proc目录简介" class="headerlink" title="Linux下/proc目录简介"></a>Linux下/proc目录简介</h4><p>Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p>
<p>用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的。</p>
<h4 id="sql语句运行时间"><a href="#sql语句运行时间" class="headerlink" title="sql语句运行时间"></a>sql语句运行时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set profiling = 1;</span><br><span class="line">select timestampdiff(second,@d,now());</span><br></pre></td></tr></table></figure>

<h1 id="I-O-要点"><a href="#I-O-要点" class="headerlink" title="I/O 要点"></a>I/O 要点</h1><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。<code>那么这就是所谓的 “IO 多路复用”</code>。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。</p>
<p><code>IO多路复用有两个特别的系统调用select、poll、epoll函数</code>。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—<code>前者可以等待多个socket，能实现同时对多个IO端口进行监听</code>，当其中任何一个socket的数据准好了，<code>就能返回进行可读</code>，<code>然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的</code>。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，<code>此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理</code>。如何知道有一部分数据到达了呢？<code>监视的事情交给了内核，内核负责数据到达的处理。也可以理解为&quot;非阻塞&quot;吧</code>。</p>
<p>对于多路复用，也就是轮询多个socket。<code>多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了</code>，当然也可以针对不同的编号。</p>
<h3 id="select-poll-epoll的区别"><a href="#select-poll-epoll的区别" class="headerlink" title="select poll epoll的区别"></a>select poll epoll的区别</h3><p>实际中，这三个函数对于每一个socket，一般都设置成为non-blocking，但是，整个用户的process其实是一直被block的。`只不过process是被函数block，而不是被socket IO给block。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<p><strong>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</strong></p>
<p><strong>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</strong></p>
<p><strong>（3）select支持的文件描述符数量太小了，默认是1024</strong></p>
<p>（4）如果要在循环中重复调用 <code>select()</code> 的话，我们必须每次都要重新初始化 <code>fd_set</code>。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构。而<code>poll()</code>通过独立的两个字段<code>events</code> （针对输入）和 <code>revents</code> （针对输出）来处理，从而避免每次都要重新初始化参数。</p>
<p>poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>红黑树管理文件描述符，用于查找fd是否存在</p>
<p>用了一个双向链表接收内核触发的事件</p>
<p>优点</p>
<ol>
<li><code>没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li><code>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li><code>内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</li>
</ol>
<p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
<p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。</p>
<p>从本质上来讲，ET相对LT是通过减少系统调用来提高并行效率的。</p>
<ul>
<li><strong>LT 模式</strong></li>
</ul>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ul>
<li><strong>ET模式</strong></li>
</ul>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h6 id="编程注意事项"><a href="#编程注意事项" class="headerlink" title="编程注意事项"></a>编程注意事项</h6><p>在ET模式下，读取套接字必须要读干净。</p>
<ul>
<li>在LT模式下，当socket可写时，会不停的触发socket可写的事件，如何处理？</li>
</ul>
<p>第一种最普遍的方式：<br>需要向socket写数据的时候才把socket加入epoll，等待可写事件。接受到可写事件后，调用write或者send发送数据。当所有数据都写完后，把socket移出epoll。</p>
<p>这种方式的缺点是，即使发送很少的数据，也要把socket加入epoll，写完后在移出epoll，有一定操作代价。</p>
<p>第二种</p>
<p>开始不把socket加入epoll，需要向socket写数据的时候，直接调用write或者send发送数据。如果返回EAGAIN，把socket加入epoll，在epoll的驱动下写数据，全部数据发送完毕后，再移出epoll。</p>
<p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>
<p>这种方式的优点是：数据不多的时候可以避免epoll的事件处理，提高效率。</p>
<ul>
<li><strong>ET模式的线程饥饿问题</strong></li>
</ul>
<p>如果某个socket源源不断地收到非常多的数据，在试图读取完所有数据的过程中，有可能会造成其他的socket得不到处理，从而造成饥饿问题。</p>
<p>解决办法：为每个已经准备好的描述符维护一个队列，这样程序就可以知道哪些描述符已经准备好了但是并没有被读取完，然后程序定时或定量的读取，如果读完则移除，直到队列为空，这样就保证了每个fd都被读到并且不会丢失数据，流程如图:</p>
<ul>
<li><strong>EPOLLONESHOT设置</strong></li>
</ul>
<p>A线程读完某socket上数据后开始处理这些数据，此时该socket上又有新数据可读，B线程被唤醒读新的数据，造成2个线程同时操作一个socket的局面 ，EPOLLONESHOT保证一个socket连接在任一时刻只被一个线程处理。</p>
<ul>
<li><strong>两种模式的选择</strong></li>
</ul>
<p>通过前面的对比可以看到LT模式比较安全并且代码编写也更清晰，但是ET模式属于高速模式，在处理大高并发场景使用得当效果更好，具体选择什么根据自己实际需要和团队代码能力来选择，如果并发很高且团队水平较高可以选择ET模式，否则建议LT模式。</p>
<p><strong>6.epoll的惊群问题</strong></p>
<p>在2.6.18内核中accept的惊群问题已经被解决了，但是在epoll中仍然存在惊群问题，表现起来就是当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。<br>在epoll官方没有正式修复这个问题之前，Nginx作为知名使用者采用全局锁来限制每次可监听fd的进程数量，每次只有1个可监听的进程，后来在Linux 3.9内核中增加了SO_REUSEPORT选项实现了内核级的负载均衡，Nginx1.9.1版本支持了reuseport这个新特性，从而解决惊群问题。EPOLLEXCLUSIVE是在2016年Linux 4.5内核新添加的一个 epoll 的标识，Ngnix 在 1.11.3 之后添加了NGX_EXCLUSIVE_EVENT选项对该特性进行支持。EPOLLEXCLUSIVE标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2020/03/12/distributed-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/12/distributed-system/" itemprop="url">distributed system</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-12T16:07:25+08:00">
                2020-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h2 id="分布式系统原则"><a href="#分布式系统原则" class="headerlink" title="分布式系统原则"></a>分布式系统原则</h2><h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h4><ul>
<li>口信消息型拜占庭问题之解<ul>
<li>n 位将军，最多能容忍 (n - 1) / 3 位叛将。</li>
</ul>
</li>
<li>签名消息型拜占庭问题之解<ul>
<li>忠诚将军的签名无法伪造，而且对他签名消息的内容进行任何更改都会被发现；</li>
<li>任何人都能验证将军签名的真伪。</li>
</ul>
</li>
</ul>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><ul>
<li>一致性（Consistency）<ul>
<li>一致性说的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失败。</li>
<li>一致性强调的是各节点间的数据一致。</li>
</ul>
</li>
<li>可用性（Availability）<ul>
<li>可用性说的是任何来自客户端的请求，不管访问哪个节点，都能得到响应数据，但不保证是同一份最新数据。我尽力给你返回数据，不会不响应你，但是我不保证每个节点给你的数据都是最新的。</li>
<li>这个指标强调的是服务可用，但不保证数据的一致。</li>
</ul>
</li>
<li>分区容错性（Partition Tolerance）<ul>
<li>当节点间出现任意数量的消息丢失或高延迟的时候，系统仍然可以继续提供服务。也就是说，分布式系统在告诉访问本系统的客户端：不管我的内部出现什么样的数据同步问题，我会一直运行，提供服务。</li>
<li>这个指标，强调的是集群对分区故障的容错能力。</li>
</ul>
</li>
</ul>
<p>CAP 不可能三角说的是对于一个分布式系统而言，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）3 个指标不可兼得，只能在 3 个指标中选择 2 个。节点间的分区故障是必然发生的。也就是说，分区容错性（P）是前提，是必须要保证的。</p>
<p>现在就只剩下一致性（C）和可用性（A）可以选择了：要么选择一致性，保证数据绝对一致；要么选择可用性，保证服务可用。那么 CP 和 AP 的含义是什么呢？</p>
<ul>
<li>当选择了一致性（C）的时候，如果因为消息丢失、延迟过高发生了网络分区，那么这个时候，当集群节点接收到来自客户端的写请求时，因为无法保证所有节点都是最新信息，所以系统将返回写失败错误，也就是说集群拒绝新数据写入。<ul>
<li>CP 模型，采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写入，典型的应用是 ZooKeeper，Etcd 和 HBase。</li>
</ul>
</li>
<li>当选择了可用性（A）的时候，系统将始终处理客户端的查询，返回特定信息，如果发生了网络分区，一些节点将无法返回最新的特定信息，它们将返回自己当前的相对新的信息。<ul>
<li>AP 模型，采用 AP 模型的分布式系统，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误，但当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。典型应用就比如 Cassandra 和 DynamoDB。</li>
</ul>
</li>
</ul>
<p>在不存在网络分区的情况下，也就是分布式系统正常运行时（这也是系统在绝大部分时候所处的状态），就是说在不需要 P 时，C 和 A 能够同时保证。只有当发生分区故障的时候，也就是说需要 P 时，才会在 C 和 A 之间做出选择。而且如果各节点数据不一致，影响到了系统运行或业务运行（也就是说会有负面的影响），推荐选择 C，否则选 A。</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>二阶段提交<ul>
<li>提交请求（投票阶段），提交执行（完成阶段）</li>
<li>为了原子性</li>
<li>“协调者故障，参与者长期锁定资源”的痛点</li>
</ul>
</li>
<li>TCC（Try-Confirm-Cancel）<ul>
<li>TCC 是 Try（预留）、Confirm（确认）、Cancel（撤销）</li>
<li>它的核心思想是针对每个操作都要注册一个与其对应的确认操作和补偿操作（也就是撤销操作）。</li>
</ul>
</li>
</ul>
<h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><ul>
<li>基本可用（Basically Available）</li>
<li>最终一致性（Eventually consistent）</li>
<li>软状态（Soft state）</li>
</ul>
<h5 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h5><p>可以把基本可用理解成，当系统节点出现大规模故障的时候，比如专线的光纤被挖断、突发流量导致系统过载（出现了突发事件，服务被大量访问），这个时候可以通过服务降级，牺牲部分功能的可用性，保障系统的核心功能可用。</p>
<ul>
<li>流量削峰</li>
<li>延迟响应</li>
<li>体验降级， 比如用小图片来替代原始图片，通过降低图片的清晰度和大小，提升系统的处理能力。</li>
<li>过载保护， 比如把接收到的请求放在指定的队列中排队处理，如果请求等待时间超时了（假设是 100ms），这个时候直接拒绝超时请求</li>
</ul>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性是说，系统中所有的数据副本在经过一段时间的同步后，最终能够达到一个一致的状态。也就是说，在数据一致性上，存在一个短暂的延迟。</p>
<p>你可以将强一致性理解为最终一致性的特例，也就是说，你可以把强一致性看作是不存在延迟的一致性。在实践中，你也可以这样思考： 如果业务的某功能无法容忍一致性的延迟（比如分布式锁对应的数据），需要实现的是强一致性；如果能容忍短暂的一致性的延迟（比如 QQ 状态数据），就可以考虑最终一致性。</p>
<p>那么如何实现最终一致性呢？你首先要知道它以什么为准，因为这是实现最终一致性的关键。一般来说，在实际工程实践中有这样几种方式：</p>
<ul>
<li>以最新写入的数据为准，比如 AP 模型的 KV 存储采用的就是这种方式；</li>
<li>以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准。</li>
</ul>
<p>那实现最终一致性的具体方式是什么呢？常用的有这样几种。</p>
<ul>
<li>读时修复：在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>
<li>写时修复：在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li>异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
<h2 id="一致哈希"><a href="#一致哈希" class="headerlink" title="一致哈希"></a>一致哈希</h2><p>我们通过 Raft 算法实现了 KV 存储，虽然领导者模型简化了算法实现和共识协商，但写请求只能限制在领导者节点上处理，导致了集群的接入性能约等于单机，那么随着业务发展，集群的性能可能就扛不住了，会造成系统过载和服务不可用，这时该怎么办呢？其实这是一个非常常见的问题。在我看来，这时我们就要通过分集群，突破单集群的性能限制了。</p>
<p>说到这儿，有同学可能会说了，分集群还不简单吗？加个 Proxy 层，由 Proxy 层处理来自客户端的读写请求，接收到读写请求后，通过对 Key 做哈希找到对应的集群就可以了啊。是的，哈希算法的确是个办法，但它有个明显的缺点：当需要变更集群数时（比如从 2 个集群扩展为 3 个集群），这时大部分的数据都需要迁移，重新映射，数据的迁移成本是非常高的。那么如何解决哈希算法，数据迁移成本高的痛点呢？答案就是一致哈希（Consistent Hashing）。</p>
<p>迁移成本是非常高昂的，这在实际生产环境中也是无法想象的。那我们如何通过一致哈希解决这个问题呢？</p>
<p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算。你可以想象下，一致哈希算法，将整个哈希值空间组织成一个虚拟的圆环，也就是哈希环：</p>
<p><img src="https://static001.geekbang.org/resource/image/3c/f5/3cb21a553580afbc840b68d4c6b128f5.jpg" alt="img"></p>
<p>从图 4 中你可以看到，哈希环的空间是按顺时针方向组织的，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、5、6……直到 2^32-1，也就是说 0 点左侧的第一个点代表 2^32-1。</p>
<p>在一致哈希中，你可以通过执行哈希算法（为了演示方便，假设哈希算法函数为“c-hash()”），将节点映射到哈希环上，比如选择节点的主机名作为参数执行 c-hash()，那么每个节点就能确定其在哈希环上的位置了：</p>
<p>当需要对指定 key 的值进行读写的时候，你可以通过下面 2 步进行寻址：</p>
<ul>
<li>首先，将 key 作为参数执行 c-hash() 计算哈希值，并确定此 key 在环上的位置；</li>
<li>然后，从这个位置沿着哈希环顺时针“行走”，遇到的第一节点就是 key 对应的节点。</li>
</ul>
<p>在一致哈希中，如果节点太少，容易因为节点分布不均匀造成数据访问的冷热不均，也就是说大多数访问请求都会集中少量几个节点上：</p>
<p>其实，就是对每一个服务器节点计算多个哈希值，在每个计算结果位置上，都放置一个虚拟节点，并将虚拟节点映射到实际节点。比如，可以在主机名的后面增加编号，分别计算 “Node-A-01”“Node-A-02”“Node-B-01”“Node-B-02”“Node-C-01”“Node-C-02”的哈希值，于是形成 6 个虚拟节点</p>
<h2 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h2><h4 id="Gossip-三板斧"><a href="#Gossip-三板斧" class="headerlink" title="Gossip 三板斧"></a>Gossip 三板斧</h4><ul>
<li><p>直接邮寄（Direct Mail）</p>
<ul>
<li>就是直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。</li>
</ul>
</li>
<li><p>反熵（Anti-entropy）</p>
<ul>
<li>如何实现最终一致性呢？答案就是反熵。本质上，反熵是一种通过异步修复实现最终一致性的方法反熵指的是集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性</li>
<li>推、拉和推拉三种方式</li>
<li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵</li>
<li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵</li>
<li>这个方式就是同时修复自己副本和对方副本中的熵</li>
</ul>
</li>
<li><p>谣言传播（Rumor mongering）</p>
<ul>
<li><p>如果是一个动态变化或节点数比较多的分布式环境（比如在 DevOps 环境中检测节点故障，并动态维护集群节点状态），这时反熵就不适用了。那么当你面临这个情况要怎样实现最终一致性呢？答案就是谣言传播。</p>
</li>
<li><p>广泛地散播谣言，它指的是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据</p>
</li>
</ul>
</li>
</ul>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce既是一个编程模型，又是一个计算框架。也就是说，开发人员必须基于MapReduce编程模型进行编程开发，然后将程序通过MapReduce计算框架分发到Hadoop集群中运行。</p>
<p>简单在于其编程模型只包含map和reduce两个过程，map的主要输入是一对&lt;key , value&gt;值，经过map计算后输出一对&lt;key , value&gt;值；然后将相同key合并，形成&lt;key , value集合&gt;；再将这个&lt;key , value集合&gt;输入reduce，经过计算输出零个或多个&lt;key , value&gt;对。</p>
<p>第一类称为Master，Master是负责调度的，相当于工地的工头。第二类叫Worker，相当于干活儿的工人。Woker进一步分为两种，一种Worker叫Mapper，另一种叫Reducer。假设我们有一个巨大的数据集，里面有海量规模的元素，元素的个数为M，每个元素都需要进行同一个函数处理。于是Master将M分成许多小份，然后每一份分给一个Mapper来做，Mapper干完活儿（执行完函数），将自己那一份儿活儿的结果传给Reducer。Reducer之后统计汇总各个Mapper传过来的结果，得到最后的任务的答案。</p>
<h3 id="WC为例"><a href="#WC为例" class="headerlink" title="WC为例"></a>WC为例</h3><h4 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">  line = line.strip()</span><br><span class="line">  word = line.split()</span><br><span class="line">  <span class="keyword">for</span> w <span class="keyword">in</span> words():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>对，就这么简单，你看到了，对于输入进来的每一行，我们做完切分之后，都会输出(单词，1)这样一个kv对，表明这个单词出现过。</p>
<h4 id="排序阶段"><a href="#排序阶段" class="headerlink" title="排序阶段"></a>排序阶段</h4><p>中间会有一个对上述结果进行排序的过程，以保证所有相同的单词都在一起，不过不用担心，这个过程是系统会自动完成的，因此不用我们编写额外的代码。</p>
<h4 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">current_word = <span class="literal">None</span></span><br><span class="line">current_count = <span class="number">0</span></span><br><span class="line">word = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依旧是标准输入过来的数据</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">    <span class="comment"># 去除左右空格</span></span><br><span class="line">    line = line.strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照tab键对行切分，得到word和次数1</span></span><br><span class="line">    word, count = line.split(<span class="string">'\t'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 你得到的1是一个字符串，需要对它进行类型转化</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        count = int(count)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="comment">#如果不能转成数字，输入有问题，调到下一行</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果本次读取的单词和上一次一样，对次数加1</span></span><br><span class="line">    <span class="keyword">if</span> current_word == word:</span><br><span class="line">        current_count += count</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> current_word:</span><br><span class="line">            <span class="comment"># 输出统计结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (current_word, current_count)</span><br><span class="line">        current_count = count</span><br><span class="line">        current_word = word</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要忘了最后一个词哦，也得输出结果</span></span><br><span class="line"><span class="keyword">if</span> current_word == word:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (current_word, current_count)</span><br></pre></td></tr></table></figure>

<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop的核心，说白了，就是HDFS和MapReduce。HDFS为海量数据提供了<strong>存储</strong>，而MapReduce为海量数据提供了<strong>计算框架</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-af31c33db7daa0761da1ed03327154fd_1440w.jpg" alt="img"></p>
<p>首先看看<strong>HDFS</strong></p>
<p>整个HDFS有三个重要角色：<strong>NameNode</strong>（名称节点）、<strong>DataNode</strong>（数据节点）和<strong>Client</strong>（客户机）。</p>
<p><strong>NameNode：</strong>是Master节点（主节点），可以看作是分布式文件系统中的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Meta-data存储在内存中，这些信息主要包括了文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode的信息等。</p>
<p><strong>DataNode：</strong>是Slave节点（从节点），是文件存储的基本单元，它将Block存储在本地文件系统中，保存了Block的Meta-data，同时周期性地将所有存在的Block信息发送给NameNode。</p>
<p><strong>Client：</strong>切分文件；访问HDFS；与NameNode交互，获得文件位置信息；与DataNode交互，读取和写入数据。 </p>
<p>还有一个<strong>Block（块）</strong>的概念：Block是HDFS中的基本读写单元；HDFS中的文件都是被切割为block（块）进行存储的；这些块被复制到多个DataNode中；块的大小（通常为64MB）和复制的块数量在创建文件时由Client决定。</p>
<p><strong>HBase</strong>：来源于Google的BigTable；是一个高可靠性、高性能、面向列、可伸缩的分布式数据库。</p>
<p><strong>高效性</strong>：Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。</p>
<p><strong>高容错性</strong>：Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。这个其实也算是高可靠性。</p>
<p><strong>MapReduce是面向磁盘的</strong>。因此，受限于磁盘读写性能的约束，MapReduce在处理迭代计算、实时计算、交互式数据查询等方面并不高效。但是，这些计算却在图计算、数据挖掘和<strong>机器学习</strong>等相关应用领域中非常常见。</p>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>而<strong>Spark是面向内存的</strong>。这使得Spark能够为多个不同数据源的数据提供近乎实时的处理性能，适用于需要多次操作特定数据集的应用场景。</p>
<p>Spark 基于 Hadoop MapReduce 算法实现的分布式计算，拥有 Hadoop MapReduce 所具有的优点，并且具有更高的运算速度。Spark 能够比 Hadoop 运算更快，主要原因是：Hadoop 在一次 MapReduce 运算之后，会将数据的运算结果从内存写入到磁盘中，第二次 MapReduce 运算时在从磁盘中读取数据，两次对磁盘的操作，增加了多余的 IO 消耗；而 Spark 则是将数据一直缓存在内存中，运算时直接从内存读取数据，只有在必要时，才将部分数据写入到磁盘中。除此之外，Spark 使用最先进的 DAG（Directed Acyclic Graph,有向无环图）调度程序、查询优化器和物理执行引擎，在处理批量处理以及处理流数据时具有较高的性能。按照<a href="https://spark.apache.org/" target="_blank" rel="noopener">Spark 官网</a>的说法，Spark 相对于 Hadoop 而言，Spark 能够达到 100 倍以上的运行负载。</p>
<p><strong>SparkContext：</strong>是 Spark 所有功能的主要入口点，它是用户逻辑与 Spark 集群主要的交互接口。通过<strong>SparkContext</strong>，可以连接到集群管理器（<strong>Cluster Manager</strong>），能够直接与集群 Master 节点进行交互，并能够向 Master 节点申请计算资源，也能够将应用程序用到的 JAR 包或 Python 文件发送到多个执行器（<strong>Executor</strong>）节点上。</p>
<p><strong>Cluster Manager：</strong>即集群管理器，它存在于 Master 进程中，主要用来对应用程序申请的资源进行管理。</p>
<p><strong>Worker Node：</strong>任何能够在集群中能够运行 Spark 应用程序的节点。</p>
<p><strong>Task：</strong>由<strong>SparkContext</strong>发送到<strong>Executor</strong>节点上执行的一个工作单元。</p>
<p><strong>Executor：</strong>也即执行器节点，它是在一个在工作节点（<strong>Worker Node</strong>）上为<strong>Application</strong>启动的进程，它能够运行 Task 并将数据保存在内存或磁盘存储中，也能够将结果数据返回给<strong>Driver</strong>。</p>
<h4 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h4><p>即弹性分布式数据集（Resilient Distributed Datasets），是一种容错的、可以被并行操作的元素集合，它是 Spark 中最重要的一个概念，是 Spark 对所有数据处理的一种基本抽象。Spark 中的计算过程可以简单抽象为对 RDD 的创建、转换和返回操作结果的过程：</p>
<p><img src="https://image.jiqizhixin.com/uploads/editor/3ad43d47-e95f-4144-b3b8-d2181394d449/640.png" alt="img"></p>
<p><strong>makeRDD：</strong>可以通过访问外部物理存储（如 HDFS），通过调用 SparkContext.textFile()方法来读取文件并创建一个 RDD，也可以对输入数据集合通过调用 SparkContext.parallelize()方法来创建一个 RDD。<strong>RDD 被创建后不可被改变，只可以对 RDD 执行 Transformation 及 Action 操作。</strong></p>
<p><strong>Transformation（转换）：</strong>对已有的 RDD 中的数据执行计算进行转换，并产生新的 RDD，在这个过程中有时会产生中间 RDD。Spark 对于<strong>Transformation</strong>采用惰性计算机制，即在 Transformation 过程并不会立即计算结果，而是在 Action 才会执行计算过程。如<strong>map</strong>、<strong>filter</strong>、<strong>groupByKey、cache</strong>等方法，只执行<strong>Transformation</strong>操作，而不计算结果。</p>
<p><strong>Action（执行）：</strong>对已有的 RDD 中的数据执行计算产生结果，将结果返回 Driver 程序或写入到外部物理存储（如 HDFS）。如<strong>reduce</strong>、<strong>collect</strong>、<strong>count</strong>、<strong>saveAsTextFile</strong>等方法，会对 RDD 中的数据执行计算。</p>
<p><strong>partition（分区）</strong>是 Spark 中的重要概念，它是<strong>RDD</strong>的最小单元，<strong>RDD</strong>是由分布在各个节点上的<strong>partition</strong> 组成的。<strong>partition</strong>的数量决定了<strong>task</strong>的数量，每个<strong>task</strong>对应着一个<strong>partition</strong>。</p>
<p>例如，使用 Spark 来读取本地文本文件内容，读取完后，这些内容将会被分成多个<strong>partition</strong>，这些<strong>partition</strong>就组成了一个<strong>RDD</strong>，同时这些<strong>partition</strong>可以分散到不同的机器上执行。RDD 的 partition 描述如下图所示：</p>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>从本质上说，Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。raft解决的问题就是如何让多个副本的<strong>日志</strong>数据达成一致。</p>
<h4 id="为什么要51"><a href="#为什么要51" class="headerlink" title="为什么要51%"></a>为什么要51%</h4><ol>
<li>考虑 2N+1 个节点。一份数据，至少需要复制到 N+1 个节点上才算是提交（commit），否则可能出现冲突。比方说事件 x=1 发到 N 个节点，同时事件 x=2 发到另外 N 个节点。如果 x=1 和 x=2 同时提交了，最终 x 的值是多少很难说清。这和多线程锁是一样的。2N 个节点的情况也同理。</li>
<li>一份数据复制到 N 个节点上，如果要容忍 K 个错误，需要 K &lt; N，这样才能保证复制到 N 个节点满足数据提交的要求。也就是说，N 个节点，最多容忍 N-1 个错误。</li>
</ol>
<p>我也时常在想一个问题，为什么多数一致性协议都要求过半节点复制成功才算提交？3 个节点，复制到 2 个才算提交（2/3）；5 个节点，复制到 3 个才算提交（3/5）。为什么没有一个专门优化 4/6 或者 4/5 的协议？</p>
<p>我觉得可能是“<strong>过半</strong>”这个 constraint 足够松，它能够最大程度容忍错误，能够最小程度上保证提交。</p>
<h4 id="如何选举领导者"><a href="#如何选举领导者" class="headerlink" title="如何选举领导者"></a>如何选举领导者</h4><p>成员身份，又叫做服务器节点状态，Raft 算法支持<strong>领导者（Leader）、跟随者（Follower）和候选人（Candidate）</strong> 3 种状态。</p>
<p>跟随者：就相当于普通群众，默默地接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。</p>
<p>候选人：候选人将向其他节点发送请求投票（RequestVote）RPC 消息，通知其他节点来投票，如果赢得了大多数选票，就晋升当领导者。</p>
<p>领导者：蛮不讲理的霸道总裁，一切以我为准，平常的主要工作内容就是 3 部分，处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们现在不要发起新的选举，找个新领导者来替代我。”</p>
<p><strong>Raft 算法是强领导者模型，集群中只能有一个“霸道总裁”。</strong></p>
<h5 id="选举领导者的过程"><a href="#选举领导者的过程" class="headerlink" title="选举领导者的过程"></a>选举领导者的过程</h5><p>每个节点等待领导者节点心跳信息的超时时间间隔是随机的。通过上面的图片你可以看到，集群中没有领导者，而节点 A 的等待超时时间最小（150ms），它会最先因为没有等到领导者的心跳信息，发生超时。</p>
<p>这个时候，节点 A 就增加自己的任期编号，并推举自己为候选人，先给自己投上一张选票，然后向其他节点发送请求投票 RPC 消息，请它们选举自己为领导者</p>
<p>如果其他节点接收到候选人 A 的请求投票 RPC 消息，在编号为 1 的这届任期内，也还没有进行过投票，那么它将把选票投给节点 A，并增加自己的任期编号。</p>
<p>如果候选人在选举超时时间内赢得了大多数的选票，那么它就会成为本届任期内新的领导者。</p>
<p>节点 A 当选领导者后，他将周期性地发送心跳消息，通知其他服务器我是领导者，阻止跟随者发起新的选举，篡权。</p>
<h5 id="节点间如何通讯？"><a href="#节点间如何通讯？" class="headerlink" title="节点间如何通讯？"></a>节点间如何通讯？</h5><p>在 Raft 算法中，服务器节点间的沟通联络采用的是远程过程调用（RPC），在领导者选举中，需要用到这样两类的 RPC：</p>
<ol>
<li>请求投票（RequestVote）RPC，是由候选人在选举期间发起，通知各节点进行投票；</li>
<li>日志复制（AppendEntries）RPC，是由领导者发起，用来复制日志和提供心跳消息。</li>
</ol>
<p><strong>日志复制 RPC 只能由领导者发起</strong></p>
<h5 id="什么是任期"><a href="#什么是任期" class="headerlink" title="什么是任期"></a>什么是任期</h5><ol>
<li>跟随者在等待领导者心跳信息超时后，推举自己为候选人时，会增加自己的任期号，比如节点 A 的当前任期编号为 0，那么在推举自己为候选人时，会将自己的任期编号增加为 1。</li>
<li>如果一个服务器节点，发现自己的任期编号比其他节点小，那么它会更新自己的编号到较大的编号值。比如节点 B 的任期编号是 0，当收到来自节点 A 的请求投票 RPC 消息时，因为消息中包含了节点 A 的任期编号，且编号为 1，那么节点 B 将把自己的任期编号更新为 1。</li>
</ol>
<p>Raft 算法中的任期不只是时间段，而且任期编号的大小，会影响领导者选举和请求的处理。</p>
<ol>
<li>在 Raft 算法中约定，如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态。比如分区错误恢复后，任期编号为 3 的领导者节点 B，收到来自新领导者的，包含任期编号为 4 的心跳消息，那么节点 B 将立即恢复成跟随者状态。</li>
<li>还约定如果一个节点接收到一个包含较小的任期编号值的请求，那么它会直接拒绝这个请求。比如节点 C 的任期编号为 4，收到包含任期编号为 3 的请求投票 RPC 消息，那么它将拒绝这个消息。</li>
</ol>
<h5 id="选举有哪些规则"><a href="#选举有哪些规则" class="headerlink" title="选举有哪些规则"></a>选举有哪些规则</h5><ol>
<li>领导者周期性地向所有跟随者发送心跳消息（即不包含日志项的日志复制 RPC 消息），通知大家我是领导者，阻止跟随者发起新的选举。</li>
<li>如果在指定时间内，跟随者没有接收到来自领导者的消息，那么它就认为当前没有领导者，推举自己为候选人，发起领导者选举。</li>
<li>在一次选举中，赢得大多数选票的候选人，将晋升为领导者。</li>
<li>在一个任期内，领导者一直都会是领导者，直到它自身出现问题（比如宕机），或者因为网络延迟，其他节点发起一轮新的选举。</li>
<li>在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，并且按照“先来先服务”的原则进行投票。比如节点 C 的任期编号为 3，先收到了 1 个包含任期编号为 4 的投票请求（来自节点 A），然后又收到了 1 个包含任期编号为 4 的投票请求（来自节点 B）。那么节点 C 将会把唯一一张选票投给节点 A，当再收到节点 B 的投票请求 RPC 消息时，对于编号为 4 的任期，已没有选票可投了。</li>
<li>当任期编号相同时，日志完整性高的跟随者（也就是最后一条日志项对应的任期编号值更大，索引号更大），拒绝投票给日志完整性低的候选人。比如节点 B、C 的任期编号都是 3，节点 B 的最后一条日志项对应的任期编号为 3，而节点 C 为 2，那么当节点 C 请求节点 B 投票给自己时，节点 B 将拒绝投票。</li>
<li>选举是跟随者发起的，推举自己为候选人；大多数选票是指集群成员半数以上的选票；大多数选票规则的目标，是为了保证在一个给定的任期内最多只有一个领导者。</li>
</ol>
<p>其实在选举中，除了选举规则外，我们还需要避免一些会导致选举失败的情况，比如同一任期内，多个候选人同时发起选举，导致选票被瓜分，选举失败。那么在 Raft 算法中，如何避免这个问题呢？答案就是随机超时时间。</p>
<h5 id="随机超时时间"><a href="#随机超时时间" class="headerlink" title="随机超时时间"></a>随机超时时间</h5><p>在议会选举中，常出现未达到指定票数，选举无效，需要重新选举的情况。在 Raft 算法的选举中，也存在类似的问题，那它是如何处理选举无效的问题呢？</p>
<ol>
<li>跟随者等待领导者心跳信息超时的时间间隔，是随机的；</li>
<li>当没有候选人赢得过半票数，选举无效了，这时需要等待一个随机时间间隔，也就是说，等待选举超时的时间间隔，是随机的。</li>
</ol>
<p>Raft 算法和兰伯特的 Multi-Paxos 不同之处，主要有 2 点。首先，在 Raft 中，不是所有节点都能当选领导者，只有日志最完整的节点，才能当选领导者；其次，在 Raft 中，日志必须是连续的。</p>
<p>本质上，Raft 算法以领导者为中心，选举出的领导者，以“一切以我为准”的方式，达成值的共识，和实现各节点日志的一致。</p>
<h4 id="如何复制日志"><a href="#如何复制日志" class="headerlink" title="如何复制日志"></a>如何复制日志</h4><h5 id="如何理解日志"><a href="#如何理解日志" class="headerlink" title="如何理解日志"></a>如何理解日志</h5><p>副本数据是以日志的形式存在的，日志是由日志项组成，日志项究竟是什么样子呢？</p>
<p>其实，日志项是一种数据格式，它主要包含用户指定的数据，也就是指令（Command），还包含一些附加信息，比如索引值（Log index）、任期编号（Term）。那你该怎么理解这些信息呢？</p>
<ul>
<li><p>指令：一条由客户端请求指定的、状态机需要执行的指令。你可以将指令理解成客户端指定的数据。</p>
</li>
<li><p>索引值：日志项对应的整数索引值。它其实就是用来标识日志项的，是一个连续的、单调递增的整数号码。</p>
</li>
<li><p>任期编号：创建这条日志项的领导者的任期编号。</p>
</li>
</ul>
<h5 id="如何复制"><a href="#如何复制" class="headerlink" title="如何复制"></a>如何复制</h5><p>你可以把 Raft 的日志复制理解成一个优化后的二阶段提交（将二阶段优化成了一阶段），减少了一半的往返消息，也就是降低了一半的消息延迟。那日志复制的具体过程是什么呢？</p>
<p>首先，领导者进入第一阶段，通过日志复制（AppendEntries）RPC 消息，将日志项复制到集群其他节点上。</p>
<p>接着，如果领导者接收到大多数的“复制成功”响应后，它将日志项提交到它的状态机，并返回成功给客户端。如果领导者没有接收到大多数的“复制成功”响应，那么就返回错误给客户端。</p>
<p>学到这里，有同学可能有这样的疑问了，领导者将日志项提交到它的状态机，怎么没通知跟随者提交日志项呢？</p>
<p>这是 Raft 中的一个优化，领导者不直接发送消息通知其他节点提交指定日志项。因为领导者的日志复制 RPC 消息或心跳消息，包含了当前最大的，将会被提交的日志项索引值。所以通过日志复制 RPC 消息或心跳消息，跟随者就可以知道领导者的日志提交位置信息。</p>
<p>因此，当其他节点接受领导者的心跳消息，或者新的日志复制 RPC 消息后，就会将这条日志项提交到它的状态机。而这个优化，降低了处理客户端请求的延迟，将二阶段提交优化为了一段提交，降低了一半的消息延迟。</p>
<ol>
<li>接收到客户端请求后，领导者基于客户端请求中的指令，创建一个新日志项，并附加到本地日志中。</li>
<li>领导者通过日志复制 RPC，将新的日志项复制到其他的服务器。</li>
<li>当领导者将日志项，成功复制到大多数的服务器上的时候，领导者会将这条日志项提交到它的状态机中。</li>
<li>领导者将执行的结果返回给客户端。</li>
<li>当跟随者接收到心跳信息，或者新的日志复制 RPC 消息后，如果跟随者发现领导者已经提交了某条日志项，而它还没提交，那么跟随者就将这条日志项提交到本地的状态机中。</li>
</ol>
<h5 id="如何实现日志的一致"><a href="#如何实现日志的一致" class="headerlink" title="如何实现日志的一致"></a>如何实现日志的一致</h5><p>在 Raft 算法中，领导者通过强制跟随者直接复制自己的日志项，处理不一致日志。也就是说，Raft 是通过以领导者的日志为准，来实现各节点日志的一致的。具体有 2 个步骤。</p>
<ol>
<li>首先，领导者通过日志复制 RPC 的一致性检查，找到跟随者节点上，与自己相同日志项的最大索引值。也就是说，这个索引值之前的日志，领导者和跟随者是一致的，之后的日志是不一致的了。</li>
<li>然后，领导者强制跟随者更新覆盖的不一致日志项，实现日志的一致。</li>
</ol>
<h4 id="如何解决成员变更"><a href="#如何解决成员变更" class="headerlink" title="如何解决成员变更"></a>如何解决成员变更</h4><p>因为 Raft 的领导者选举，建立在“大多数”的基础之上，那么当成员变更时，集群成员发生了变化，就可能同时存在新旧配置的 2 个“大多数”，出现 2 个领导者，破坏了 Raft 集群的领导者唯一性，影响了集群的运行。</p>
<p>而关于成员变更，不仅是 Raft 算法中比较难理解的一部分，非常重要，也是 Raft 算法中唯一被优化和改进的部分。比如，最初实现成员变更的是联合共识（Joint Consensus），但这个方法实现起来难，后来 Raft 的作者就提出了一种改进后的方法，单节点变更（single-server changes）。</p>
<p>在我看来，在集群中进行成员变更的最大风险是，可能会同时出现 2 个领导者。比如在进行成员变更时，节点 A、B 和 C 之间发生了分区错误，节点 A、B 组成旧配置中的“大多数”，也就是变更前的 3 节点集群中的“大多数”，那么这时的领导者（节点 A）依旧是领导者。</p>
<h5 id="如何通过单节点变更解决成员变更的问题？"><a href="#如何通过单节点变更解决成员变更的问题？" class="headerlink" title="如何通过单节点变更解决成员变更的问题？"></a>如何通过单节点变更解决成员变更的问题？</h5><p>单节点变更，就是通过一次变更一个节点实现成员变更。如果需要变更多个节点，那你需要执行多次单节点变更。比如将 3 节点集群扩容为 5 节点集群，这时你需要执行 2 次单节点变更，先将 3 节点集群变更为 4 节点集群，然后再将 4 节点集群变更为 5 节点集群</p>
<p>目前的集群配置为[A, B, C]，我们先向集群中加入节点 D，这意味着新配置为[A, B, C, D]。成员变更，是通过这么两步实现的：</p>
<ol>
<li>领导者（节点 A）向新节点（节点 D）同步数据；</li>
<li>领导者（节点 A）将新配置[A, B, C, D]作为一个日志项，复制到新配置中所有节点（节点 A、B、C、D）上，然后将新配置的日志项提交到本地状态机，完成单节点变更。</li>
</ol>
<p>管旧的集群配置是怎么组成的，旧配置的“大多数”和新配置的“大多数”都会有一个节点是重叠的。 也就是说，不会同时存在旧配置和新配置 2 个“大多数”</p>
<p>不管集群是偶数节点，还是奇数节点，不管是增加节点，还是移除节点，新旧配置的“大多数”都会存在重叠</p>
<p>在分区错误、节点故障等情况下，如果我们并发执行单节点变更，那么就可能出现一次单节点变更尚未完成，新的单节点变更又在执行，导致集群出现 2 个领导者的情况。如果你遇到这种情况，可以在领导者启动时，创建一个 NO_OP 日志项（也就是空日志项），只有当领导者将 NO_OP 日志项提交后，再执行成员变更请求。</p>
<p>有很多同学把 Raft 当成一致性算法，其实 Raft 不是一致性算法而是共识算法，是一个 Multi-Paxos 算法，实现的是如何就一系列值达成共识。并且，Raft 能容忍少数节点的故障。虽然 Raft 算法能实现强一致性，也就是线性一致性（Linearizability），但需要客户端协议的配合。在实际场景中，我们一般需要根据场景特点，在一致性强度和实现复杂度之间进行权衡。比如 Consul 实现了三种一致性模型。</p>
<ol>
<li>default：客户端访问领导者节点执行读操作，领导者确认自己处于稳定状态时（在 leader leasing 时间内），返回本地数据给客户端，否则返回错误给客户端。在这种情况下，客户端是可能读到旧数据的，比如此时发生了网络分区错误，新领导者已经更新过数据，但因为网络故障，旧领导者未更新数据也未退位，仍处于稳定状态。</li>
<li>consistent：客户端访问领导者节点执行读操作，领导者在和大多数节点确认自己仍是领导者之后返回本地数据给客户端，否则返回错误给客户端。在这种情况下，客户端读到的都是最新数据。</li>
<li>stale：从任意节点读数据，不局限于领导者节点，客户端可能会读到旧数据。</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h5><p>生产流程：</p>
<p>1）生产者将生产消息的请求发往Leader的Raft模块。</p>
<p>2）Raft模块完成Entry的创建和同步。</p>
<p>3）大多数节点上持久化并返回成功后Entry标记为Committed。</p>
<p>4）所有节点的State Machine应用该日志，取出实际的生产请求，将消息内容写入磁盘，更新ApplyIndex。该步骤不需要刷盘。</p>
<p>5）Leader回复客户端Confirm，通知生产成功。</p>
<p>6）如果此后机器重启，通过raft日志恢复生产消息，保证了已Confirm的消息不丢失。</p>
<p>消费流程：</p>
<p>1）消费者从Leader节点拉取消息。</p>
<p>2）Leader收到后从磁盘加载未删除的消息投递给客户端。</p>
<p>3）客户端处理完成后Ack消息，通知服务器删除消息。</p>
<p>4）Ack请求经Raft同步后标记为Committed。</p>
<p>5）各节点状态机应用该日志，将消息对应的bit置位，将其设置为已删除并更新ApplyIndex。</p>
<p>6）通知客户端删除成功。</p>
<p>7）如果机器重启，通过Raft日志恢复Ack请求，保证了已删除的消息不会再投递。</p>
<p>##PoW</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2020/03/11/tree-structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/tree-structure/" itemprop="url">【面试系列】- 常用树结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-11T17:58:48+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h2 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>AVL树是一棵二叉搜索树。1</p>
</li>
<li><p>AVL树的左右子节点也是AVL树。</p>
</li>
<li><p>AVL树拥有二叉搜索树的所有基本特点。</p>
</li>
<li><p>每个节点的左右子节点的高度之差的绝对值最多为1，即平衡因子为范围为[-1,1]。</p>
</li>
<li><p>AVL是严格自平衡的二叉树，即所有节点的左右子树高度差不超过1</p>
</li>
<li><p>因为有个旋转比较耗时，所以AVL适合插入和删除次数较少，但查找比较多的情况</p>
</li>
</ul>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><h5 id="LL（右旋）"><a href="#LL（右旋）" class="headerlink" title="LL（右旋）"></a>LL（右旋）</h5><ol>
<li>将失衡节点的左子树的右子树 变成 失衡节点的左子树</li>
<li>失衡节点 变成 失衡节点未发生操作前左子树的右子树</li>
</ol>
<h5 id="RR（左旋）"><a href="#RR（左旋）" class="headerlink" title="RR（左旋）"></a>RR（左旋）</h5><ol>
<li>将失衡节点的右子树的左子树 变成失衡节点的右子树</li>
<li>失衡节点 变成 失衡节点未发生操作前右子树的左子树</li>
</ol>
<h5 id="LR（旋转）"><a href="#LR（旋转）" class="headerlink" title="LR（旋转）"></a>LR（旋转）</h5><ol>
<li>对失衡节点的左子树进行RR型旋转</li>
<li>对失衡节点进行LL型旋转</li>
</ol>
<h5 id="RL-旋转"><a href="#RL-旋转" class="headerlink" title="RL(旋转)"></a>RL(旋转)</h5><ol>
<li>对失衡节点的右子树进行LL型旋转</li>
<li>对失衡节点进行RR型旋转</li>
</ol>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><ol>
<li>待删除结点至少一棵子树为空，则直接用另一棵子树替代当前结点的位置即可（两侧都为空则置为空）。此种情况下不会引起当前结点处的失衡，其祖先结点的平衡可能受影响。</li>
<li>待删除结点两棵子树均不为空。此时从高度较大的一棵子树处寻找替代结点（左侧最大或右侧最小）替代当前结点的位置，然后从该子树中删除替代结点（即再调用删除方法。因为替代结点为最大/最小结点，必有一子树为空，所以这个调用会成为第一种情况的删除）。此种情况亦不会引起当前结点处的失衡（因为是从高度大的子树中删除一个结点）。</li>
</ol>
<p>故无论如何，删除结点处不会失衡。我们在删除方法中递归寻找待删除的结点，然后回溯处理平衡。<br>删除结点引起的失衡基本可以看成从另一侧子树中插入一个结点的情况，其具有<code>LL</code>, <code>LR</code>, <code>RL</code>, <code>RR</code>四种类型，可以直接用上述已经分析过的旋转处理。不过删除时还会出现<code>LE</code>, <code>RE</code>两种失衡类型，即为当前结点左子树（或右子树）偏高，但是左子树（或右子树）的两棵子树平衡。<br>尝试一下，不难发现，对于<code>LE</code>型失衡，用<code>LL</code>或<code>LR</code>型的处理方法，都能让其恢复平衡，<code>RE</code>同理。所以这里不需要进行特殊讨论处理。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，<strong>红黑树确保没有一条路径会比其它路径长出两倍</strong>，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。</p>
<p>树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>每个节点非红即黑</li>
<li>根节点是黑的;</li>
<li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;</li>
<li>如图所示，如果一个节点是红的，那么它的两儿子都是黑的;</li>
<li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;</li>
<li>每条路径都包含相同的黑节点;</li>
<li>当某条路径最短时，这条路径必然都是由黑色节点构成。当某条路径长度最长时，这条路径必然是由红色和黑色节点相间构成</li>
</ol>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>红黑树的插入过程和二叉查找树插入过程基本类似，不同的地方在于，红黑树插入新节点后，需要进行调整，以满足红黑树的性质。性质1规定红黑树节点的颜色要么是红色要么是黑色，那么在插入新节点时，这个节点应该是红色还是黑色呢？答案是<strong>红色</strong>，原因也不难理解。如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。</p>
<p>接下来，将分析插入红色节点后红黑树的情况。这里假设要插入的节点为 N，N 的父节点为 P，祖父节点为 G，叔叔节点为 U。插入红色节点后，会出现5种情况，分别如下：</p>
<h5 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h5><p>插入的新节点 N 是红黑树的根节点，这种情况下，我们把节点 N 的颜色由红色变为黑色，性质2（根是黑色）被满足。同时 N 被染成黑色后，红黑树所有路径上的黑色节点数量增加一个，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍然被满足。</p>
<p><img src="https://segmentfault.com/img/remote/1460000015590868?w=1308&h=88" alt="img"></p>
<h5 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h5><p>N 的父节点是黑色，这种情况下，性质4（每个红色节点必须有两个黑色的子节点）和性质5没有受到影响，不需要调整。</p>
<p><img src="https://segmentfault.com/img/remote/1460000015590869?w=1304&h=138" alt="img"></p>
<h5 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h5><p>N 的父节点是红色（节点 P 为红色，其父节点必然为黑色），叔叔节点 U 也是红色。由于 P 和 N 均为红色，所有性质4被打破，此时需要进行调整。这种情况下，先将 P 和 U 的颜色染成黑色，再将 G 的颜色染成红色。此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。但需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。</p>
<p><img src="https://segmentfault.com/img/remote/1460000015590870?w=1304&h=230" alt="img"></p>
<h5 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h5><p>N 的父节点为红色，叔叔节点为黑色。节点 N 是 P 的右孩子，且节点 P 是 G 的左孩子。此时先对节点 P 进行左旋，调整 N 与 P 的位置。接下来按照情况五进行处理，以恢复性质4。</p>
<p><img src="https://segmentfault.com/img/remote/1460000015590871?w=1302&h=224" alt="img"></p>
<p>这里需要特别说明一下，上图中的节点 N 并非是新插入的节点。当 P 为红色时，P 有两个孩子节点，且孩子节点均为黑色，这样从 G 出发到各叶子节点路径上的黑色节点数量才能保持一致。既然 P 已经有两个孩子了，所以 N 不是新插入的节点。情况四是由以 N 为根节点的子树中插入了新节点，经过调整后，导致 N 被变为红色，进而导致了情况四的出现。考虑下面这种情况（PR 节点就是上图的 N 节点）：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015590872?w=1308&h=234" alt="img"></p>
<p>如上图，插入节点 N 并按情况三处理。此时 PR 被染成了红色，与 P 节点形成了连续的红色节点，这个时候就需按情况四再次进行调整。</p>
<h5 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h5><p>N 的父节点为红色，叔叔节点为黑色。N 是 P 的左孩子，且节点 P 是 G 的左孩子。此时对 G 进行右旋，调整 P 和 G 的位置，并互换颜色。经过这样的调整后，性质4被恢复，同时也未破坏性质5。</p>
<p><img src="https://segmentfault.com/img/remote/1460000012728526?w=1308&h=234" alt="img"></p>
<h5 id="插入总结"><a href="#插入总结" class="headerlink" title="插入总结"></a>插入总结</h5><p>上面五种情况中，情况一和情况二比较简单，情况三、四、五稍复杂。但如果细心观察，会发现这三种情况的区别在于叔叔节点的颜色，如果叔叔节点为红色，直接变色即可。如果叔叔节点为黑色，则需要选选择，再交换颜色。当把这三种情况的图画在一起就区别就比较容易观察了，如下图：</p>
<p><img src="https://segmentfault.com/img/remote/1460000012725117?w=1312&h=768" alt="img"></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>相较于插入操作，红黑树的删除操作则要更为复杂一些。删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（该节点右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。我们并不关心最终被删除的节点是否是我们开始想要删除的那个节点，只要节点里的值最终被删除就行了，至于树结构如何变化，这个并不重要。</p>
<p>红黑树删除操作的复杂度在于删除节点的颜色，当删除的节点是红色时，直接拿其孩子节点补空位即可。因为删除红色节点，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍能够被满足。当删除的节点是黑色时，那么所有经过该节点的路径上的黑节点数量少了一个，破坏了性质5。如果该节点的孩子为红色，直接拿孩子节点替换被删除的节点，并将孩子节点染成黑色，即可恢复性质5。但如果孩子节点为黑色，处理起来就要复杂的多。分为6种情况，下面会展开说明。</p>
<p>在展开说明之前，我们先做一些假设，方便说明。这里假设最终被删除的节点为<code>X</code>（至多只有一个孩子节点），其孩子节点为<code>N</code>，<code>X</code>的兄弟节点为<code>S</code>，<code>S</code>的左节点为 SL，右节点为 SR。接下来讨论是建立在节点 <code>X</code> 被删除，节点 <code>N</code> 替换<code>X</code>的基础上进行的。这里说明把被删除的节点<code>X</code>特地拎出来说一下的原因是防止大家误以为节点<code>N</code>会被删除，不然后面就会看不明白。</p>
<h5 id="情况一-1"><a href="#情况一-1" class="headerlink" title="情况一"></a>情况一</h5><p>N 是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。</p>
<p>要删除的节点 X 是根节点，且左右孩子节点均为空节点，此时将节点 X 用空节点替换完成删除操作。</p>
<h5 id="情况二-1"><a href="#情况二-1" class="headerlink" title="情况二"></a>情况二</h5><p>S 为红色，其他节点为黑色。这种情况下可以对 N 的父节点进行左旋操作，然后互换 P 与 S 颜色。但这并未结束，经过节点 P 和 N 的路径删除前有3个黑色节点（<code>P -&gt; X -&gt; N</code>），现在只剩两个了（<code>P -&gt; N</code>）。比未经过 N 的路径少一个黑色节点，性质5仍不满足，还需要继续调整。不过此时可以按照情况四、五、六进行调整。</p>
<p><img src="https://segmentfault.com/img/remote/1460000012728528?w=1310&h=218" alt="img"></p>
<h5 id="情况三-1"><a href="#情况三-1" class="headerlink" title="情况三"></a>情况三</h5><p>N 的父节点，兄弟节点 S 和 S 的孩子节点均为黑色。这种情况下可以简单的把 S 染成红色，所有经过 S 的路径比之前少了一个黑色节点，这样经过 N 的路径和经过 S 的路径黑色节点数量一致了。但经过 P 的路径比不经过 P 的路径少一个黑色节点，此时需要从情况一开始对 P 进行平衡处理。</p>
<p><img src="https://segmentfault.com/img/remote/1460000012728529?w=1306&h=210" alt="img"></p>
<h5 id="情况四-1"><a href="#情况四-1" class="headerlink" title="情况四"></a>情况四</h5><p>N 的父节点是红色，S 和 S 孩子为黑色。这种情况比较简单，我们只需交换 P 和 S 颜色即可。这样所有通过 N 的路径上增加了一个黑色节点，所有通过 S 的节点的路径必然也通过 P 节点，由于 P 与 S 只是互换颜色，并不影响这些路径。</p>
<p><img src="https://segmentfault.com/img/remote/1460000012916620?w=1302&h=224" alt="img"></p>
<p>这里需要特别说明一下，上图中的节点 N 并非是新插入的节点。当 P 为红色时，P 有两个孩子节点，且孩子节点均为黑色，这样从 G 出发到各叶子节点路径上的黑色节点数量才能保持一致。既然 P 已经有两个孩子了，所以 N 不是新插入的节点。情况四是由以 N 为根节点的子树中插入了新节点，经过调整后，导致 N 被变为红色，进而导致了情况四的出现。考虑下面这种情况（PR 节点就是上图的 N 节点）：</p>
<p><img src="https://segmentfault.com/img/remote/1460000012916621?w=1342&h=314" alt="img"></p>
<h5 id="情况五-1"><a href="#情况五-1" class="headerlink" title="情况五"></a>情况五</h5><p>S 为黑色，S 的左孩子为红色，右孩子为黑色。N 的父节点颜色可红可黑，且 N 是 P 左孩子。这种情况下对 S 进行右旋操作，并互换 S 和 SL 的颜色。此时，所有路径上的黑色数量仍然相等，N 兄弟节点的由 S 变为了 SL，而 SL 的右孩子变为红色。接下来我们到情况六继续分析。</p>
<p><img src="https://segmentfault.com/img/remote/1460000015590878?w=1306&h=260" alt="img"></p>
<h5 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h5><p>S 为黑色，S 的右孩子为红色。N 的父节点颜色可红可黑，且 N 是其父节点左孩子。这种情况下，我们对 P 进行左旋操作，并互换 P 和 S 的颜色，并将 SR 变为黑色。因为 P 变为黑色，所以经过 N 的路径多了一个黑色节点，经过 N 的路径上的黑色节点与删除前的数量一致。对于不经过 N 的路径，则有以下两种情况：</p>
<ol>
<li>该路径经过 N 新的兄弟节点 SL ，那它之前必然经过 S 和 P。而 S 和 P 现在只是交换颜色，对于经过 SL 的路径不影响。</li>
<li>该路径经过 N 新的叔叔节点 SR，那它之前必然经过 P、 S 和 SR，而现在它只经过 S 和 SR。在对 P 进行左旋，并与 S 换色后，经过 SR 的路径少了一个黑色节点，性质5被打破。另外，由于 S 的颜色可红可黑，如果 S 是红色的话，会与 SR 形成连续的红色节点，打破性质4（每个红色节点必须有两个黑色的子节点）。此时仅需将 SR 由红色变为黑色即可同时恢复性质4和性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。）。</li>
<li><img src="https://segmentfault.com/img/remote/1460000015590879?w=1308&h=214" alt="img"></li>
</ol>
<h5 id="删除总结"><a href="#删除总结" class="headerlink" title="删除总结"></a>删除总结</h5><p>红黑树删除的情况比较多，大家刚开始看的时候可能会比较晕。可能会产生这样的疑问，为啥红黑树会有这种删除情况，为啥又会有另一种情况，它们之间有什么联系和区别？和大家一样，我刚开始看的时候也有这样的困惑，直到我把所有情况对应的图形画在一起时，拨云见日，一切都明了了。此时天空中出现了4个字，原来如此、原来如此、原来如此。所以，请看图吧：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015590880?w=1308&h=1278" alt="img"></p>
<p>虽然删除情况较多，但是实际上总的可以分为两种情况，SL,SR全为黑和SL,SR至少有一个为红。</p>
<p>SL,SR 全为黑，分为三种情况，P红S红不存在，不符合红黑树定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) N黑，P黑，S红，通过处理变为3),4),5)</span><br><span class="line">2) N黑，P黑，S黑，通过将S变为红，将P设置给N，递归向上进行处理</span><br><span class="line">3) N黑，P红，S黑，交换P和S的颜色，满足红黑树，处理完毕</span><br></pre></td></tr></table></figure>

<p>2 SL红，SR黑，此时S必为黑，P无所谓颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经过处理，以S为中心进行右旋，变为5)</span><br></pre></td></tr></table></figure>

<p>SL无所谓颜色，SR红，此时S必为黑，P无所谓颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P的颜色给S，SR变为黑，然后以P为中心进行左旋，红黑树处理完毕</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol>
<li><p>广泛用于C ++的STL中，地图和集都是用红黑树实现的;</p>
</li>
<li><p>着名的Linux的的进程调度完全公平调度程序，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一颗红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间;</p>
</li>
<li><p>IO多路复用的epoll的的的实现采用红黑树组织管理的的的sockfd，以支持快速的增删改查;</p>
</li>
</ol>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构</p>
<p>数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p>
<p>每个节点最多有m-1个<strong>关键字</strong>（可以存有的键值对）。</p>
<p>根节点最少可以只有1个<strong>关键字</strong>。</p>
<p>非根节点至少有m/2个<strong>关键字</strong>。</p>
<p>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</p>
<p>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</p>
<p>每个节点都存有索引和数据，也就是对应的key和value。</p>
<p>所以，根节点的<strong>关键字</strong>数量范围：<code>1 &lt;= k &lt;= m-1</code>，非根节点的<strong>关键字</strong>数量范围：<code>m/2 &lt;= k &lt;= m-1</code>。</p>
<p>另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。</p>
<p>我们再举个例子来说明一下上面的概念，比如这里有一个5阶的B树，根节点数量范围：1 &lt;= k &lt;= 4，非根节点数量范围：2 &lt;= k &lt;= 4。</p>
<p>下面，我们通过一个插入的例子，讲解一下B树的插入过程，接着，再讲解一下删除关键字的过程。</p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>插入的时候，我们需要记住一个规则：<strong>判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。</strong></p>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。</p>
<p>1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步</p>
<p>2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。</p>
<p>3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。</p>
<p>否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。</p>
<p>有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>关键字个数比孩子结点个数小1，这种方式是和B树基本等价的。上图就是一颗阶数为4的B+树。</p>
<p>除此之外B+树还有以下的要求。</p>
<p>1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。</p>
<p>2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</p>
<p>3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。</p>
<p>4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都<strong>小于</strong>它，右子树中的key都<strong>大于等于</strong>它。叶子结点中的记录也按照key的大小排列。</p>
<p>5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</p>
<h2 id="B树-和-B-树的区别"><a href="#B树-和-B-树的区别" class="headerlink" title="B树 和 B+树的区别"></a>B树 和 B+树的区别</h2><ol>
<li><p>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</p>
</li>
<li><p>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</p>
</li>
</ol>
<p>B+树的优点：</p>
<ol>
<li><p>非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</p>
</li>
<li><p>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</p>
</li>
</ol>
<p>B树的优点：</p>
<p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。与树状数组不同的是，线段树不止可以适用于区间求和的查询，也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询。</p>
<p>线段树是用一个<strong>完全二叉树</strong>来存储对应于其每一个区间（segment）的数据。该二叉树的每一个结点中保存着相对应于这一个区间的信息。同时，线段树所使用的这个二叉树是用一个数组保存的，与堆（Heap）的实现方式相同。</p>
<p><strong>区间快速的修改，查询</strong>，当区间的左端点与右端点相等时，即单点的修改与查询，也适用于线段树。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2019/12/22/design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/22/design-pattern/" itemprop="url">【面试系列】 - design pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-22T18:13:13+08:00">
                2019-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><h4 id="懒汉版"><a href="#懒汉版" class="headerlink" title="懒汉版"></a>懒汉版</h4><p>单例实例在第一次被使用时才进行初始化，这叫做延迟初始化。</p>
<ol>
<li>私有化它的构造函数，以防止外界创建单例类的对象；</li>
<li>使用类的私有静态指针变量指向类的唯一实例；</li>
<li>使用一个公有的静态方法获取该实例。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version 1.2</span></span><br><span class="line"><span class="comment">// Meyer's Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singleton() &#123; &#125;;</span><br><span class="line">	~Singleton() &#123; &#125;;</span><br><span class="line">	Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">		<span class="keyword">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="饿汉版"><a href="#饿汉版" class="headerlink" title="饿汉版"></a>饿汉版</h4><p>饿汉版（Eager Singleton）：指单例实例在程序运行时被立即执行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Singleton();</span><br><span class="line">	~Singleton();</span><br><span class="line">	Singleton(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize defaultly</span></span><br><span class="line">Singleton Singleton::instance;</span><br></pre></td></tr></table></figure>

<p>由于在main函数之前初始化，所以没有线程安全的问题。但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。也即，static Singleton instance;和static Singleton&amp; getInstance()二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>饿汉版 虽然是线程安全的，但存在潜在问题；</li>
<li>懒汉版通常需要加锁来保证线程安全，但局部静态变量版本在C++11后是线程安全的；</li>
<li>局部静态变量版本（Meyers Singleton）最优雅。</li>
</ul>
<p>在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生<strong>内存泄露</strong>问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。</p>
<p>而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductA()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> :</span> <span class="keyword">public</span> AbstractProductA &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductA2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductB()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> :</span> <span class="keyword">public</span> AbstractProductB &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ProductB2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA* <span class="title">CreateProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB* <span class="title">CreateProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractFactory()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA1* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB1* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> :</span> <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA2* <span class="title">CreateProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB2* <span class="title">CreateProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory* af1 = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">    <span class="comment">// 具体工厂创建对应的具体产品</span></span><br><span class="line">    AbstractProductA* apa1 = af1-&gt;CreateProductA();  <span class="comment">// 工厂1创建产品A</span></span><br><span class="line">    apa1-&gt;Operation();  <span class="comment">// ProductA1</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb1 = af1-&gt;CreateProductB();  <span class="comment">// 工厂1创建产品B</span></span><br><span class="line">    apb1-&gt;Operation();  <span class="comment">// ProductB1</span></span><br><span class="line"></span><br><span class="line">    AbstractFactory* af2 = <span class="keyword">new</span> ConcreteFactory2();</span><br><span class="line">    AbstractProductA* apa2 = af2-&gt;CreateProductA();  <span class="comment">// 工厂2创建产品A</span></span><br><span class="line">    apa2-&gt;Operation();  <span class="comment">// ProductA2</span></span><br><span class="line"></span><br><span class="line">    AbstractProductB* apb2 = af2-&gt;CreateProductB();  <span class="comment">// 工厂2创建产品B</span></span><br><span class="line">    apb2-&gt;Operation();  <span class="comment">// ProductB2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> apa1;</span><br><span class="line">    <span class="keyword">delete</span> apa2;</span><br><span class="line">    <span class="keyword">delete</span> af1;</span><br><span class="line">    <span class="keyword">delete</span> apb1;</span><br><span class="line">    <span class="keyword">delete</span> apb2;</span><br><span class="line">    <span class="keyword">delete</span> af2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>易于交换产品系列，由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这样就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置。</p>
<p>让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>增加新的产品时需要改动多处代码。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式顾名思义在于接口的转换，最形象的例子就如两口转三口电源适配器，口子的数量可以理解为参数数量，一如我们调用三个参数的接口，而提供的接口只有两个参数，那么久需要适配器类进行接口的扩展改造，这就是适配器模式存在的最主要意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//目标接口类，客户需要的接口</span><br><span class="line">class Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Target()&#123;&#125;</span><br><span class="line">  virtual ~Target()&#123;&#125;</span><br><span class="line">  virtual void Request()//定义新的标准接口</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Request&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//需要适配的类</span><br><span class="line">class Object</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Object()&#123;&#125;</span><br><span class="line">  ~Object()&#123;&#125;</span><br><span class="line">  void SpecificRequest()</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; &quot;SpecificRequest&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//类模式，适配器类，通过public继承获得接口继承的效果，通过private继承获得实现继承的效果</span><br><span class="line">class Adapter :public Target, private Object</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Adapter()&#123;&#125;</span><br><span class="line">  ~Adapter()&#123;&#125;</span><br><span class="line">  virtual void Request()//实现Target定义的Request接口</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; &quot;AdapterRequest&quot; &lt;&lt; endl;</span><br><span class="line">    this-&gt;SpecificRequest();</span><br><span class="line">    cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//对象模式，适配器类，继承Target类，采用组合的方式实现Object的复用</span><br><span class="line">class Adapter1 :public Target</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  Adapter1(Object* adaptee) :_adaptee(adaptee)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  Adapter1() :_adaptee(new Object)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  ~Adapter1()&#123;&#125;</span><br><span class="line">  virtual void Request()//实现Target定义的Request接口</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Adapter1Request&quot; &lt;&lt; endl;</span><br><span class="line">    _adaptee-&gt;SpecificRequest();</span><br><span class="line">    cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  Object* _adaptee;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//client调用</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  //类模式Adapter</span><br><span class="line">  Target* pTarget = new Adapter();</span><br><span class="line">  pTarget-&gt;Request();</span><br><span class="line"> </span><br><span class="line">  //对象模式Adapter1</span><br><span class="line">  Adaptee* ade = new Adaptee();</span><br><span class="line">  Target* pTarget1= new Adapter1(ade);</span><br><span class="line">  pTarget1-&gt;Request();</span><br><span class="line"> </span><br><span class="line">  //对象模式Adapter2</span><br><span class="line">  Target* pTarget2 = new Adapter1();</span><br><span class="line">  pTarget2-&gt;Request();</span><br><span class="line"> </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式属于先天模式，这里的先天模式就是说一开始就要把结构搭建好，方便后来的扩展，而不是对已经出现的模块和接口进行改进扩展的。桥接的核心在于实体类和操作类之间的聚合关系，这个聚合关系就是我们所说的”桥”,不同于装饰、代理和适配器模式的中的聚合关系，桥接不存在两者之间的继承关系，操作类是完全解耦的，而实体类对于操作类也只是弱耦合。</p>
<p>将抽象部份与它的实现部份分离，使它们都可以独立地变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//操作类</span><br><span class="line">class action</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual void do()=0;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class write : public action</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">   void do()&#123; count &lt;&lt; &quot;to write\n&quot;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class draw : public action</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  void do() &#123; count &lt;&lt; &quot;to draw\n&quot;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class gift : public action</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  void do &#123;count &lt;&lt; &quot;to gift\n&quot;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//实体类</span><br><span class="line">class pen</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  pen(): m_pAction(NULL)&#123;&#125;</span><br><span class="line">  virtual ~pen()&#123; delete m_pAction;&#125;</span><br><span class="line">  virtual void use();</span><br><span class="line">  void setaction(action* pAction)&#123;m_pAction = pAction;&#125;</span><br><span class="line">protected:</span><br><span class="line">  action* m_pAction;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class pencil : public pen</span><br><span class="line">&#123;</span><br><span class="line">  void use()</span><br><span class="line">  &#123; </span><br><span class="line">    cout &lt;&lt; &quot;use pencil &quot;;</span><br><span class="line">    m_pAction.do(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class brush : public pen</span><br><span class="line">&#123;</span><br><span class="line">  void use()</span><br><span class="line">  &#123; </span><br><span class="line">    cout &lt;&lt; &quot;use brush &quot;;</span><br><span class="line">    m_pAction.do(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class goldenpen : public pen</span><br><span class="line">&#123;</span><br><span class="line">  void use()</span><br><span class="line">  &#123; </span><br><span class="line">    cout &lt;&lt; &quot;use goldenpen &quot;;</span><br><span class="line">    m_pAction.do(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main</span><br><span class="line">&#123;</span><br><span class="line">  ballpen inHand;</span><br><span class="line">  inHand.setaction(new gift());</span><br><span class="line">  inHand.use();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式通常的叫法叫做订阅-发布模式，类似于报刊杂志的订阅，观察者和被观察者就是读者和邮局的关系，读者先要在邮局订阅想要的报刊，当报刊发行时，邮局会将报刊邮寄到读者家里。观察者（Observer）和被观察者（Listener）也是这种关系，Observer将自己attach到Listener中，当Listener触发时Notify所有Observer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">class Observer </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~Observer() &#123;&#125;;</span><br><span class="line">  virtual void Update(const std::string &amp;msg)= 0; </span><br><span class="line">protected:</span><br><span class="line">  Observer()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Listener</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~Listener() &#123;&#125;;</span><br><span class="line">  void attach(Observer* obsvr) </span><br><span class="line">  &#123;</span><br><span class="line">    m_observers.push_back(obsvr);</span><br><span class="line">  &#125;</span><br><span class="line">  void remove(Observer* obsvr)</span><br><span class="line">  &#123;</span><br><span class="line">    m_observers.remove(obsvr);</span><br><span class="line">  &#125;</span><br><span class="line">  void notify(const std::string &amp;msg)</span><br><span class="line">  &#123;</span><br><span class="line">    list&lt;Observer*&gt;::iterator iter = m_observers.begin(); </span><br><span class="line">    for(; iter != m_observers.end(); iter++) </span><br><span class="line">      (*iter)-&gt;Update(msg); </span><br><span class="line">  &#125;</span><br><span class="line">private: </span><br><span class="line">  list&lt;Observer* &gt; m_observers; //观察者链表 </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class logRunner : public Listener</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~logRunner()&#123;&#125;;</span><br><span class="line">  void addmsg(const std::string &amp;msg)</span><br><span class="line">  &#123;</span><br><span class="line">    nofity(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class logGui : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~Observer()&#123;&#125;;</span><br><span class="line">  void Update(const std::string &amp;msg)</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt; &quot;Gui log show : &quot;&lt;&lt; msg &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class logFile : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~Observer()&#123;&#125;;</span><br><span class="line">  void Update(const std::string &amp;msg)</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt; &quot;file log write : &quot;&lt;&lt; msg &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class logDebug : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~Observer()&#123;&#125;;</span><br><span class="line">  void Update(const std::string &amp;msg)</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt; &quot;Debug log out : &quot;&lt;&lt; msg &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class logDataBase : public Observer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  virtual ~Observer()&#123;&#125;;</span><br><span class="line">  void Update(const std::string &amp;msg)</span><br><span class="line">  &#123;</span><br><span class="line">    cout&lt;&lt; &quot;DataBase log in : &quot;&lt;&lt; msg &lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  logRunner Runner;</span><br><span class="line">  logGui gGui;</span><br><span class="line">  logFile gFile;</span><br><span class="line">  logDebug gDebug;</span><br><span class="line">  logDataBase gDataBase;</span><br><span class="line">   </span><br><span class="line">  Runner.attach(&amp;gGui);</span><br><span class="line">  Runner.attach(&amp;gFile);</span><br><span class="line">  Runner.attach(&amp;gDebug);</span><br><span class="line">  Runner.attach(&amp;gDataBase);</span><br><span class="line">   </span><br><span class="line">  Runner.addmsg(&quot;app is setup&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observer中update一般为纯虚，通过子类各自实现，这里只是保证调用的接口一致，Listener中的attach、remove、notify一般建议不进行虚化，子类不用关心其内部的聚合内容，通过调用notify实现消息分发即可。当然也可以虚化，将这一系列的操作放到子类进行实现。</p>
<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><ul>
<li>SRP，Single Responsibility Principle(单一职责原则)</li>
<li>LSP，Liskov Substitution Principle(里氏替换原则)</li>
<li>DIP，Dependence Inversion Principle(依赖倒置原则)</li>
<li>ISP，Interface Segregation Principle(接口隔离原则)</li>
<li>LoD，Law of Demeter(迪米特法则)</li>
<li>OCP，Open Close Principle(开放封闭原则)</li>
</ul>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p>
<p>View 传送指令到 Controller ；</p>
<p>Controller 完成业务逻辑后，要求 Model 改变状态 ；</p>
<p>Model 将新的数据发送到 View，用户得到反馈。</p>
<p>MVC流程：</p>
<p>MVC流程一共有两种，在日常开发中都会使用到。</p>
<p>一种是通过 View 接受指令，传递给 Controller，然后对模型进行修改或者查找底层数据，最后把改动渲染在视图上。</p>
<p>另一种是通过controller接受指令，传给Controller：</p>
<p>MVC优点：</p>
<p>耦合性低，视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码。<br>重用性高<br>生命周期成本低<br>MVC使开发和维护用户接口的技术含量降低<br>可维护性高，分离视图层和业务逻辑层也使得WEB应用更易于维护和修改<br>部署快<br>MVC缺点：</p>
<p>不适合小型，中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。</p>
<p>视图与控制器间过于紧密连接，视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</p>
<p>视图对模型数据的低效率访问，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP（Model-View-Presenter）是MVC的改良模式，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller/Presenter负责业务逻辑，Model管理数据，View负责显示只不过是将 Controller 改名为 Presenter，同时改变了通信方向。<br>MVP特点：</p>
<p>M、V、P之间双向通信。<br>View 与 Model 不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。<br>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。<br>Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。</p>
<ul>
<li>在<strong>MVP</strong>中，View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部。</li>
<li>在<strong>MVC</strong>中，View会直接从Model中读取数据而不是通过 Controller。</li>
</ul>
<p>MVP优点：</p>
<p>模型与视图完全分离，我们可以修改视图而不影响模型；<br>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；<br>我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；<br>如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。<br>MVP缺点：</p>
<p>视图和Presenter的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，presenter也要变更。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM是Model-View-ViewModel的简写。微软的WPF(Windows Presentation Foundation–微软推出的基于Windows 的用户界面框架)带来了新的技术体验, 使得软件UI层更加细节化、可定制化。与此同时，在技术层面，WPF也带来了 诸如Binding（绑定）、Dependency Property（依赖属性）、Routed Events（路由事件）、Command（命令）、DataTemplate（数据模板）、ControlTemplate（控制模板）等新特性。MVVM模式其实是MV模式与WPF结合的应用方式时发展演变过来的一种新型架构模式。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。</p>
<p>MVVM模式和MVC模式类似，主要目的是分离视图（View）和模型（Model），有几大优点：</p>
<p>低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</p>
<p>可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2019/12/22/os-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/22/os-interview/" itemprop="url">【面试系列】- 操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-22T17:41:40+08:00">
                2019-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>计算机可以被细分为4大块</p>
<ul>
<li>Processor</li>
<li>Main Memory</li>
<li>I/O Modules</li>
<li>System Bus（系统总线）</li>
</ul>
<h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>主要负责控制计算机进行动作，处理数据，即就是CPU。</p>
<p>CPU内部分为：</p>
<ul>
<li>Control Unit</li>
<li>Arithmetic &amp; Logic Unit</li>
</ul>
<p>处理器执行命令的顺序为：</p>
<ol>
<li>从内存里取出命令</li>
<li>decode instruction into commands（Control Unit）</li>
<li>执行命令（ALU）</li>
<li>把结果存进内存</li>
</ol>
<h4 id="Main-Memory"><a href="#Main-Memory" class="headerlink" title="Main Memory"></a>Main Memory</h4><p>被称作primary memory, main memory 或者 RAM</p>
<p>里面包含一系列的地址，地址被连续的一串数字计数</p>
<p>用于储存数据和程序，有volatile的属性</p>
<h4 id="I-O-Modules"><a href="#I-O-Modules" class="headerlink" title="I/O Modules"></a>I/O Modules</h4><p>负责把数据在电脑和外部环境中做交换，外部环境包括：</p>
<ul>
<li>硬盘</li>
<li>输入输出设备</li>
<li>终端</li>
</ul>
<h4 id="System-Bus（系统总线）"><a href="#System-Bus（系统总线）" class="headerlink" title="System Bus（系统总线）"></a>System Bus（系统总线）</h4><p>为处理器，内存，I/O单元间提供通信</p>
<h4 id="寄存器-Register"><a href="#寄存器-Register" class="headerlink" title="寄存器 Register"></a>寄存器 Register</h4><p>是特殊的在CPU内部的内存位置，可以被非常快的访问</p>
<h4 id="Memory-Hierarchy（由小到大）"><a href="#Memory-Hierarchy（由小到大）" class="headerlink" title="Memory Hierarchy（由小到大）"></a>Memory Hierarchy（由小到大）</h4><ol>
<li>Register</li>
<li>Cache (介于CPU和RAM之间，用于拷贝常用数据加速访问，可以有多层Cache，egL1 cache, L3 cache)</li>
<li>Main Memory</li>
<li>Hard drive</li>
</ol>
<h4 id="操作系统Overview"><a href="#操作系统Overview" class="headerlink" title="操作系统Overview"></a>操作系统Overview</h4><ul>
<li>操作系统是一个控制应用执行的程序</li>
<li>操作系统是应用和硬件之间的界面</li>
<li>操作系统负责管理资源</li>
</ul>
<h2 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2. 进程与线程"></a>2. 进程与线程</h2><p>####Overview</p>
<p>进程有两大特性：</p>
<ul>
<li>资源所有权（Resource Ownership）：一个进程可能被分配一些资源的所有权，包括虚拟地址空间来保存进程图像（Process Image）<ul>
<li>进程图像指的是进程执行的上下文环境，包括处理器中各个通用寄存器的值，进程的内存图像，打开文件的状态和进程占用的资源的信息，由：</li>
<li>进程控制块（PCB）</li>
<li>程序</li>
<li>数据集合</li>
<li>栈</li>
<li>四个部分组成</li>
</ul>
</li>
<li>Dispatching/Scheduling/execution：沿着一条执行路径，其中可能被其他进程插入</li>
</ul>
<p>这两大特性被OS独立对待：</p>
<ul>
<li>分发单元被称为线程（thread）</li>
<li>资源所有权被称为进程或者任务（task）</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p>
<p>多线程指的是OS支持按多条并行的路径在一个进程中执行多条线程</p>
<p>![image-20200302160716409](/Users/ziliugao2/Library/Application Support/typora-user-images/image-20200302160716409.png)</p>
<p>在OS中，一个进程是：</p>
<ul>
<li>一个资源分配单元：一个保存有进程图像的虚拟内存空间</li>
<li>一个被保护的单元：被保护的处理器access权限，其他进程沟通权限，文件权限，I/O资源</li>
</ul>
<p>在一个进程中，每个线程有：</p>
<ul>
<li>一个执行状态（running, ready, etc.）</li>
<li>一个在没运行时被保存的线程上下文</li>
<li>一个执行栈</li>
<li>一些per-thread的static storage for local variable</li>
<li>访问拥有他的进程拥有的内存和资源的权限</li>
</ul>
<h6 id="一个CPU工作时间段的解读"><a href="#一个CPU工作时间段的解读" class="headerlink" title="一个CPU工作时间段的解读"></a>一个CPU工作时间段的解读</h6><p>在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文（PCB），调入下一个要执行的程序B的程序上下文（PCB），然后开始执行B,保存程序B的上下文。<br><strong>进程和线程就是这样的背景出来的</strong>，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。</p>
<p><strong>进程就是包换上下文切换的程序执行时间总和</strong> = <strong>CPU加载上下文+CPU执行+CPU保存上下文</strong></p>
<p>程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p>
<p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这<strong>里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</strong></p>
<p>作者：zhonyong<br>链接：<a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384/answer/81152571</a><br>来源：知乎</p>
<p>并发<br>最早的计算机，每次只能执行一个程序，只有当当前执行的程序结束后才能执行其它程序，在此期间，别的程序都得等着。到后来，计算机运行速度提高了，程序员们发现，单任务运行一旦陷入IO阻塞状态，CPU就没事做了，很是浪费资源，于是就想要同一时间执行那么三五个程序，几个程序一块跑，于是就有了并发。原理就是将CPU时间分片，分别用来运行多个程序，可以看成是多个独立的逻辑流，由于能快速切换逻辑流，看起来就像是大家一块跑的。</p>
<p>并发解决了两个问题：<br>提高了CPU的利用率，在某个程序陷入IO或者其它等待状态时，CPU可以转而执行其它程序。<br>表面上看起来多个程序一起运行，解决了跑程序排队等待的问题。<br>引入的新问题：<br>并发执行也存在一些问题。我的程序运行到一半，别的进程突然插进来，抢占了CPU，我的中间状态怎么办，我用来存储的内存被覆盖了怎么办？所以跑在一个CPU里面的并发都需要处理上下文切换的问题。进程就是这样抽象出来了一个概念，搭配虚拟内存、进程表之类的东西，用来管理独立运行的程序运行、切换。因为程序的使用涉及到大量的计算机资源配置， 把这活随意的交给用户程序，容易让整个系统被搞挂，资源分配也很难做到相对的公平。所以就出现了操作系统，核心的操作需要陷入内核(kernel)，切换到操作系统，让内核来做。</p>
<p>上下文切换<br>上下文切换最早是指进程的上下文切换(context switch)，它发生在内核态。内核调度器会对每个CPU上执行的进程进行调度(scheduling)，以保证每个进程都能分到CPU时间片。当一个进程的时间片用完，或被中断后，内核将保存该进程的运行状态(即上下文)，将其存入运行队列(run queue)，同时让新的进程占用CPU。进程的上下文切换包括内存地址空间、内核态堆栈和硬件上下文(CPU寄存器)的切换，所以代价很高。</p>
<p>线程<br>有的时候碰着I/O访问，阻塞了后面所有的计算。空着也是空着，内核就直接把CPU切换到其他进程，让人家先用着。当然除了I\O阻塞，还有时钟阻塞等等。一开始大家都这样弄，后来发现太慢了，一切换进程得反复进入内核，置换掉一大堆状态。进程数一高，大部分系统资源就被进程切换给吃掉了。由于进程切换开销大，所以设计了线程。 大致意思就是，这个地方阻塞了，但我还有其他地方的逻辑流可以计算，这些逻辑流是共享一个地址空间的，不用特别麻烦的重新加载地址空间，页表缓冲区，只要把寄存器刷新一遍就行，能比切换进程开销少点。Linux 2.6内核的clone()系统调用已经支持创建内核级线程，且发布了内核线程库pthread。在同一进程内的线程可以共享进程的地址空间，线程仅需要维护自己的寄存器、栈和线程相关的变量。不过内核线程的调度仍然需要由内核完成，这需要进行用户态和内核态的模式切换，至少包括堆栈和内存映射的切换。而且，不同进程之间的线程切换，有可能会还会导致进程切换，所以代价还是不小。<br>————————————————<br>版权声明：本文为CSDN博主「OshynSong」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u010487568/article/details/56841031" target="_blank" rel="noopener">https://blog.csdn.net/u010487568/article/details/56841031</a></p>
<hr>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<strong>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p>
<p>简而言之：</p>
<ol>
<li><strong>一个程序至少有一个进程,一个进程至少有一个线程.</strong></li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<strong>但是线程不能够独立执行，</strong>必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ol>
<p>总结：</p>
<ol>
<li>线程在进程下行进</li>
<li><strong>一个程序至少有一个进程,一个进程至少有一个线程.</strong></li>
<li>不同进程间数据很难共享，统一进程下不同线程间数据很容易共享</li>
<li>进程要比线程消耗更多的计算机资源</li>
<li>进程有独立的地址空间，同一个进程中的不同线程没有</li>
<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</li>
<li>进程可以拓展到多机，进程更偏向适合多核</li>
<li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>进程使用的内存地址可以限定使用量</li>
</ol>
<hr>
<h4 id="进程与线程的优劣势"><a href="#进程与线程的优劣势" class="headerlink" title="进程与线程的优劣势"></a>进程与线程的优劣势</h4><p>进程对资源的管理和保护很好，但执行和切换的开销很大</p>
<p>线程对资源的管理和保护不利，但执行和切换开销很小</p>
<hr>
<h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><h5 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h5><p>进程调度的实质是资源的分配，如何使系统能够保持较短的响应时间和较高的吞吐量，如何在多个可运行的进程中选取一个最值得运行的进程投入运行是调度器的主要任务。进程调度包括两个方面的内容：何时分配CPU 时间（调度时机）即调度器什么时候启动；如何选择进程（调度算法）即调度器该怎么做。进程调度主要可以分为非剥夺方式与剥夺方式两种。</p>
<p>非剥夺方式：调度程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。 </p>
<p>剥夺方式：当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。</p>
<p>Linux 从整体上区分实时进程和普通进程，因为实时进程和普通进程度调度是不同的，它们两者之间，实时进程应该先于普通进程而运行，然后，对于同一类型的不同进程，采用不同的标准来选择进程。对普通进程的调度策略是动态优先调度，对于实时进程采用了两种调度策略，FIFO(先来先服务调度)和RR（时间片轮转调度）。</p>
<p>UNIX系统是单纯的分时系统，所以没有设置作业调度。UNIX系统的进程调度采用的算法是，多级反馈队列调度法。其核心思想是先从最高休先级就绪队列中取出排在队列最前面的进程，当进程执行完一个时间片仍未完成则剥夺它的执行，将它放入到相应的队列中，取出下一个就绪进程投入运行，对于同一个队列中的各个进程，按照时间片轮转法调度。多级反馈队列调度算法即能使高优先级的作业得到响应又能使短作业（进程）迅速完成。但是它还是存在某些方面的不足，当不断有新进程到来时，则长进程可能饥饿。</p>
<p>Windows 系统其调度方式比较复杂，它的处理器调度的调度单位是线程而不是进程，是基于优先级的抢占式多处理器调度，依据优先级和分配时间片来调度。而且Windows 2000/XP在单处理器系统和多处理器系统中的线程调度是不同的线程调度机制，Windows操作系统的调度系统总是运行优先级最高的就绪线程。在同一优先级的各线程按时间片轮转算法进行调度。如果一个高优先级的线程进入就绪状态，当前运行的线程可能在用完它的时间片之前就被抢占处理机。</p>
<p>我们通常用 带权周转时间 $\bar{W} = T / R$ 来衡量一个算法的优劣势，其中T是从开始到该任务运行完的时间，R是实际运行时间。</p>
<h6 id="FCFS（先来先服务）和短作业优先（SJF）算法"><a href="#FCFS（先来先服务）和短作业优先（SJF）算法" class="headerlink" title="FCFS（先来先服务）和短作业优先（SJF）算法"></a>FCFS（先来先服务）和短作业优先（SJF）算法</h6><p>FCFS 有利于长进程，不利于短进程。因此FCFS调度算法有利于CPU繁忙型的作业，而不利于I/O繁忙型的作业(进程)</p>
<p>SJF调度算法能相对FCFS算法有效地降低作业的平均等待时间，提高系统吞吐量。但SJF也有不容忽视的缺点。</p>
<ol>
<li>该算法对长作业不利</li>
<li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li>
<li>由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li>
</ol>
<h6 id="时间片轮转RR进程调度算法"><a href="#时间片轮转RR进程调度算法" class="headerlink" title="时间片轮转RR进程调度算法"></a>时间片轮转RR进程调度算法</h6><ul>
<li>基本原理</li>
</ul>
<p>用于分时系统中的进程调度。每次调度时，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片。一个时间片内没有完成运行的进程，返回到绪队列末尾重新排队，等待下一次调度。</p>
<ul>
<li>时间片大小的确定</li>
</ul>
<p>在时间片轮转算法中，时间片的大小对系统性能有很大的影响，如选择很小的时间片将有利于短作业，因为它能较快地完成，但会频繁地发生中断、进程上下文的切换，从而增加系统的开销；反之，如选择太长的时间片，使得每个进程都能在一个时间片内完成，时间片轮转算法便退化为FCFS算法，无法满足交互式用户的需求。一个较为可取的大小是，时间片略大于一次典型的交互所需要的时间。这样可使大多数进程在一个时间片内完成。</p>
<h6 id="预防死锁的银行家算法"><a href="#预防死锁的银行家算法" class="headerlink" title="预防死锁的银行家算法"></a>预防死锁的银行家算法</h6><ul>
<li>银行家算法的数据结构</li>
</ul>
<ol>
<li>可利用资源向量Available。这是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果Available[j]=K，则表示系统中现有Rj类资源K个。</li>
<li>最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。</li>
<li>分配矩阵Allocation。这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的数目为K。</li>
<li>需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要R j类资源K个，方能完成其任务。</li>
<li>Need[i, j] = Max[i, j] - Allocation[i, j]</li>
</ol>
<ul>
<li>银行家算法流程</li>
</ul>
<p>设Request i是进程Pi的请求向量，如果Request i[j]=K，表示进程P i需要K个R j类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：</p>
<ol>
<li>如果Request i[j]≤Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</li>
<li>如果Requesti[j]≤Available[j]，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</li>
<li>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值<ol>
<li>Available[j]:= Available[j]-Requesti[j]；</li>
<li>Allocation[i,j]:= Allocation[i,j]+Requesti[j]；</li>
<li>Need[i,j]:= Need[i,j]-Request i[j]；</li>
</ol>
</li>
<li>统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">P - 进程的集合</span><br><span class="line"></span><br><span class="line">Mp - 进程p的最大的请求数目</span><br><span class="line"></span><br><span class="line">Cp - 进程p当前被分配的资源</span><br><span class="line"></span><br><span class="line">A - 当前可用的资源</span><br><span class="line"></span><br><span class="line">while (P != ∅) &#123;</span><br><span class="line">    found = FALSE;</span><br><span class="line">    foreach (p ∈ P) &#123;</span><br><span class="line">        if (Mp − Cp ≤ A) &#123;</span><br><span class="line">             /* p可以獲得他所需的資源。假設他得到資源後執行；執行終止，並釋放所擁有的資源。*/</span><br><span class="line">             A = A + Cp ;</span><br><span class="line">             P = P − &#123;p&#125;;</span><br><span class="line">             found = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (! found) return FAIL;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="串行（Sequentiallism）并行（Parallellism）与-并发（Concurrency）"><a href="#串行（Sequentiallism）并行（Parallellism）与-并发（Concurrency）" class="headerlink" title="串行（Sequentiallism）并行（Parallellism）与 并发（Concurrency）"></a>串行（Sequentiallism）并行（Parallellism）与 并发（Concurrency）</h4><p><em>CSAPP 的观点</em></p>
<p>串行即 按照顺序执行任务。</p>
<p>并行指同一时间两（多）个进程运行在不同的机器上或者同一个机器的不同处理器上，是并发的真子集</p>
<p>并发是说说进程B开始的开始时间是在进程A的开始时间和结束时间之间，我们就说A和B是并发的。</p>
<p>二者有相关度，但并非同一个概念：<strong>并发可认为是一种逻辑结构的设计模式</strong>。你可以用并发的设计方式去设计模型，然后运行在一个单核系统上，通过系统动态地逻辑切换制造出并行的假象。此时，你的程序不是并行，但是是并发的。你可以将这种模型不加修改地运行在多核系统上，此时你的程序可以认为是并行。此处，并行更关注的是程序的执行（execution）</p>
<p>作者：晒太阳的猫<br>链接：<a href="https://www.zhihu.com/question/33515481/answer/135306366" target="_blank" rel="noopener">https://www.zhihu.com/question/33515481/answer/135306366</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>利用线程编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。</p>
<ul>
<li>并行</li>
</ul>
<p>多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。</p>
<p><img src="https://img-blog.csdn.net/20180711145302288?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tpc3NjYXRmb3JldmVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li>并发</li>
</ul>
<p>多个线程同时竞争一个位置，竞争到的才可以执行，每一个时间段只有一个线程在执行。</p>
<p>我们更多遇到的是并发的问题，也就是常说的高并发。要保证每一个时刻只有一个线程运行，并保证数据的一致性。</p>
<hr>
<h4 id="线程同步与通信"><a href="#线程同步与通信" class="headerlink" title="线程同步与通信"></a>线程同步与通信</h4><p>Linux 下 线程同步（通信）的方法有：</p>
<ul>
<li>互斥锁（mutex）</li>
<li>条件变量（condition variable）</li>
<li>信号量（Semaphore）</li>
<li>临界区（Critical Section）</li>
<li>自旋锁（Spinlock）</li>
<li>读写锁（readers-writer lock）</li>
<li>屏障（Memory barrier）</li>
</ul>
<h6 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h6><p>互斥锁，是一种信号量，常用来防止两个进程或线程在同一时刻访问相同的共享资源，可以保证一下三点：</p>
<ol>
<li>原子性：把一个互斥量锁定为一个原子操作，这意味着操作系统（或pthread函数库）保证了如果一个线程锁定了一个互斥量，没有其他线程在同一时间可以成功锁定这个互斥量。</li>
<li>唯一性：如果一个线程锁定了一个互斥量，在它解除锁定之前，没有其他线程可以锁定这个互斥量。</li>
<li>非繁忙等待：如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。</li>
</ol>
<ul>
<li>直接lock() / unlock()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> g_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  g_mutex.lock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = ++g_count;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面代码如有异常，unlock 就调不到了。</span></span><br><span class="line">  g_mutex.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一组线程。</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; v;</span><br><span class="line">  v.reserve(SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    v.emplace_back(&amp;Counter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有线程结束。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用lock_guard自动加锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex g_mutex;</span><br><span class="line"><span class="keyword">int</span> g_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lock_guard 在构造函数里加锁，在析构函数里解锁。</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(g_mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = ++g_count;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"count: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; v;</span><br><span class="line">  v.reserve(SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    v.emplace_back(&amp;Counter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用unique_lock自动加锁，解锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line">int g_count = 0;</span><br><span class="line"></span><br><span class="line">void Counter() &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lock(g_mutex);</span><br><span class="line"></span><br><span class="line">  int i = ++g_count;</span><br><span class="line">  std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  const std::size_t SIZE = 4;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::thread&gt; v;</span><br><span class="line">  v.reserve(SIZE);</span><br><span class="line"></span><br><span class="line">  for (std::size_t i = 0; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    v.emplace_back(&amp;Counter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (std::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为输出流使用的单独的mutex</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::mutex g_mutex;</span><br><span class="line">std::mutex g_io_mutex;</span><br><span class="line">int g_count = 0;</span><br><span class="line"></span><br><span class="line">void Counter() &#123;</span><br><span class="line">  int i;</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock(g_mutex);</span><br><span class="line">    i = ++g_count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock(g_io_mutex);</span><br><span class="line">    std::cout &lt;&lt; &quot;count: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  const std::size_t SIZE = 4;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::thread&gt; v;</span><br><span class="line">  v.reserve(SIZE);</span><br><span class="line"></span><br><span class="line">  for (std::size_t i = 0; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    v.emplace_back(&amp;Counter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (std::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h6><p>条件变量（Condition Variable）的一般用法是：线程 A 等待某个条件并挂起，直到线程 B 设置了这个条件，并通知条件变量，然后线程 A 被唤醒。经典的「生产者-消费者」问题就可以用条件变量来解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;  <span class="comment">// 条件</span></span><br><span class="line"><span class="keyword">bool</span> processed = <span class="literal">false</span>;  <span class="comment">// 条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待主线程发送数据。</span></span><br><span class="line">  cv.wait(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待后，继续拥有锁。</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"工作线程正在处理数据..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 睡眠一秒以模拟数据处理。</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  data += <span class="string">" 已处理"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数据发回主线程。</span></span><br><span class="line">  processed = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"工作线程通知数据已经处理完毕。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知前，手动解锁以防正在等待的线程被唤醒后又立即被阻塞。</span></span><br><span class="line">  lock.unlock();</span><br><span class="line"></span><br><span class="line">  cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">worker</span><span class="params">(Worker)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数据发送给工作线程。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程正在准备数据..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 睡眠一秒以模拟数据准备。</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    data = <span class="string">"样本数据"</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程通知数据已经准备完毕。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cv.notify_one();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待工作线程处理数据。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">    cv.wait(lock, [] &#123; <span class="keyword">return</span> processed; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"回到主线程，数据 = "</span> &lt;&lt; data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  worker.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与条件变量搭配使用的「锁」，必须是 <code>unique_lock</code>，不能用 <code>lock_guard</code>。这个前面文章中已有说明。等待前先加锁。等待时，如果条件不满足，<code>wait</code> 会原子性地解锁并把线程挂起。</p>
<p>######信号量（Semaphore） </p>
<p>信号量是一个计数器，计算能同时（concurrently）access 一份共享的资源。他提供两个原子操作：</p>
<ol>
<li>wait: –count; 如果count &lt; 0 就挂起线程。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。</li>
<li>signal ++count；如果count&lt;=0 就唤醒一个执行线程。在信号量上执行加一操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。</li>
</ol>
<p>信号量和互斥锁的主要区别是 mutex是二分互斥，信号量则是数量有n个，在都占完的情况下，阻塞当前进程。</p>
<p>若信号量S的初值是2，当前值为-3，则表示有-3个进程在S上等待。</p>
<p>但C++11 和 Boosting 都不提供 信号量的实现，因为他们认为信号量是容易导致错误的，可以用条件变量和mutex组合实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    semaphore(<span class="keyword">int</span> value = <span class="number">1</span>) :count(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lck(mtk);</span><br><span class="line">        <span class="keyword">if</span> (--count &lt; <span class="number">0</span>)<span class="comment">//资源不足挂起线程</span></span><br><span class="line">            cv.wait(lck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lck(mtk);</span><br><span class="line">        <span class="keyword">if</span> (++count &lt;= <span class="number">0</span>)<span class="comment">//有线程挂起，唤醒一个</span></span><br><span class="line">            cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    mutex mtk;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>吃水果问题：</strong>桌子有一只盘子，只允许放一个水果，父亲专向盘子放苹果，母亲专向盘子放桔子 儿子专等吃盘子的桔子，女儿专等吃盘子的苹果。只要盘子为空，父亲或母亲就可以向盘子放水果， 仅当盘子有自己需要的水果时，儿子和女儿可从盘子取出。请给出四个人之间的同步关系，并用 pv操作实现四个人的正确活动的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">semaphore plate(1), apple(0), orange(0);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">father</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        plate.wait();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"往盘中放一个苹果"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        apple.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mother</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        plate.wait();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"往盘中放一个橘子"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        orange.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">son</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        apple.wait();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"儿子吃苹果"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        plate.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daughter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        orange.wait();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"女儿吃橘子"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        plate.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread f(father), m(mother), s(son), d(daughter);</span><br><span class="line">    f.join();</span><br><span class="line">    m.join();</span><br><span class="line">    s.join();</span><br><span class="line">    d.join();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="临界区（Critical-Section）"><a href="#临界区（Critical-Section）" class="headerlink" title="临界区（Critical Section）"></a>临界区（Critical Section）</h6><p> 保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线 程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。<br>临界区包含两个操作原语： EnterCriticalSection（） 进入临界区 LeaveCriticalSection（） 离开临界区 EnterCriticalSection（）语句执行后代码将进入临界区以后无论发生什么，必须确保与之匹配的 LeaveCriticalSection（）都能够被执行到。否则临界区保护的共享资源将永远不会被释放。虽然临界区同步速度很快，但却只能用来同步本 进程内的线程，而不可用来同步多个进程中的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CRITICAL_SECTION&amp; cs;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CLock(CRITICAL_SECTION&amp; lock):cs(lock)&#123;</span><br><span class="line">        EnterCriticalSection(&amp;cs);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~CLock() &#123;</span><br><span class="line">        LeaveCriticalSection(&amp;cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Process</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CRITICAL_SECTION cs;</span><br><span class="line">    <span class="comment">/* other data */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Process()&#123;</span><br><span class="line">        InitializeCriticalSection(&amp;cs);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Process() &#123;DeleteCriticalSection(&amp;cs);&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">data_process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">CLock <span class="title">lock</span><span class="params">(cs)</span></span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(<span class="comment">/* error happens */</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h6><p>自旋锁是一种基础的同步原语，用于保障对共享数据的互斥访问。与互斥锁的相比，在获取锁失败的时候不会使得线程阻塞而是一直自旋尝试获取锁。当线程等待自旋锁的时候，CPU不能做其他事情，而是一直处于轮询忙等的状态。自旋锁主要适用于被持有时间短，线程不希望在重新调度上花过多时间的情况。实际上许多其他类型的锁在底层使用了自旋锁实现，例如多数互斥锁在试图获取锁的时候会先自旋一小段时间，然后才会休眠。如果在持锁时间很长的场景下使用自旋锁，则会导致CPU在这个线程的时间片用尽之前一直消耗在无意义的忙等上，造成计算资源的浪费。</p>
<p>在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。</p>
<p> 使用任何锁都需要消耗系统资源（内存资源和CPU时间），这种资源消耗可以分为两类：</p>
<p>​    1.建立锁所需要的资源</p>
<p>​    2.当线程被阻塞时所需要的资源</p>
<p>Mutex属于sleep-waiting类型的 锁。例如在一个双核的机器上有两个线程(线程A和线程B)，它们分别运行在Core0和Core1上。假设线程A想要通过 pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞(blocking)，Core0 会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而Spin lock则不然，它属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在 Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。</p>
<p>对于自旋锁来说，它只需要消耗很少的资源来建立锁；随后当线程被阻塞时，它就会一直重复检查看锁是否可用了，也就是说当自旋锁处于等待状态时它会一直消耗CPU时间。</p>
<p>​        对于互斥锁来说，与自旋锁相比它需要消耗大量的系统资源来建立锁；随后当线程被阻塞时，线程的调度状态被修改，并且线程被加入等待线程队列；最后当锁可用 时，在获取锁之前，线程会被从等待队列取出并更改其调度状态；但是在线程被阻塞期间，它不消耗CPU资源。</p>
<p>​        因此自旋锁和互斥锁适用于不同的场景。自旋锁适用于那些仅需要阻塞很短时间的场景，而互斥锁适用于那些可能会阻塞很长时间的场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//CAS</span><br><span class="line">std::atomic::compare_exchange_weak( T&amp; expected, T desired,</span><br><span class="line">                                    std::memory_order order =</span><br><span class="line">                                    std::memory_order_seq_cst ),</span><br><span class="line">                                    </span><br><span class="line">std::atomic::compare_exchange_strong( T&amp; expected, T desired,</span><br><span class="line">                                    std::memory_order order =</span><br><span class="line">                                    std::memory_order_seq_cst )</span><br><span class="line">//赋值</span><br><span class="line">void store( T desired, std::memory_order order = std::memory_order_seq_cst )</span><br><span class="line"></span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">class SpinLock &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    SpinLock() : flag_(false)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void lock()</span><br><span class="line">    &#123;</span><br><span class="line">        bool expect = false;</span><br><span class="line">        while (!flag_.compare_exchange_weak(expect, true))</span><br><span class="line">        &#123;</span><br><span class="line">            //这里一定要将expect复原，执行失败时expect结果是未定的</span><br><span class="line">            expect = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unlock()</span><br><span class="line">    &#123;</span><br><span class="line">        flag_.store(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::atomic&lt;bool&gt; flag_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果临界区可能包含引起睡眠的代码则不能使用自旋锁，否则可能引起死锁：如果在自旋锁保护的代码中间睡眠，此时发生进程调度，则可能另外一个进程会再次调用spinlock保护的这段代码。而我们 现在知道了即使在获取不到锁的“自旋”状态，也是禁止抢占的，而“自旋”又是动态的，不会再睡眠了，也就是说在这个处理器上不会再有进程调度发生了，那么 死锁自然就发生了。</p>
<ul>
<li>单CPU非抢占内核下：自旋锁会在编译时被忽略（因为单CPU且非抢占模式情况下，不可能发生进程切换，时钟只有一个进程处于临界区（自旋锁实际没什么用了）</li>
<li>单CPU抢占内核下：自选锁仅仅当作一个设置抢占的开关（因为单CPU不可能有并发访问临界区的情况，禁止抢占就可以保证临街区唯一被拥有）</li>
<li>多CPU下：此时才能完全发挥自旋锁的作用，自旋锁在内核中主要用来防止多处理器中并发访问临界区，防止内核抢占造成的竞争。</li>
</ul>
<p>Linux 发生抢占：</p>
<p>用户抢占和内核抢占</p>
<ul>
<li>用户抢占<ul>
<li>从系统调用返回用户空间</li>
<li>从中断处理程序返回用户空间</li>
</ul>
</li>
<li>系统抢占<ul>
<li>当从中断处理程序返回内核空间的时候，且当时内核具有可抢占性</li>
<li>当内核代码再一次具有可抢占性的时候</li>
<li>如果内核中的任务显示的调用schedule() </li>
</ul>
</li>
</ul>
<h6 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h6><p>STL 和 Boost 都提供了 <code>shared_mutex</code> 来解决「读者-写者」问题。<code>shared_mutex</code> 这个名字并不十分贴切，不如 pthread 直呼「读写锁」。</p>
<p>读者优先。读者优先指的是除非有写者在写文件，否则读者不需要等待。</p>
<p>写者优先。写者优先与读者优先相类似。不同之处在于一旦一个写者到来，它应该尽快对文件进行写操作，如果有一个写者在等待，则新到来的读者不允许进行读操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">public:</span><br><span class="line">  Counter() : value_(0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Multiple threads/readers can read the counter&apos;s value at the same time.</span><br><span class="line">  std::size_t Get() const &#123;</span><br><span class="line">    std::shared_lock&lt;std::shared_mutex&gt; lock(mutex_);</span><br><span class="line">    return value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Only one thread/writer can increment/write the counter&apos;s value.</span><br><span class="line">  void Increase() &#123;</span><br><span class="line">    // You can also use lock_guard here.</span><br><span class="line">    std::unique_lock&lt;std::shared_mutex&gt; lock(mutex_);</span><br><span class="line">    value_++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Only one thread/writer can reset/write the counter&apos;s value.</span><br><span class="line">  void Reset() &#123;</span><br><span class="line">    std::unique_lock&lt;std::shared_mutex&gt; lock(mutex_);</span><br><span class="line">    value_ = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  mutable std::shared_mutex mutex_;</span><br><span class="line">  std::size_t value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex g_io_mutex;</span><br><span class="line"></span><br><span class="line">void Worker(Counter&amp; counter) &#123;</span><br><span class="line">  for (int i = 0; i &lt; 3; ++i) &#123;</span><br><span class="line">    counter.Increase();</span><br><span class="line">    std::size_t value = counter.Get();</span><br><span class="line"></span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(g_io_mutex);</span><br><span class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &apos; &apos; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  const std::size_t SIZE = 2;</span><br><span class="line"></span><br><span class="line">  Counter counter;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::thread&gt; v;</span><br><span class="line">  v.reserve(SIZE);</span><br><span class="line"></span><br><span class="line">  v.emplace_back(&amp;Worker, std::ref(counter));</span><br><span class="line">  v.emplace_back(&amp;Worker, std::ref(counter));</span><br><span class="line"></span><br><span class="line">  for (std::thread&amp; t : v) &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shared_mutex</code> 比一般的 <code>mutex</code> 多了函数 <code>lock_shared() / unlock_shared()</code>，允许多个（读者）线程同时加锁、解锁，而 <code>shared_lock</code> 则相当于共享版的 <code>lock_guard</code>。</p>
<p>对 <code>shared_mutex</code> 使用 <code>lock_guard</code> 或 <code>unique_lock</code> 就达到了写者独占的目的。</p>
<p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。</p>
<h6 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h6><p>内存屏障其实就是因为编译器优化和CPU对寄存器和cache的使用，导致对内存的操作不能够及时的反映出来，比如cpu写入后，读出来的值可能是旧的内容。举个例子，对一个变量赋值然后读出它的值这一看似“原子”的操作，因为内存是没有ALU计算单元的，所以内存没有计算的能力。而CPU一般情况下是不直接读写内存的(emmintrin.h应用例外)，所以这一个过程可以看作(编译器优化后)：</p>
<p> <strong>读取内存数据到cache –&gt;  CPU读取cache/寄存器  –&gt;  CPU的计算  –&gt;  将结果写入cache/寄存器  –&gt;  写回数据到内存</strong></p>
<p><strong>最简单的就是锁机制，还有volatile关键字</strong>，可以把可能出现的cache读脏的数据volatile int tmp = 0;这样每次操作都会从内存获取。</p>
<p>现代 CPU中指令的执行次序不一定按顺序执行，没有相关性的指令可以打乱次序执行，以充分利用 CPU的指令流水线，提高执行速度。同时，编译器也会对指令进行优化，例如，调整指令顺序来利用CPU的指令流水线。这些优化方式，大部分时候都工作良好，但是在一些比较复杂的情况可能会出现错误，例如，执行同步代码时就有可能因为优化导致同步原语之后的指令在同步原语前执行。</p>
<p>内存屏障和编译屏障就是用来告诉CPU和编译器停止优化的手段。编译屏障是指使用伪指令“memory”告诉编译器不能把“memory”执行前后的代码混淆在一起，这时“memory”起到了一种优化屏障的作用。内存屏障是在代码中使用一些特殊指令，如ARM中的dmb、dsb和isb指令，x86中的sfence、lfence和mfence指令。CPU遇到这些特殊指令后，要等待前面的指令执行完成才执行后面的指令。这些指令的作用就好像一道屏障把前后指令隔离开了，防止CPU把前后两段指令颠倒执行。</p>
<hr>
<h4 id="进程同步与通信"><a href="#进程同步与通信" class="headerlink" title="进程同步与通信"></a>进程同步与通信</h4><p>######通信的办法</p>
<ul>
<li><strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。（半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。）</li>
<li><strong>命名管道 (FIFO)</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。(原理一定要清楚，常考)</li>
<li><strong>信号量</strong>：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据，有XSI信号量和POSIX信号量，POSIX信号量更加完善。</li>
<li><strong>信号 ( sinal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。</li>
<li><strong>套接字( socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li><strong>共享文件映射mmap</strong><br>mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。</li>
</ul>
<h6 id="同步的办法"><a href="#同步的办法" class="headerlink" title="同步的办法"></a>同步的办法</h6><ul>
<li><p>信号量</p>
</li>
<li><p>管程(monitor)信号量机制的缺点：进程自备<a href="https://baike.baidu.com/item/同步/984802" target="_blank" rel="noopener">同步</a>操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。1974年和1977年，Hore和Hansen提出了管程。</p>
<p>管程特点：管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。</p>
<p>引入管程机制的目的：1、把分散在各进程中的临界区集中起来进行管理；2、防止进程有意或无意的违法同步操作；3、便于用高级语言来书写程序，也便于程序正确性验证。</p>
</li>
<li><p>互斥量</p>
</li>
<li><p>文件锁</p>
</li>
</ul>
<h6 id="四种进程或线程同步互斥的控制方法"><a href="#四种进程或线程同步互斥的控制方法" class="headerlink" title="四种进程或线程同步互斥的控制方法"></a>四种进程或线程同步互斥的控制方法</h6><ol>
<li>临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 </li>
<li>互斥量:为协调共同对一个共享资源的单独访问而设计的。 </li>
<li>信号量:为控制一个具有有限数量用户资源而设计。 </li>
<li>事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</li>
</ol>
<hr>
<h4 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h4><p>协程是一个无优先级的子程序调度组件，允许子程序在特定的地方挂起恢复。</p>
<p>线程包含于进程，协程包含于线程。只要内存足够，一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</p>
<p><strong>异步</strong> 指令执行之后，结果并不立即显现的操作称为异步操作。及其指令执行完成并不代表操作完成。</p>
<p>为了进一步减小内核态线程上下文切换的开销，于是又有了用户态线程设计，即纤程(Fiber)。如果连时钟阻塞、 线程切换这些功能我们都不需要了，自己在进程里面写一个逻辑流调度的东西。那么我们即可以利用到并发优势，又可以避免反复系统调用，还有进程切换造成的开销，分分钟给你上几千个逻辑流不费力。这就是用户态线程。</p>
<p>从上面可以看到，实现一个用户态线程有两个必须要处理的问题：</p>
<p>碰着阻塞式I\O会导致整个进程被挂起；<br>由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。<br>如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是协程。协程的做法很像早期操作系统的协作式多任务。</p>
<p>协作式多任务：当任务得一个到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU。win3.x就是这个方式。<br>但是，对于操作系统来说，这种做法会让系统不稳定。因为操作系统管理者整个计算机的资源，这个做法容易让系统失去控制（比如用户程序的一个死循环），因此，现在的操作系统都是用的是抢占式多任务。而在一个程序内，使用协作式的方法是可行的，因为自己的程序可以自己控制。 可以这么理解：协程就是在用户程序中实现了协作式任务调度。 这里输入引用文本进程、线程、协程的设计，都是为了并发任务能够更好的利用CPU资源，协程可以作为进程和线程的有力补充。由于我们可以在用户态调度协程任务，所以，我们可以把一组互相依赖的任务设计成协程。这样，当一个协程任务完成之后，可以手动进行任务调度，把自己挂起(yield)，切换到另外一个协程执行。这样，由于我们可以控制程序主动让出资源，很多情况下将不需要对资源加锁。</p>
<p>协程(coroutine)顾名思义就是“协作的例程”（co-operative routines）。跟具有操作系统概念的线程不一样，协程是在用户空间利用程序语言的语法语义就能实现逻辑上类似多任务的编程技巧。实际上协程的概念比线程还要早，按照 Knuth 的说法“子例程是协程的特例”，一个子例程就是一次子函数调用，那么实际上协程就是类函数一样的程序组件，你可以在一个线程里面轻松创建数十万个协程，就像数十万次函数调用一样。只不过子例程只有一个调用入口起始点，返回之后就结束了，而协程入口既可以是起始点，又可以从上一个返回点继续执行，也就是说协程之间可以通过 yield 方式转移执行权，对称（symmetric）、平级地调用对方，而不是像例程那样上下级调用关系。当然 Knuth 的“特例”指的是协程也可以模拟例程那样实现上下级调用关系，这就叫非对称协程（asymmetric coroutines）。</p>
<p>协程的优势：<br>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。<br>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。<br>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。<br>————————————————<br>版权声明：本文为CSDN博主「OshynSong」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u010487568/article/details/56841031" target="_blank" rel="noopener">https://blog.csdn.net/u010487568/article/details/56841031</a></p>
<p><a href="https://blog.csdn.net/u010487568/article/details/56841031" target="_blank" rel="noopener">https://blog.csdn.net/u010487568/article/details/56841031</a></p>
<p>如果连时钟阻塞、 线程切换这些功能我们都不需要了，自己在进程里面写一个逻辑流调度的东西。那么我们即可以利用到并发优势，又可以避免反复系统调用，还有进程切换造成的开销，分分钟给你上几千个逻辑流不费力。这就是<strong>用户态线程</strong>。</p>
<p>从上面可以看到，实现一个用户态线程有两个必须要处理的问题：一是碰着阻塞式I\O会导致整个进程被挂起；二是由于缺乏时钟阻塞，进程需要自己拥有调度线程的能力。如果一种实现使得每个线程需要自己通过调用某个方法，主动交出控制权。那么我们就称这种用户态线程是协作式的，即是<strong>协程</strong>。</p>
<p>作者：阿猫<br>链接：<a href="https://www.zhihu.com/question/20511233/answer/24260355" target="_blank" rel="noopener">https://www.zhihu.com/question/20511233/answer/24260355</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h2 id="2-5-内核级线程和用户级线程"><a href="#2-5-内核级线程和用户级线程" class="headerlink" title="2.5 内核级线程和用户级线程"></a>2.5 内核级线程和用户级线程</h2><h4 id="内核级线程（KLT）"><a href="#内核级线程（KLT）" class="headerlink" title="内核级线程（KLT）"></a>内核级线程（KLT）</h4><ul>
<li>线程管理的所有工作由OS内核来做<ul>
<li>OS提供了一个应用程序设计接口API，供开发者使用KLT；</li>
<li>OS直接调度KLT</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180805211948984?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eTE5OTMxMDE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>内核级线程的特点<ul>
<li>进程中的一个线程被阻塞了， 内核能调度同一进程的其它线程占有处理器运行；</li>
<li>多处理器环境中， 内核能同时调度同一进程中多个线程并行执行；</li>
<li>内核自身也可用多线程技术实现， 能提高操作系统的执行速度和效率</li>
<li>应用程序线程在用户态运行， 线程调度和管理在内核实现， 在同一进程中， 控制权从一个线程传送到另一个线程时<strong>需要模式切换</strong>，系统开销较大；</li>
</ul>
</li>
</ul>
<h4 id="用户级线程（ULT）"><a href="#用户级线程（ULT）" class="headerlink" title="用户级线程（ULT）"></a>用户级线程（ULT）</h4><ul>
<li>用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境；</li>
<li>任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行；</li>
<li><strong>线程管理的所有工作都由应用程序</strong>完成， 内核没有意识到线程的存在；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180805212504825?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eTE5OTMxMDE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>用户级线程的特点<ul>
<li>所有线程管理数据结构均在进程的用户空间中， 线程切换<strong>不需要内核模式</strong>， 能节省模式切换开销和内核的宝贵资源；</li>
<li>允许进程按应用特定需要选择调度算法， 甚至根据应用需求裁剪调度算法；</li>
<li>能运行在任何OS上， 内核在支持ULT方面不需要做任何工作；</li>
<li><strong>不能利用多处理器的优点</strong>， OS调度进程，仅有一个ULT能执行；</li>
<li><strong>一个ULT的阻塞， 将引起整个进程的阻塞；</strong></li>
</ul>
</li>
</ul>
<h4 id="Jacketing技术"><a href="#Jacketing技术" class="headerlink" title="Jacketing技术"></a>Jacketing技术</h4><ul>
<li>把<strong>阻塞式系统调用改造成非阻塞式</strong>的</li>
<li>当线程陷入系统调用时， 执行jacketing程序；</li>
<li>由jacketing 程序来检查资源使用情况， 以决定是否执行进程切换或传递控制权给另一个线程；</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>ULT适用于解决逻辑并行性问题</li>
<li>KLT适合于解决物理并行性问题</li>
</ul>
<h4 id="混合策略"><a href="#混合策略" class="headerlink" title="混合策略"></a>混合策略</h4><ul>
<li>创建是完全在用户空间做的</li>
<li>单应用的多个用户级线程可以映射成一些内核级线程，通过调整内核级数目，可以达到较好的并行效果</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180805213013669?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N4eTE5OTMxMDE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>混合策略的特点<ul>
<li>线程创建完全在用户空间中完成， <strong>线程的调度和同步也在应用程序</strong>中进行；</li>
<li>一个应用中的多个用户级线程<strong>被映射</strong>到一些(小于等于用户级线程数目)内核级线程上；</li>
<li>程序员可以针对特定应用和机器调节内核级线程的数目， 以达到整体最佳结果；</li>
<li>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点， 同时减少它们的缺点</li>
</ul>
</li>
</ul>
<h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h2><h4 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h4><h6 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h6><ul>
<li>缺点<ul>
<li>分区的数量在系统阶段就被定下，限制了系统中活动进程的数量。</li>
<li>不能保证所有进程所需大小是能够被预先得知的。除非在这种情况下，固定分区才是有效的。</li>
</ul>
</li>
</ul>
<h6 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h6><p>动态分区分配是根据进程的实际需要，动态地为之分配内存空间。在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作这样三个问题。</p>
<ul>
<li>分区分配中的数据结构</li>
</ul>
<p>为了实现分区分配，系统中必须配置相应的数据结构，用来描述空闲分区和已分配分区的情况，为分配提供依据。常用的数据结构有以下两种形式：</p>
<ol>
<li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。</li>
<li>空闲分区链：为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。</li>
</ol>
<ul>
<li>分区分配算法</li>
</ul>
<ol>
<li>首次适应算法（First Fit）<ol>
<li>在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；</li>
<li>然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。</li>
<li>若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。</li>
</ol>
</li>
</ol>
<p>首次适应算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这给为以后到达的大作业分配大的内存空间创造了条件。其缺点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是从低址部分开始，这无疑会增加查找可用空闲分区时的开销。</p>
<ol start="2">
<li>循环首次适应算法（Next Fit）</li>
</ol>
<p>该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。<br>  为实现该算法，应设置一起始查寻指针，用于指示下一次起始查寻的空闲分区，并采用循环查找方式，即如果最后一个(链尾)空闲分区的大小仍不能满足要求，则应返回到第一个空闲分区，比较其大小是否满足要求。找到后，应调整起始查寻指针。<br>  该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。 </p>
<ol start="3">
<li>最佳适应算法(Best Fit)</li>
</ol>
<p>所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区，必然是最佳的。<br>  孤立地看，最佳适应算法似乎是最佳的，然而在宏观上却不一定。因为每次分配后所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区。</p>
<ol start="4">
<li>最坏适应算法(Worst Fit)</li>
</ol>
<p>最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高。该算法要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。<br>  但是该算法的缺点也是明显的，它会使存储器中缺乏大的空闲分区。最坏适应算法与前面所述的首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。 </p>
<ol start="5">
<li>快速适应算法（Quick Fit）</li>
</ol>
<p>该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。<br>  空闲分区的分类是根据进程常用的空间大小进行划分，如2 KB、4 KB、8 KB等，对于其它大小的分区，如7 KB这样的空闲区，既可以放在8 KB的链表中，也可以放在一个特殊的空闲区链表中。<br>  该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。<br>  该算法的缺点是在分区归还主存时算法复杂，系统开销较大。<br>  此外，该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存储空间浪费，这是典型的以空间换时间的作法。 </p>
<ul>
<li>如何回收内存</li>
</ul>
<p>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点。此时可能出现以下四种情况之一：</p>
<ol>
<li>回收区与插入点的前一个空闲分区相邻接。此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区的大小，大小为两者之和。</li>
<li>回收分区与插入点的后一空闲分区相邻接。此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。 </li>
<li>回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，使用前分区的表项和首址，取消后分区的表项，大小为三者之和。</li>
<li>回收区不邻接。这时应为回收区单独建立一新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</li>
</ol>
<hr>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p><img src="http://c.biancheng.net/uploads/allimg/181107/2-1Q10G60550B2.gif" alt="程序员眼中的程序"></p>
<p>当编写程序时，程序员认为它是由主程序加上一组方法、过程或函数所构成的。它还可以包括各种<a href="http://c.biancheng.net/data_structure/" target="_blank" rel="noopener">数据结构</a>，例如对象、数组、堆栈、变量等。每个模块或数据元素通过名称来引用。程序员会说“堆栈”、“数学库”和“主程序”等，而并不关心这些元素所在内存的位置，及他不关心堆栈是放在函数 Sqrt() 之前还是之后。</p>
<p>分段就是支持这种用户视图的内存管理方案。逻辑地址空间是由一组段构成。每个段都有名称和长度。地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和段偏移。</p>
<hr>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p><a href="http://c.biancheng.net/view/1265.html" target="_blank" rel="noopener">分段</a>允许进程的物理地址空间是非连续的。分页是提供这种优势的另一种内存管理方案。然而，分页避免了外部碎片和紧缩，而分段不可以。</p>
<p>分页还避免了将不同大小的内存块匹配到交换空间的问题，在分页引入之前采用的内存管理方案都有这个问题。由于比早期方法更加优越，各种形式的分页为大多数操作系统采用，包括大型机的和智能手机的操作系统。实现分页需要操作系统和计算机硬件的协作。</p>
<p>实现分页的基本方法涉及将物理内存分为固定大小的块，称为帧或页帧，而将逻辑内存也分为同样大小的块，称为页或页面。当需要执行一个进程时，它的页从文件系统或备份存储等处，加载到内存的可用帧。备份存储划分为固定大小的块，它与单个内存帧或与多个内存帧（簇）的大小一样。</p>
<hr>
<h4 id="虚拟内存是什么"><a href="#虚拟内存是什么" class="headerlink" title="虚拟内存是什么"></a>虚拟内存是什么</h4><h6 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h6><p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的<a href="https://zh.wikipedia.org/wiki/物理内存" target="_blank" rel="noopener">物理内存</a>（例如<a href="https://zh.wikipedia.org/wiki/隨機存取記憶體" target="_blank" rel="noopener">RAM</a>）的使用也更有效率。</p>
<p>注意：<strong>虚拟内存</strong>不只是“用磁盘空间来扩展物理内存”的意思——这只是扩充<a href="https://zh.wikipedia.org/wiki/記憶體階層" target="_blank" rel="noopener">内存级别</a>以使其包含<a href="https://zh.wikipedia.org/wiki/硬盘驱动器" target="_blank" rel="noopener">硬盘驱动器</a>而已。把内存扩展到磁盘只是使用虚拟内存技术的一个结果，它的作用也可以通过<a href="https://zh.wikipedia.org/wiki/覆盖_(编程)" target="_blank" rel="noopener">覆盖</a>或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现。对虚拟内存的定义是基于对<a href="https://zh.wikipedia.org/wiki/地址空间" target="_blank" rel="noopener">地址空间</a>的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。</p>
<p>CPU太快，但容量小且功能单一，其他 I/O 硬件支持各种花式功能，可是相对于 CPU，它们又太慢。于是它们之间就需要一种润滑剂来作为缓冲，这就是内存大显身手的地方。</p>
<p>而在现代操作系统中，多任务已是标配。多任务并行，大大提升了 CPU 利用率，但却引出了多个进程对内存操作的冲突问题，虚拟内存概念的提出就是为了解决这个问题。</p>
<p><img src="https://zhenbianshu.github.io/images/2018/process_vm.jpg" alt="img"></p>
<p>上图是虚拟内存最简单也是最直观的解释。</p>
<p>操作系统有一块物理内存（中间的部分），有两个进程（实际会更多）P1 和 P2，操作系统偷偷地分别告诉 P1 和 P2，我的整个内存都是你的，随便用，管够。可事实上呢，操作系统只是给它们画了个大饼，这些内存说是都给了 P1 和 P2，实际上只给了它们一个序号而已。只有当 P1 和 P2 真正开始使用这些内存时，系统才开始使用辗转挪移，拼凑出各个块给进程用，P2 以为自己在用 A 内存，实际上已经被系统悄悄重定向到真正的 B 去了，甚至，当 P1 和 P2 共用了 C 内存，他们也不知道。</p>
<p>操作系统的这种欺骗进程的手段，就是虚拟内存。对 P1 和 P2 等进程来说，它们都以为自己占用了整个内存，而自己使用的物理内存的哪段地址，它们并不知道也无需关心。</p>
<h6 id="分页和分表"><a href="#分页和分表" class="headerlink" title="分页和分表"></a>分页和分表</h6><p>虚拟内存是操作系统里的概念，对操作系统来说，虚拟内存就是一张张的对照表，P1 获取 A 内存里的数据时应该去物理内存的 A 地址找，而找 B 内存里的数据应该去物理内存的 C 地址。</p>
<p>我们知道系统里的基本单位都是 Byte 字节，如果将每一个虚拟内存的 Byte 都对应到物理内存的地址，每个条目最少需要 8字节（32位虚拟地址-&gt;32位物理地址），在 4G 内存的情况下，就需要 32GB 的空间来存放对照表，那么这张表就大得真正的物理地址也放不下了，于是操作系统引入了 <code>页（Page）</code>的概念。</p>
<p>在系统启动时，操作系统将整个物理内存以 4K 为单位，划分为各个页。之后进行内存分配时，都以页为单位，那么虚拟内存页对应物理内存页的映射表就大大减小了，4G 内存，只需要 8M 的映射表即可，一些进程没有使用到的虚拟内存，也并不需要保存映射关系，而且Linux 还为大内存设计了多级页表，可以进一页减少了内存消耗。操作系统虚拟内存到物理内存的映射表，就被称为<code>页表</code>。</p>
<h6 id="内存寻址和分配"><a href="#内存寻址和分配" class="headerlink" title="内存寻址和分配"></a>内存寻址和分配</h6><p>我们知道通过虚拟内存机制，每个进程都以为自己占用了全部内存，进程访问内存时，操作系统都会把进程提供的虚拟内存地址转换为物理地址，再去对应的物理地址上获取数据。CPU 中有一种硬件，<code>内存管理单元 MMU（Memory Management Unit）</code>专门用来将翻译虚拟内存地址。CPU 还为页表寻址设置了缓存策略，由于程序的局部性，其缓存命中率能达到 98%。</p>
<p>以上情况是页表内存在虚拟地址到物理地址的映射，而如果进程访问的物理地址还没有被分配，系统则会产生一个<code>缺页中断</code>，在中断处理时，系统切到内核态为进程虚拟地址分配物理地址。</p>
<hr>
<h4 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h4><p>虚拟内存管理最主要的作用是让每个进程有独立的地址空间(进程间的安全)。同时解决了多进程对物理地址的冲突问题。虚拟内存不仅通过内存地址转换解决了多个进程访问内存冲突的问题，还带来更多的益处。</p>
<ul>
<li>进程的内存管理<ul>
<li>内存完整性：由于虚拟内存对进程的”欺骗”，每个进程都认为自己获取的内存是一块连续的地址。我们在编写应用程序时，就不用考虑大块地址的分配，总是认为系统有足够的大块内存即可。</li>
<li>安全：由于进程访问内存时，都要通过页表来寻址，操作系统在页表的各个项目上添加各种访问权限标识位，就可以实现内存的权限控制。</li>
</ul>
</li>
<li>数据共享<ul>
<li>通过虚拟内存更容易实现内存和数据的共享。</li>
<li>在进程加载系统库时，总是先分配一块内存，将磁盘中的库文件加载到这块内存中，在直接使用物理内存时，由于物理内存地址唯一，即使系统发现同一个库在系统内加载了两次，但每个进程指定的加载内存不一样，系统也无能为力。</li>
<li>而在使用虚拟内存时，系统只需要将进程的虚拟内存地址指向库文件所在的物理内存地址即可。如上文图中所示，进程 P1 和 P2 的 B 地址都指向了物理地址 C。</li>
<li>而通过使用虚拟内存使用共享内存也很简单，系统只需要将各个进程的虚拟内存地址指向系统分配的共享内存地址即可。</li>
</ul>
</li>
<li>SWAP<ul>
<li>虚拟内存可以让帮进程”扩充”内存。</li>
<li>我们前文提到了虚拟内存通过缺页中断为进程分配物理内存，内存总是有限的，如果所有的物理内存都被占用了怎么办呢？</li>
<li>Linux 提出 SWAP 的概念，Linux 中可以使用 SWAP 分区，在分配物理内存，但可用内存不足时，将暂时不用的内存数据先放到磁盘上，让有需要的进程先使用，等进程再需要使用这些数据时，再将这些数据加载到内存中，通过这种”交换”技术，Linux 可以让进程使用更多的内存。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Pagein-amp-out"><a href="#Pagein-amp-out" class="headerlink" title="Pagein &amp; out"></a>Pagein &amp; out</h4><p>各进程分配的只不过是虚拟内存的页面，这些页面的数据可以映射到物理页面，也可以临时保存到磁盘上而不占用物理页面，在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备（Swap Device）。当物理内存不够用时，将一些不常用的物理页面中的数据临时保存到交换设备，然后这个物理页面就认为是空闲的了，可以重新分配给进程使用，这个过程称为换出（Pageout）。如果进程要用到被换出的页面，就从交换设备再加载回物理内存，这称为换入（Pagein）。换出和换入操作统称为换页（Paging）</p>
<hr>
<h4 id="物理地址-逻辑地址-物理地址"><a href="#物理地址-逻辑地址-物理地址" class="headerlink" title="物理地址/逻辑地址/物理地址"></a>物理地址/逻辑地址/物理地址</h4><p><strong>物理地址(physical address)</strong>：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。</p>
<p><strong>逻辑地址(logical address)</strong>：是指由程序产生的与段相关的偏移地址部分。例如，你在进行C语言指针<a href="http://www.2cto.com/kf" target="_blank" rel="noopener">编程</a>中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。</p>
<p><strong>虚拟地址(virtual address)</strong>是逻辑地址到物理地址变换之间的中间层。在分段部件中逻辑地址是段中的偏移地址，然后加上基地址就是线性地址。是一个32位无符号整数，可以用来表示高达4GB的地址，也就是，高达4294967296个内存单元。线性地址通常用十六进制数字表示，值得范围从0x00000000到0xfffffff）程序代码会产生逻辑地址，通过逻辑地址变换就可以生成一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换以产生一个物理地址。如果没有启用分页机制，那么线性地址直接就是物理地址。</p>
<hr>
<h4 id="操作系统层面对内存的管理"><a href="#操作系统层面对内存的管理" class="headerlink" title="操作系统层面对内存的管理"></a>操作系统层面对内存的管理</h4><ul>
<li>内存抽象<ul>
<li>动态内存分区</li>
</ul>
</li>
<li>虚拟内存<ul>
<li>虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为页(Page).每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)，还有一些没加载在内存中的对应在硬盘上</li>
</ul>
</li>
<li>页面替换算法（Pagein and Pageout）<ul>
<li><strong>最佳置换算法(Optimal Page Replacement Algorithm)</strong></li>
<li><strong>最近不常使用算法(Not Recently Used Replacement Algorithm)</strong></li>
<li><strong>先进先出页面置换算法(First-In,First-Out Page Replacement Algorithm)</strong></li>
<li><strong>改进型FIFO算法(Second Chance Page Replacement Algorithm)</strong><ul>
<li>这种算法是在FIFO的基础上，为了避免置换出经常使用的页，增加一个标志位R，如果最近使用过将R置1，当页将会淘汰时，如果R为1，则不淘汰页，将R置0.而那些R=0的页将被淘汰时，直接淘汰。这种算法避免了经常被使用的页被淘汰。</li>
</ul>
</li>
<li><strong>时钟替换算法(Clock Page Replacement Algorithm)</strong></li>
<li>LRU</li>
</ul>
</li>
</ul>
<hr>
<h4 id="进程空间和内核空间对内存的管理不同"><a href="#进程空间和内核空间对内存的管理不同" class="headerlink" title="进程空间和内核空间对内存的管理不同"></a>进程空间和内核空间对内存的管理不同</h4><p>用户空间对应进程，所以每当进程切换，用户空间</p>
<p>就会跟着变化；而内核空间是由内核负责映射，它并不会跟着进程变化，是固定的。内核空间地址有自己对应的页表，用户进程各自有不同的页表。</p>
<p><img src="https://img-blog.csdn.net/20130926120346703" alt="img"></p>
<p><img src="https://img-blog.csdn.net/20130926120338812" alt="img"></p>
<hr>
<h4 id="Linux的slab层-amp-VAM"><a href="#Linux的slab层-amp-VAM" class="headerlink" title="Linux的slab层 &amp; VAM"></a>Linux的slab层 &amp; VAM</h4><p>SLAB 算法是一种对伙伴算的一种补充，对于用户进程的内存分配，伙伴算法已经够好了，但对于内核进程，还需要存在一类很小的数据（字节大小，比如进程描述符、虚拟内存描述符等），若每次给几个字节的数据分配一个4KB的页，实在太浪费，于是就有了SLBA算法，SLAB算法其实就是把一个页用力劈成一小块一小块，然后再分配。</p>
<hr>
<h4 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h4><p>一种物理内存分配和回收的方法，物理内存所有空闲页都记录在BUDDY链表中。首选，系统建立一个链表，链表中的每个元素代表一类大小的物理内存，分别为2的0次方、1次方、2次方，个页大小，对应4K、8K、16K的内存，没一类大小的内存又有一个链表，表示目前可以分配的物理内存。例如现在仅存需要分配8K的物理内存，系统首先从8K那个链表中查询有无可分配的内存，若有直接分配；否则查找16K大小的链表，若有，首先将16K一分为二，将其中一个分配给进程，另一个插入8K的链表中，若无，继续查找32K，若有，首先把32K一分为二，其中一个16K大小的内存插入16K链表中，然后另一个16K继续一分为二，将其中一个插入8K的链表中，另一个分配给进程……..以此类推。当内存释放时，查看相邻内存有无空闲，若存在两个联系的8K的空闲内存，直接合并成一个16K的内存，插入16K链表中。（伙伴算法用于物理内存分配方案）</p>
<hr>
<h4 id="高端内存"><a href="#高端内存" class="headerlink" title="高端内存"></a>高端内存</h4><p>linux中内核使用3G-4G的线性地址空间，也就是说总共只有1G的地址空间可以用来映射物理地址空间。但是，如果内存大于1G的情况下呢？是不是超过1G的内存就无法使用了呢？为此内核引入了一个高端内存的概念，把1G的线性地址空间划分为两部分：小于896M物理地址空间的称之为低端内存，这部分内存的物理地址和3G开始的线性地址是一一对应映射的,也就是说内核使用的线性地址空间3G–(3G+896M)和物理地址空间0-896M一一对应；剩下的128M的线性空间用来映射剩下的大于896M的物理地址空间，这也就是我们通常说的高端内存区。</p>
<p>所谓的建立高端内存的映射就是能用一个线性地址来访问高端内存的页。如何理解这句话呢？在开启分页后，我们要访问一个物理内存地址，需要经过MMU的转换，也就是一个32位地址vaddr的高10位用来查找该vaddr所在页目录项，用12-21位来查找页表项，再用0-11位偏移和页的起始物理地址相加得到paddr,再把该paddr放到前端总线上，那么我们就可以访问该vaddr对应的物理内存了。在低端内存中，每一个物理内存页在系统初始化的时候都已经存在这样一个映射了。而高端内存还不存在这样一个映射(页目录项，页表都是空的)，所以我们必须要在系统初始化完后，提供一系列的函数来实现这个功能，这就是所谓的高端内存的映射。那么我们为什么不再系统初始化的时候把所有的内存映射都建立好呢？主要原因是，内核线性地址空间不足以容纳所有的物理地址空间（1G的内核线性地址空间和最多可达4G的物理地址空间），所以才需要预留一部分（128M）的线性地址空间来动态的映射所有的物理地址空间，于是就产生了所谓的高端内存映射。</p>
<h2 id="4-Linux-进程管理与调度"><a href="#4-Linux-进程管理与调度" class="headerlink" title="4. Linux 进程管理与调度"></a>4. Linux 进程管理与调度</h2><h3 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1 背景知识"></a>1 背景知识</h3><h5 id="1-1什么是调度器"><a href="#1-1什么是调度器" class="headerlink" title="1. 1什么是调度器"></a>1. 1什么是调度器</h5><p>通常来说，操作系统是应用程序和可用资源之间的媒介。</p>
<p>典型的资源有内存和物理设备。但是CPU也可以认为是一个资源，调度器可以临时分配一个任务在上面执行（单位是时间片）。调度器使得我们同时执行多个程序成为可能，因此可以与具有各种需求的用户共享CPU。</p>
<p>内核必须提供一种方法, 在各个进程之间尽可能公平地共享CPU时间, 而同时又要考虑不同的任务优先级.</p>
<p>调度器的一个重要目标是有效地分配 CPU 时间片，同时提供很好的用户体验。调度器还需要面对一些互相冲突的目标，例如既要为关键实时任务最小化响应时间, 又要最大限度地提高 CPU 的总体利用率.</p>
<p>调度器的一般原理是, 按所需分配的计算能力, 向系统中每个进程提供最大的公正性, 或者从另外一个角度上说, 他试图确保没有进程被亏待.</p>
<h5 id="1-2-调度策略"><a href="#1-2-调度策略" class="headerlink" title="1.2 调度策略"></a>1.2 调度策略</h5><p>传统的Unix操作系统的调度算法必须实现几个互相冲突的目标:</p>
<ul>
<li>进程响应时间尽可能快</li>
<li>后台作业的吞吐量尽可能高</li>
<li>尽可能避免进程的饥饿现象</li>
<li>低优先级和高优先级进程的需要尽可能调和等等</li>
</ul>
<p>调度策略(scheduling policy)的任务就是决定什么时候以怎么样的方式选择一个新进程占用CPU运行.</p>
<p>传统操作系统的调度基于分时(time sharing)技术: 多个进程以”时间多路服用”方式运行, 因为CPU的时间被分成”片(slice)”, 给每个可运行进程分配一片CPU时间片, 当然单处理器在任何给定的时刻只能运行一个进程.</p>
<p>如果当前可运行进程的时限(quantum)到期时(即时间片用尽), 而该进程还没有运行完毕, 进程切换就可以发生.</p>
<p>分时依赖于定时中断, 因此对进程是透明的, 不需要在承租中插入额外的代码来保证CPU分时.</p>
<p>调度策略也是根据进程的优先级对他们进行分类. 有时用复杂的算法求出进程当前的优先级, 但最后的结果是相同的: 每个进程都与一个值(优先级)相关联, 这个值表示把进程如何适当地分配给CPU.</p>
<p>在linux中, 进程的优先级是动态的. 调度程序跟踪进程正在做什么, 并周期性的调整他们的优先级. 在这种方式下, 在较长的时间间隔内没有任何使用CPU的进程, 通过动态地增加他们的优先级来提升他们. 相应地, 对于已经在CPU上运行了较长时间的进程, 通过减少他们的优先级来处罚他们.</p>
<h5 id="1-3-进程饥饿"><a href="#1-3-进程饥饿" class="headerlink" title="1.3 进程饥饿"></a>1.3 进程饥饿</h5><p>进程饥饿，即为Starvation，指当等待时间给进程推进和响应带来明显影响称为进程饥饿。当饥饿到一定程度的进程在等待到即使完成也无实际意义的时候称为饥饿死亡。</p>
<p><strong>产生饥饿的原因</strong></p>
<p>在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。</p>
<p>有时资源分配策略可能是不公平的，即不能保证等待时间上界的存在。在这种情况下，即使系统没有发生死锁，某些进程也可能会长时间等待．当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿，当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。</p>
<p>举个例子，当有多个进程需要打印文件时，如果系统分配打印机的策略是最短文件优先，那么长文件的打印任务将由于短文件的源源不断到来而被无限期推迟，导致最终的饥饿甚至饿死。</p>
<hr>
<h3 id="2-Linux-进程的分类"><a href="#2-Linux-进程的分类" class="headerlink" title="2 Linux 进程的分类"></a>2 Linux 进程的分类</h3><h5 id="2-1-实时进程-与-非实时进程（普通进程）"><a href="#2-1-实时进程-与-非实时进程（普通进程）" class="headerlink" title="2.1 实时进程 与 非实时进程（普通进程）"></a>2.1 实时进程 与 非实时进程（普通进程）</h5><p>一种分类法是将进程分为三类：</p>
<ul>
<li>交互式进程(interactive process)<ul>
<li>此类进程经常与用户进行交互, 因此需要花费很多时间等待键盘和鼠标操作. 当接受了用户的输入后, 进程必须很快被唤醒, 否则用户会感觉系统反应迟钝</li>
<li>shell, 文本编辑程序和图形应用程序</li>
</ul>
</li>
<li>批处理进程(batch process)<ul>
<li>此类进程不必与用户交互, 因此经常在后台运行. 因为这样的进程不必很快相应, 因此常受到调度程序的怠慢</li>
<li>程序语言的编译程序, 数据库搜索引擎以及科学计算</li>
</ul>
</li>
<li>实时进程(real-time process)<ul>
<li>这些进程由很强的调度需要, 这样的进程绝不会被低优先级的进程阻塞. 并且他们的响应时间要尽可能的短</li>
<li>视频音频应用程序, 机器人控制程序以及从物理传感器上收集数据的程序</li>
</ul>
</li>
</ul>
<p>在linux中, 调度算法可以明确的确认所有实时进程的身份, 但是没办法区分交互式程序和批处理程序(统称为普通进程), linux2.6的调度程序实现了基于进程过去行为的启发式算法, 以确定进程应该被当做交互式进程还是批处理进程. 当然与批处理进程相比, 调度程序有偏爱交互式进程的倾向</p>
<p>对于实时进程，采用FIFO或者Round Robin的调度策略.</p>
<p>对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器的核心思想是”完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持.</p>
<p>注意Linux通过将进程和线程调度视为一个，同时包含二者。进程可以看做是单个线程，但是进程可以包含共享一定资源（代码和/或数据）的多个线程。因此进程调度也包含了线程调度的功能.</p>
<p>linux进程的调度算法其实经过了很多次的演变, 但是其演变主要是针对与普通进程的, 因为前面我们提到过根据进程的不同分类Linux采用不同的调度策略.实时进程和普通进程采用了不同的调度策略, 更一般的普通进程还需要启发式的识别批处理进程和交互式进程.</p>
<p>实时进程的调度策略比较简单, 因为实时进程值只要求尽可能快的被响应, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时, 总选择优先级最高的进程开始执行. 低优先级不可能抢占高优先级, 因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求.</p>
<p>但是普通进程的调度策略就比较麻烦了, 因为普通进程不能简单的只看优先级, 必须公平的占有CPU, 否则很容易出现进程饥饿, 这种情况下用户会感觉操作系统很卡, 响应总是很慢.</p>
<p>此外如何进程中如果存在实时进程, 则实时进程总是在普通进程之前被调度</p>
<hr>
<h3 id="3-优先级"><a href="#3-优先级" class="headerlink" title="3 优先级"></a>3 优先级</h3><h5 id="3-1-优先级取值范围"><a href="#3-1-优先级取值范围" class="headerlink" title="3.1 优先级取值范围"></a>3.1 优先级取值范围</h5><p> 在linux系统中，进程优先级的取值范围是0-139,而这个值又是由另外两个值组成的，一个是代表实时进程（realtime）优先级范围是[0,99],另外一个是代表非实时进程，取值范围是[100,139]。<br>    所以，Linux进程实际上实现了140个优先级范围，取值范围是从0-139，这个值越小，优先级越高。</p>
<ul>
<li><strong>动态优先级</strong>：实时进程优先级[0,99],该区间被称为动态优先级，优先级随着进程执行情况的变化而改变，以便获得更好的调度性能。</li>
<li><strong>静态优先级</strong>：代表非实时进程优先级[100,139],被称为静态优先级，该值不会随着时间而进行改变，但系统可以通过nice命令来进行修改。</li>
</ul>
<h5 id="3-2-PRI-和-NICE-值"><a href="#3-2-PRI-和-NICE-值" class="headerlink" title="3.2 PRI 和 NICE 值"></a>3.2 PRI 和 NICE 值</h5><ul>
<li>PRI</li>
</ul>
<p>PRI即进程的优先级，此值越小进程的优先级别越高。PRI值越小越快被cpu调度程序执行，那么加入nice值后，将会使得PRI变为：PRI(new)=PRI(old)+nice。由此看出，PRI是根据NICE排序的，规则是NICE越小PRI值越小，其优先级会变高。</p>
<ul>
<li>NICE值</li>
</ul>
<p>它是反应一个进程“优先级”状态的值，其取值范围是-20至19，一共40个级别。它对应于静态优先级的[100,139]这个区间，进程启动后默认的nice值为0，则其对应的优先级为120。<br>NICE值虽然不是priority，但是它确实可以影响进程的优先级。</p>
<h5 id="3-3-查看PRI-和-NICE-值"><a href="#3-3-查看PRI-和-NICE-值" class="headerlink" title="3.3 查看PRI 和 NICE 值"></a>3.3 查看PRI 和 NICE 值</h5><figure class="highlight ps"><figcaption><span>-elf``` 查看</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ps命令中,ps_PRI = static_priority - <span class="number">40</span>，PRI的取值范围为[-<span class="number">40</span>,<span class="number">99</span>]，也就是说，ps中PRI值为<span class="number">80</span>等价于nice值为<span class="number">0</span>，等价于静态优先级的<span class="number">120</span>。</span><br><span class="line"></span><br><span class="line">```top``` 查看</span><br><span class="line"></span><br><span class="line">top中的PR表示优先级，但是跟上述的值不是直接对等的。在top中，实时优先级的[<span class="number">0</span>,<span class="number">99</span>]没有具体的表示。静态优先级和top中的优先级关系为top_PR = static_Priority - <span class="number">100</span>也就是说，top中的PR取值为[<span class="number">0</span>,<span class="number">39</span>]，对应优先级[<span class="number">100</span>,<span class="number">139</span>]</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「JeanCheng」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/gatieme/article/details/<span class="number">51699889</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 5. 死锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 产生的原因</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 系统资源不足</span><br><span class="line"><span class="number">2</span>. 进程运行推进顺序不合适</span><br><span class="line"><span class="number">3</span>. 资源分配不得当</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 产生的必要条件</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 互斥条件：一个资源每次只能被一个进程使用。</span><br><span class="line"><span class="number">2</span>. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br><span class="line"><span class="number">3</span>.  不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br><span class="line"><span class="number">4</span>.  循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。</span><br><span class="line"></span><br><span class="line">这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之</span><br><span class="line"></span><br><span class="line">一不满足，就不会发生死锁。</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 如何避免</span></span><br><span class="line"></span><br><span class="line">所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确</span><br><span class="line">定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态</span><br><span class="line">的情况下占用资源。因此，对资源的分配要给予合理的规划。</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 6. Linux 命令行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### cd</span></span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line"><span class="comment">#### ls</span></span><br><span class="line"></span><br><span class="line">-l 列出长数据串，包含文件的属性与权限数据等</span><br><span class="line"></span><br><span class="line">-a 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</span><br><span class="line"></span><br><span class="line">-R 连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line"><span class="comment">#### grep</span></span><br><span class="line"></span><br><span class="line">该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">grep [-acinv] [--color=auto] <span class="string">'查找字符串'</span> filename</span><br></pre></td></tr></table></figure>

<p>-a 将binary文件以text文件的方式查找数据</p>
<p>-c 计算找到‘查找字符串’的次数</p>
<p>-i 忽略大小写的区别，即把大小写视为相同</p>
<p>-v 反向选择，即显示出没有‘查找字符串’内容的那一行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色</span><br><span class="line">grep --color=auto 'MANPATH' /etc/man.config</span><br><span class="line"><span class="meta">#</span> 把ls -l的输出中包含字母file（不区分大小写）的内容输出</span><br><span class="line">ls -l | grep -i file</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep cout hello.cpp | wc -l</span><br><span class="line">grep -o cout hello.cpp | wc -l</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line"><span class="meta">#</span> 与时间有关的参数：</span><br><span class="line">-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；</span><br><span class="line">-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；</span><br><span class="line">-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；</span><br><span class="line">-newer file : 列出比file还要新的文件名</span><br><span class="line"><span class="meta">#</span> 例如：</span><br><span class="line">find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 与用户或用户组名有关的参数：</span><br><span class="line">-user name : 列出文件所有者为name的文件</span><br><span class="line">-group name : 列出文件所属用户组为name的文件</span><br><span class="line">-uid n : 列出文件所有者为用户ID为n的文件</span><br><span class="line">-gid n : 列出文件所属用户组为用户组ID为n的文件</span><br><span class="line"><span class="meta">#</span> 例如：</span><br><span class="line">find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 与文件权限及名称有关的参数：</span><br><span class="line">-name filename ：找出文件名为filename的文件</span><br><span class="line">-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件</span><br><span class="line">-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、</span><br><span class="line">             目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；</span><br><span class="line">-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；</span><br><span class="line">-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示</span><br><span class="line">-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示</span><br><span class="line"><span class="meta">#</span> 例如：</span><br><span class="line">find / -name passwd # 查找文件名为passwd的文件</span><br><span class="line">find . -perm 0755 # 查找当前目录中文件权限的0755的文件</span><br><span class="line">find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a ：将文件的特性一起复制</span><br><span class="line">-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</span><br><span class="line">-r ：递归持续复制，用于目录的复制行为</span><br><span class="line">-u ：目标文件与源文件有差异时才会复制</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="line">-i ：若目标文件已经存在，就会询问是否覆盖</span><br><span class="line">-u ：若目标文件已经存在，且比目标文件新，才会更新</span><br><span class="line"></span><br><span class="line"># 该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</span><br><span class="line"></span><br><span class="line">mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中</span><br><span class="line">mv file1 file2 # 把文件file1重命名为file2</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="line">-i ：互动模式，在删除前会询问用户是否操作</span><br><span class="line">-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-A ：所有的进程均显示出来</span><br><span class="line">-a ：不与terminal有关的所有进程</span><br><span class="line">-u ：有效用户的相关进程</span><br><span class="line">-x ：一般与a参数一起使用，可列出较完整的信息</span><br><span class="line">-l ：较长，较详细地将PID的信息列出</span><br><span class="line"></span><br><span class="line">ps aux # 查看系统所有的进程数据</span><br><span class="line">ps ax # 查看不与terminal有关的所有进程</span><br><span class="line">ps -lA # 查看系统所有的进程数据</span><br><span class="line">ps axjf # 查看连同一部分进程树状态</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kill -signal PID</span><br><span class="line"></span><br><span class="line">1：SIGHUP，启动被终止的进程</span><br><span class="line">2：SIGINT，相当于输入ctrl+c，中断一个程序的进行</span><br><span class="line">9：SIGKILL，强制中断一个进程的进行</span><br><span class="line">15：SIGTERM，以正常的结束进程方式来终止进程</span><br><span class="line">17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</span><br><span class="line"></span><br><span class="line"># 例如</span><br><span class="line"># 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程</span><br><span class="line">kill -SIGTERM %1 </span><br><span class="line"># 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得</span><br><span class="line">kill -SIGHUP PID</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：</p>
<hr>
<h4 id="tar-unzip"><a href="#tar-unzip" class="headerlink" title="tar/unzip"></a>tar/unzip</h4><hr>
<h4 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h4><p>cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 </p>
<hr>
<h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p>该命令用于改变文件的权限</p>
<hr>
<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>
<p>如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。</p>
<hr>
<h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>可以指定ip,例如截获所有210.27.48.1 的主机收到的和发出的所有的数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 210.27.48.1</span><br></pre></td></tr></table></figure>

<p>截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \)</span><br></pre></td></tr></table></figure>

<p>截获主机hostname发送的所有数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 src host hostname</span><br></pre></td></tr></table></figure>

<p>监视所有送到主机hostname的数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 dst host hostname</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">top -[option]</span><br><span class="line">-b 批处理</span><br><span class="line"></span><br><span class="line">-c 显示完整的治命令</span><br><span class="line"></span><br><span class="line">-I 忽略失效过程</span><br><span class="line"></span><br><span class="line">-s 保密模式</span><br><span class="line"></span><br><span class="line">-S 累积模式</span><br><span class="line"></span><br><span class="line">-i&lt;时间&gt; 设置间隔时间</span><br><span class="line"></span><br><span class="line">-u&lt;用户名&gt; 指定用户名</span><br><span class="line"></span><br><span class="line">-p&lt;进程号&gt; 指定进程</span><br><span class="line"></span><br><span class="line">-n&lt;次数&gt; 循环显示的次数</span><br><span class="line"></span><br><span class="line">h 显示帮助画面，给出一些简短的命令总结说明</span><br><span class="line"></span><br><span class="line">k 终止一个进程。</span><br><span class="line"></span><br><span class="line">i 忽略闲置和僵死进程。这是一个开关式命令。</span><br><span class="line"></span><br><span class="line">q 退出程序</span><br><span class="line"></span><br><span class="line">r 重新安排一个进程的优先级别</span><br><span class="line"></span><br><span class="line">S 切换到累计模式</span><br><span class="line"></span><br><span class="line">s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s</span><br><span class="line"></span><br><span class="line">f或者F 从当前显示中添加或者删除项目</span><br><span class="line"></span><br><span class="line">o或者O 改变显示项目的顺序</span><br><span class="line"></span><br><span class="line">l 切换显示平均负载和启动时间信息</span><br><span class="line"></span><br><span class="line">m 切换显示内存信息</span><br><span class="line"></span><br><span class="line">t 切换显示进程和CPU状态信息</span><br><span class="line"></span><br><span class="line">c 切换显示命令名称和完整命令行</span><br><span class="line"></span><br><span class="line">M 根据驻留内存大小进行排序</span><br><span class="line"></span><br><span class="line">P 根据CPU使用百分比大小进行排序</span><br><span class="line"></span><br><span class="line">T 根据时间/累计时间进行排序</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使用的命令之一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-b 　以Byte为单位显示内存使用情况。 </span><br><span class="line"></span><br><span class="line">-k 　以KB为单位显示内存使用情况。 </span><br><span class="line"></span><br><span class="line">-m 　以MB为单位显示内存使用情况。</span><br><span class="line"></span><br><span class="line">-g   以GB为单位显示内存使用情况。 </span><br><span class="line"></span><br><span class="line">-o 　不显示缓冲区调节列。 </span><br><span class="line"></span><br><span class="line">-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 </span><br><span class="line"></span><br><span class="line">-t 　显示内存总和列。 </span><br><span class="line"></span><br><span class="line">-V 　显示版本信息。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>linux中df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">df [选项] [文件]</span><br><span class="line">-a 全部文件系统列表</span><br><span class="line"></span><br><span class="line">-h 方便阅读方式显示</span><br><span class="line"></span><br><span class="line">-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024</span><br><span class="line"></span><br><span class="line">-i 显示inode信息</span><br><span class="line"></span><br><span class="line">-k 区块为1024字节</span><br><span class="line"></span><br><span class="line">-l 只显示本地文件系统</span><br><span class="line"></span><br><span class="line">-m 区块为1048576字节</span><br><span class="line"></span><br><span class="line">--no-sync 忽略 sync 命令</span><br><span class="line"></span><br><span class="line">-P 输出格式为POSIX</span><br><span class="line"></span><br><span class="line">--sync 在取得磁盘信息前，先执行sync命令</span><br><span class="line"></span><br><span class="line">-T 文件系统类型</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>Linux sed 命令是利用脚本来处理文本文件。</p>
<p>sed 可依照脚本的指令来处理、编辑文本文件。</p>
<p>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;pattern + action&#125;&apos; &#123;filenames&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-IO模型"><a href="#7-IO模型" class="headerlink" title="7. IO模型"></a>7. IO模型</h2><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><h6 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h6><p>同步即一个任务的完成依赖于另一个任务，只有被依赖的任务完成后，依赖的任务才能完成，是一种可靠的任务序列。要么都成功，要么都失败，两个任务的状态可以保持一致。</p>
<p>异步即不需要等被依赖的任务完成，只要通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了任务就算完成。之于被依赖的任务是否完成，依赖他的任务无法确认。</p>
<h6 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h6><p>当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过<strong>状态、通知和回调</strong>来通知调用者。</p>
<p>如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）；</p>
<p>如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p>
<h6 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h6><p>阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p>
<p>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</p>
<ul>
<li>对于同步调用来说，当前线程可能还是激活的，知识逻辑上当前函数没有返回，此时，这个线程可能也会处理其他的消息。<ul>
<li>如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞</li>
<li>如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞</li>
</ul>
</li>
<li>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回。</li>
</ul>
<p>同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p>
<h6 id="同步-异步与阻塞-非阻塞"><a href="#同步-异步与阻塞-非阻塞" class="headerlink" title="同步/异步与阻塞/非阻塞"></a>同步/异步与阻塞/非阻塞</h6><ol>
<li>同步阻塞<ol>
<li>效率是最低的</li>
</ol>
</li>
<li>异步阻塞<ol>
<li>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</li>
</ol>
</li>
<li><strong>同步非阻塞形式</strong><ol>
<li>实际上是效率低下的</li>
</ol>
</li>
<li><strong>异步非阻塞形式</strong><ol>
<li>效率更高</li>
</ol>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/aed6067eeac9" target="_blank" rel="noopener">https://www.jianshu.com/p/aed6067eeac9</a></p>
<hr>
<h4 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h4><h6 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h6><ul>
<li>进程切换</li>
</ul>
<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>保存处理机上下文，包括程序计数器和其他寄存器。</p>
<p>更新PCB信息。</p>
<p>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</p>
<p>选择另一个进程执行，并更新其PCB。</p>
<p>更新内存管理的数据结构。</p>
<p>恢复处理机上下文。</p>
<ul>
<li>进程的阻塞</li>
</ul>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<ul>
<li>文件描述符fd</li>
</ul>
<p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<ul>
<li>缓存IO</li>
</ul>
<p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>缺点：</p>
<p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<p>作者：猿码道<br>链接：<a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">https://www.jianshu.com/p/486b0965c296</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h4 id="Linux-I-O-模型"><a href="#Linux-I-O-模型" class="headerlink" title="Linux I/O 模型"></a>Linux I/O 模型</h4><p>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)。</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</li>
</ol>
<p>而对于socket流来说</p>
<ol>
<li>通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li>
<li>把数据从内核缓冲区复制到应用进程缓冲区。</li>
</ol>
<p>网络应用需要处理的无非就是两大类问题，网络IO，数据计算。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。网络IO的模型大致有如下几种：</p>
<ul>
<li><strong>同步模型（synchronous IO）</strong></li>
<li>阻塞IO（bloking IO）</li>
<li>非阻塞IO（non-blocking IO）</li>
<li>多路复用IO（multiplexing IO）</li>
<li>信号驱动式IO（signal-driven IO）</li>
<li><strong>异步IO（asynchronous IO）</strong></li>
</ul>
<p><img src="https://static.oschina.net/uploads/img/201604/20144245_Wtld.png" alt="输入图片说明"></p>
<p>每个 IO 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。常见的IO模型有阻塞、非阻塞、IO多路复用，异步</p>
<hr>
<h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><h6 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h6><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。阻塞就是进程 “被” 休息, CPU处理其它进程去了。</p>
<p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，<code>在等待数据到处理数据的两个阶段</code>，整个进程都被阻塞。不能处理别的网络IO。<code>调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态</code>，因此从处理的角度来看，这是非常有效的。在调用recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图：</p>
<p><img src="https://static.oschina.net/uploads/img/201604/20150405_VKYH.png" alt="输入图片说明"></p>
<p>优点：</p>
<ol>
<li>能够及时返回数据，无延迟；</li>
<li>对内核开发者来说这是省事了；</li>
</ol>
<p>缺点：</p>
<ol>
<li>对用户来说处于等待就要付出性能的代价了</li>
</ol>
<hr>
<h4 id="同步非阻塞-IO"><a href="#同步非阻塞-IO" class="headerlink" title="同步非阻塞 IO"></a>同步非阻塞 IO</h4><h6 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h6><p>我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。<code>这就是非阻塞</code>。需要不断的询问，是否准备好了。</p>
<h6 id="网络模型-1"><a href="#网络模型-1" class="headerlink" title="网络模型"></a>网络模型</h6><p>同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。在这种模型中，设备是以非阻塞的形式打开的。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。</p>
<p>在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p>
<p><code>也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error</code>。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。<code>这个过程通常被称之为轮询</code>。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。<strong><code>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</code></strong>。</p>
<p>在linux下，可以通过设置socket使其变为non-blocking。<code>当对一个non-blocking socket执行读操作时</code>，流程如图所示：</p>
<p><img src="https://static.oschina.net/uploads/img/201604/20152818_DXcj.png" alt="输入图片说明"></p>
<h6 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a>流程描述</h6><p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
<p><strong>同步非阻塞方式相比同步阻塞方式：</strong></p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>
<p>作者：猿码道<br>链接：<a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">https://www.jianshu.com/p/486b0965c296</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h4 id="IO-多路复用（-IO-multiplexing）"><a href="#IO-多路复用（-IO-multiplexing）" class="headerlink" title="IO 多路复用（ IO multiplexing）"></a>IO 多路复用（ IO multiplexing）</h4><h6 id="场景描述-1"><a href="#场景描述-1" class="headerlink" title="场景描述"></a>场景描述</h6><p>与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，<code>这就是典型的IO多路复用</code>。</p>
<h6 id="网络模型-2"><a href="#网络模型-2" class="headerlink" title="网络模型"></a>网络模型</h6><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。<code>那么这就是所谓的 “IO 多路复用”</code>。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。</p>
<p><code>IO多路复用有两个特别的系统调用select、poll、epoll函数</code>。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—<code>前者可以等待多个socket，能实现同时对多个IO端口进行监听</code>，当其中任何一个socket的数据准好了，<code>就能返回进行可读</code>，<code>然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的</code>。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，<code>此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理</code>。如何知道有一部分数据到达了呢？<code>监视的事情交给了内核，内核负责数据到达的处理。也可以理解为&quot;非阻塞&quot;吧</code>。</p>
<p><code>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作</code>。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p>
<p>对于多路复用，也就是轮询多个socket。<code>多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了</code>，当然也可以针对不同的编号。具体流程，如下图所示：</p>
<p><img src="https://static.oschina.net/uploads/img/201604/20164149_LD8E.png" alt="输入图片说明"></p>
<h6 id="流程描述-1"><a href="#流程描述-1" class="headerlink" title="流程描述"></a>流程描述</h6><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。<code>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO</code>。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，<code>当任何一个socket中的数据准备好了，select就会返回</code>。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>多路复用的特点是<code>通过一种机制一个进程能同时等待IO文件描述符</code>，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p>
<p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。<code>因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)</code>。但是，<code>用select的优势在于它可以同时处理多个connection</code>。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，<code>实际中，对于每一个socket，一般都设置成为non-blocking</code>，但是，如上图所示，整个用户的process其实是一直被block的。<code>只不过process是被select这个函数block，而不是被socket IO给block</code>。所以<strong><code>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</code></strong></p>
<p>在I/O编程过程中，<code>当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理</code>。I/O多路复用技术<code>通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</code>。与传统的多线程/多进程模型比，<code>I/O多路复用的最大优势是系统开销小</code>，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：</p>
<ol>
<li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</li>
<li>服务器需要同时处理多种网络协议的套接字。</li>
</ol>
<p>了解了前面三种IO模式，在用户进程进行系统调用的时候，<strong><code>他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询</code></strong>，两个阶段过程：</p>
<ol>
<li>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</li>
<li>第二个阶段都是阻塞的。</li>
</ol>
<p><strong><code>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。</code></strong><code>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式</code>。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。<code>而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求</code>。</p>
<hr>
<h4 id="信号驱动式IO（signal-driven-IO）"><a href="#信号驱动式IO（signal-driven-IO）" class="headerlink" title="信号驱动式IO（signal-driven IO）"></a>信号驱动式IO（signal-driven IO）</h4><p>首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：</p>
<p><img src="https://static.oschina.net/uploads/img/201604/21091434_DsZb.png" alt="输入图片说明"></p>
<p>即在socket处设立一个发送信息的装置，好了以后向进程发送准备完毕的消息，然后进程再调用recvform</p>
<hr>
<h4 id="异步非阻塞-IO（asynchronous-IO）"><a href="#异步非阻塞-IO（asynchronous-IO）" class="headerlink" title="异步非阻塞 IO（asynchronous IO）"></a>异步非阻塞 IO（asynchronous IO）</h4><h6 id="网络模型-3"><a href="#网络模型-3" class="headerlink" title="网络模型"></a>网络模型</h6><p>相对于同步IO，异步IO不是顺序执行。<code>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情</code>。等到socket数据准备好了，内核直接复制数据给进程，<code>然后从内核向进程发送通知</code>。<code>IO两个阶段，进程都是非阻塞的</code>。</p>
<p>目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示</p>
<p><img src="https://static.oschina.net/uploads/img/201604/20175459_gtgw.png" alt="输入图片说明"></p>
<h6 id="流程描述-2"><a href="#流程描述-2" class="headerlink" title="流程描述"></a>流程描述</h6><p>用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，<code>首先它会立刻返回，所以不会对用户进程产生任何block</code>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，<code>当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程</code>，告诉它read操作完成了。</p>
<p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p>
<p><code>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数</code>，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，<code>一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事</code>。</p>
<p><code>如果这个进程正在内核态忙着做别的事</code>，例如以同步阻塞方式读写磁盘，<code>那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知</code>。</p>
<p><code>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒</code>，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p>
<h6 id="AIO-的动机"><a href="#AIO-的动机" class="headerlink" title="AIO 的动机"></a>AIO 的动机</h6><p>同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。</p>
<p>同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。</p>
<p>这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知。</p>
<p>IO多路复用除了需要阻塞之外，<code>select 函数所提供的功能（异步阻塞 IO）与 AIO 类似</code>。不过，<code>它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞</code>。</p>
<p>作者：猿码道<br>链接：<a href="https://www.jianshu.com/p/486b0965c296" target="_blank" rel="noopener">https://www.jianshu.com/p/486b0965c296</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h4 id="五种模型流程比较"><a href="#五种模型流程比较" class="headerlink" title="五种模型流程比较"></a>五种模型流程比较</h4><h6 id><a href="#" class="headerlink" title></a><img src="https://static.oschina.net/uploads/img/201604/21095604_vhHX.png" alt="输入图片说明"></h6><h4 id="select，poll，epoll的区别"><a href="#select，poll，epoll的区别" class="headerlink" title="select，poll，epoll的区别"></a>select，poll，epoll的区别</h4><hr>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>实际中，这三个函数对于每一个socket，一般都设置成为non-blocking，但是，整个用户的process其实是一直被block的。`只不过process是被函数block，而不是被socket IO给block。</p>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>

<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; /* file descriptor */</span><br><span class="line">    short events; /* requested events to watch */</span><br><span class="line">    short revents; /* returned events witnessed */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。</p>
<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p>轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。</p>
<p>作者：任荒芜蔓延<br>链接：<a href="https://www.nowcoder.com/discuss/369657?type=5" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/369657?type=5</a><br>来源：牛客网</p>
<p>epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。<br> 红黑树将存储epoll所监听的套接字。上面mmap出来的内存如何保存epoll所监听的套接字，必然也得有一套数据结构，epoll在实现上采用红黑树去存储所有套接字，当添加或者删除一个套接字时（epoll_ctl），都在红黑树上去处理，红黑树本身插入和删除性能比较好，时间复杂度O(logN)。<br> 通过epoll_ctl函数添加进来的事件都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把事件添加进来的时候时候会完成关键的一步，那就是该事件都会与相应的设备（网卡）驱动程序建立回调关系，当相应的事件发生后，就会调用这个回调函数，该回调函数在内核中被称为：ep_poll_callback,这个回调函数其实就所把这个事件添加到rdllist这个双向链表中。一旦有事件发生，epoll就会将该事件添加到双向链表中。那么当我们调用epoll_wait时，epoll_wait只需要检查rdlist双向链表中是否有存在注册的事件，效率非常可观。这里也需要将发生了的事件复制到用户态内存中即可。</p>
<ul>
<li>epoll 现在是线程安全的，而 select 和 poll 不是。这是因为epoll是通过锁来保证线程安全的, epoll中粒度最小的自旋锁ep-&gt;lock(spinlock)用来保护就绪的队列, 互斥锁ep-&gt;mtx用来保护epoll的重要数据结构红黑树</li>
<li>epoll 内部使用了 mmap 共享了用户和内核的部分空间，避免了数据的来回拷贝。</li>
<li>epoll 基于事件驱动，epoll_ctl 注册事件并注册 callback 回调函数，epoll_wait 只返回发生的事件避免了像 select 和 poll 对事件的整个轮寻操作。</li>
</ul>
<p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>int epoll_create(int size)</strong></li>
</ul>
<p><strong>创建一个epoll的句柄</strong>，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<ul>
<li><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong></li>
</ul>
<p><strong>函数是对指定描述符fd执行op操作</strong>。<br>- epfd：是epoll_create()的返回值。<br>- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br>- fd：是需要监听的fd（文件描述符）<br>- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">  __uint32_t events;  /* Epoll events */</span><br><span class="line">  epoll_data_t data;  /* User data variable */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//events可以是以下几个宏的集合：</span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></li>
</ul>
<p>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h6 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h6><p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。</p>
<p>从本质上来讲，ET相对LT是通过减少系统调用来提高并行效率的。</p>
<ul>
<li><strong>LT 模式</strong></li>
</ul>
<p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ul>
<li><strong>ET模式</strong></li>
</ul>
<p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h6 id="编程注意事项"><a href="#编程注意事项" class="headerlink" title="编程注意事项"></a>编程注意事项</h6><p>在ET模式下，读取套接字必须要读干净。</p>
<ul>
<li>在LT模式下，当socket可写时，会不停的触发socket可写的事件，如何处理？</li>
</ul>
<p>第一种最普遍的方式：<br>需要向socket写数据的时候才把socket加入epoll，等待可写事件。接受到可写事件后，调用write或者send发送数据。当所有数据都写完后，把socket移出epoll。</p>
<p>这种方式的缺点是，即使发送很少的数据，也要把socket加入epoll，写完后在移出epoll，有一定操作代价。</p>
<p>第二种</p>
<p>开始不把socket加入epoll，需要向socket写数据的时候，直接调用write或者send发送数据。如果返回EAGAIN，把socket加入epoll，在epoll的驱动下写数据，全部数据发送完毕后，再移出epoll。</p>
<p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p>
<p>这种方式的优点是：数据不多的时候可以避免epoll的事件处理，提高效率。</p>
<ul>
<li><strong>ET模式的线程饥饿问题</strong></li>
</ul>
<p>如果某个socket源源不断地收到非常多的数据，在试图读取完所有数据的过程中，有可能会造成其他的socket得不到处理，从而造成饥饿问题。</p>
<p>解决办法：为每个已经准备好的描述符维护一个队列，这样程序就可以知道哪些描述符已经准备好了但是并没有被读取完，然后程序定时或定量的读取，如果读完则移除，直到队列为空，这样就保证了每个fd都被读到并且不会丢失数据，流程如图:</p>
<ul>
<li><strong>EPOLLONESHOT设置</strong></li>
</ul>
<p>A线程读完某socket上数据后开始处理这些数据，此时该socket上又有新数据可读，B线程被唤醒读新的数据，造成2个线程同时操作一个socket的局面 ，EPOLLONESHOT保证一个socket连接在任一时刻只被一个线程处理。</p>
<ul>
<li><strong>两种模式的选择</strong></li>
</ul>
<p>通过前面的对比可以看到LT模式比较安全并且代码编写也更清晰，但是ET模式属于高速模式，在处理大高并发场景使用得当效果更好，具体选择什么根据自己实际需要和团队代码能力来选择，如果并发很高且团队水平较高可以选择ET模式，否则建议LT模式。</p>
<p><strong>6.epoll的惊群问题</strong></p>
<p>在2.6.18内核中accept的惊群问题已经被解决了，但是在epoll中仍然存在惊群问题，表现起来就是当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。<br>在epoll官方没有正式修复这个问题之前，Nginx作为知名使用者采用全局锁来限制每次可监听fd的进程数量，每次只有1个可监听的进程，后来在Linux 3.9内核中增加了SO_REUSEPORT选项实现了内核级的负载均衡，Nginx1.9.1版本支持了reuseport这个新特性，从而解决惊群问题。EPOLLEXCLUSIVE是在2016年Linux 4.5内核新添加的一个 epoll 的标识，Ngnix 在 1.11.3 之后添加了NGX_EXCLUSIVE_EVENT选项对该特性进行支持。EPOLLEXCLUSIVE标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p>
<p><strong>epoll的优点主要是一下几个方面：</strong></p>
<ol>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。<ol>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
<li>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</li>
</ol>
</li>
</ol>
<h2 id="8-线程池与内存池"><a href="#8-线程池与内存池" class="headerlink" title="8. 线程池与内存池"></a>8. 线程池与内存池</h2><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> Task = function&lt;<span class="keyword">void</span>()&gt;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;thread&gt; pool;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Task&gt; tasks;</span><br><span class="line">    <span class="comment">//同步</span></span><br><span class="line">    mutex mtx;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">    <span class="comment">//是否关闭提交</span></span><br><span class="line">    atomic&lt;<span class="keyword">bool</span>&gt; isStop;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TaskExecutor(<span class="keyword">int</span> size = <span class="number">4</span>):isStop(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">1</span>)</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pool.emplace_back(&amp;TaskExecutor::schedual, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~TaskExecutor()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : pool)</span><br><span class="line">            t.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止任务提交</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isStop.store(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重启任务提交</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isStop.store(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交一个任务</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto</span> <span class="title">commit</span>(<span class="title">F</span>&amp;&amp; <span class="title">f</span>, <span class="title">Args</span>&amp;&amp;...<span class="title">args</span>)-&gt;<span class="title">future</span>&lt;decltype(f(args...))&gt;</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (isStop.load())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"task executor have closed commit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> ResType = <span class="keyword">decltype</span>(f(args...));</span><br><span class="line">        <span class="keyword">auto</span> task = make_shared&lt;packaged_task&lt;ResType()&gt;&gt;(</span><br><span class="line">            <span class="built_in">std</span>::bind(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...)</span><br><span class="line">            );</span><br><span class="line">        <span class="comment">//添加任务到队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock_guard&lt;mutex&gt; lck(mtx);</span><br><span class="line">            tasks.emplace([task]() &#123;</span><br><span class="line">                (*task)();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cv.notify_one();</span><br><span class="line">        future&lt;ResType&gt; future = task-&gt;get_future();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//获得一个待执行的Task</span></span><br><span class="line">    <span class="function">Task <span class="title">get_one_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unique_lock&lt;mutex&gt; lck(mtx);</span><br><span class="line">        cv.wait(lck, [&amp;]() &#123;</span><br><span class="line">            <span class="keyword">return</span> !tasks.empty();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">Task <span class="title">task</span><span class="params">(move(tasks.front()))</span></span>;</span><br><span class="line">        tasks.pop();</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务调度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedual</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Task task = get_one_task())</span><br><span class="line">            &#123;</span><br><span class="line">                task();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello f"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello g!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_lock&lt;mutex&gt; lck(m);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i &lt;&lt; <span class="string">"号线程被调度"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TaskExecutor <span class="title">executor</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    future&lt;<span class="keyword">void</span>&gt; ff = executor.commit(f);</span><br><span class="line">    future&lt;<span class="keyword">int</span>&gt; fg = executor.commit(G());</span><br><span class="line">    future&lt;<span class="built_in">string</span>&gt; fh = executor.commit([]()-&gt;<span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello h!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,fh!"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    ff.get();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fg.get() &lt;&lt; <span class="string">" "</span> &lt;&lt; fh.get() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    this_thread::sleep_for(chrono::seconds(<span class="number">5</span>));</span><br><span class="line">    executor.restart();</span><br><span class="line">    executor.commit(f).get();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"end..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        executor.commit(x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/zhangbaochong/p/5879434.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangbaochong/p/5879434.html</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1361759" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1361759</a></p>
<h2 id="9-Linux-相关"><a href="#9-Linux-相关" class="headerlink" title="9. Linux 相关"></a>9. Linux 相关</h2><h4 id="如何判断系统的位数"><a href="#如何判断系统的位数" class="headerlink" title="如何判断系统的位数"></a>如何判断系统的位数</h4><p>Linux：uname -a</p>
<hr>
<h4 id="系统位数的意义"><a href="#系统位数的意义" class="headerlink" title="系统位数的意义"></a>系统位数的意义</h4><p>8位处理器、16位处理器、32位处理器和64位处理器，其计数都是8的倍数。它表示一个时钟周期里，处理器处理的二进制代码数。“0”和“1”就是二进制代码，线路上有电信号，则计做1,没有电信号则为0。8位机有8条线路，每个时钟周期有8个电信号，组成一个字节。所以，随8位处理器上升至64位处理器，每个时钟周期传送1个字节到8个字节，关联到时钟速度提高到若干个千兆赫之后，处理器处理信息的能力越来越大。</p>
<p>如果操作数最高可达64位，那么存放操作数的通用寄存器（GPR）也必须是64位的，64位处理器也就有64位的GPR。<br>同样的道理，目前作为主流的32位处理器（如Pentium 4，K7）的GPR就是32位的了。GPR是CPU寻址和地址数据存放的地方。64位处理器的GPR提升到了64位，增加程序员可见寄存器数量（这部分增加的寄存器称之为“寄存器扩展”），因而可供编程者使用的寄存器空间就更大，处理器的寻址能力和地址数据处理能力就会成倍的提高，性能自然机会更强。换句话来说，当64位处理器与32位处理器在处理同一条指令的时候，64位处理器访问内存、完成工作时消耗的等待时间就会更短，能处理的数据会比32位处理器能处理的数据多一倍以上，同时，64位处理器能管理的内存容量也会比32位处理器的高出一倍、甚至是两倍（PowerPC G5能管理8GB容量的内存）。但需要说明的是，这部分寄存器扩展是需要64位操作系统、64位驱动程序以及64位应用程序的配合才能充分发挥其突出的优势，而目前只有Windows XP 64-Bit Edition、Linux和Mac OS X Panther三个64位操作系统</p>
<hr>
<h4 id="大端-amp-小端"><a href="#大端-amp-小端" class="headerlink" title="大端 &amp; 小端"></a>大端 &amp; 小端</h4><p>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p>
<p>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p>
<p>为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以随时在程序中(在ARM Cortex 系列使用REV、REV16、REVSH指令 [1] )进行大小端的切换。</p>
<hr>
<h4 id="网络序-amp-字节序"><a href="#网络序-amp-字节序" class="headerlink" title="网络序 &amp; 字节序"></a>网络序 &amp; 字节序</h4><p>网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</p>
<p>为了进行转换 bsd socket提供了转换的函数 有下面四个<br>htons 把unsigned short类型从主机序转换到网络序<br>htonl 把unsigned long类型从主机序转换到网络序<br>ntohs 把unsigned short类型从网络序转换到主机序<br>ntohl 把unsigned long类型从网络序转换到主机序</p>
<p>在使用little endian的系统中 这些函数会把字节序进行转换<br>在使用big endian类型的系统中 这些函数会定义成空宏</p>
<p>同样 在网络程序开发时 或是跨平台开发时 也应该注意保证只用一种字节序 不然两方的解释不一样就会产生bug.</p>
<p>字节序即 大端&amp; 小端</p>
<hr>
<h4 id="操作系统为什么有用户态和内核态"><a href="#操作系统为什么有用户态和内核态" class="headerlink" title="操作系统为什么有用户态和内核态"></a>操作系统为什么有用户态和内核态</h4><p>linux的内核是一个有机的整体。每一个用户进程运行时都好像有一份内核的拷贝，每当用户进程使用系统调用时，都自动地将运行模式从用户级转为内核级，此时进程在内核的地址空间中运行。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p>
<p>内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, 如上所提到的intel cpu提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。</p>
<p>从用户空间到内核空间有两种触发手段：</p>
<ol>
<li>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</li>
<li>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。</li>
</ol>
<h2 id="10-文件系统"><a href="#10-文件系统" class="headerlink" title="10. 文件系统"></a>10. 文件系统</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2019/12/22/database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/22/database/" itemprop="url">【面试系列】 - 数据库指北</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-22T16:55:52+08:00">
                2019-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="1-SQL-Query"><a href="#1-SQL-Query" class="headerlink" title="1. SQL Query"></a>1. SQL Query</h1><h1 id="1-1-SQL分类"><a href="#1-1-SQL分类" class="headerlink" title="1.1 SQL分类"></a>1.1 SQL分类</h1><h4 id="DDL（Data-Definition-Languages）语句"><a href="#DDL（Data-Definition-Languages）语句" class="headerlink" title="DDL（Data Definition Languages）语句"></a><strong>DDL（Data Definition Languages）语句</strong></h4><p>数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。</p>
<h4 id="DML（Data-Manipulation-Language）语句"><a href="#DML（Data-Manipulation-Language）语句" class="headerlink" title="DML（Data Manipulation Language）语句"></a>DML（Data Manipulation Language）语句</h4><p>数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）</p>
<h4 id="DCL（Data-Control-Language）语句"><a href="#DCL（Data-Control-Language）语句" class="headerlink" title="DCL（Data Control Language）语句"></a>DCL（Data Control Language）语句</h4><p>数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。</p>
<h2 id="1-1-常见关键字"><a href="#1-1-常见关键字" class="headerlink" title="1.1 常见关键字"></a>1.1 常见关键字</h2><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table Student(</span><br><span class="line">ID varchar(20) not null,</span><br><span class="line">name varchar(10) not null, </span><br><span class="line">age int,</span><br><span class="line">class varchar(50),</span><br><span class="line">primary key (ID));</span><br></pre></td></tr></table></figure>

<h4 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into"></a>insert into</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into Student(ID,name,class)</span><br><span class="line">    values(10152510302,&quot;Tom&quot;,&quot;class 1&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="delete-from"><a href="#delete-from" class="headerlink" title="delete from"></a>delete from</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete form Student</span><br><span class="line">    where name=&quot;Tom&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="update-…-set-…-where"><a href="#update-…-set-…-where" class="headerlink" title="update … set … where"></a>update … set … where</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update Student</span><br><span class="line">   set age=18</span><br><span class="line">   where name=&quot;Tom&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table Student;</span><br></pre></td></tr></table></figure>

<p>删除Student这张表。</p>
<h4 id="alter"><a href="#alter" class="headerlink" title="alter"></a>alter</h4><p>向表中添加性别属性，并且将表中以存放的信息的sex值设为null。所有通过这种方式添加的属性都不能被设置为not null类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table Student</span><br><span class="line">   add sex varchar(5);</span><br></pre></td></tr></table></figure>

<h4 id="alter-table-…-drop"><a href="#alter-table-…-drop" class="headerlink" title="alter table … drop"></a>alter table … drop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table Student</span><br><span class="line">   drop class;</span><br></pre></td></tr></table></figure>

<p>从表中将class这一列属性删除。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>在select后加入关键字distinct表示将结果去重</p>
<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>在select后加入关键字all表示不去重（默认）</p>
<h4 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;&gt;"></a>&lt;&gt;</h4><p>不等于</p>
<h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p>让查询结果中的信息按照给定的属性排序（默认升序，上小下大）</p>
<h4 id="asc-desc"><a href="#asc-desc" class="headerlink" title="asc/desc"></a>asc/desc</h4><p>升序/降序</p>
<h4 id="having"><a href="#having" class="headerlink" title="having"></a>having</h4><p>对group by产生的分组进行筛选，可以使用聚集函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select class,avg(score) as avg_score</span><br><span class="line">from Student natural join Math</span><br><span class="line">group by class</span><br><span class="line">having avg(score) &lt; 60;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-连接（Join）"><a href="#1-2-连接（Join）" class="headerlink" title="1.2 连接（Join）"></a>1.2 连接（Join）</h2><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接(Natural join)是一种特殊的等值连接，要求两个关系表中进行比较的属性组必须是名称相同的属性组，并且在结果中把重复的属性列去掉（即：留下名称相同的属性组中的其中一组）</p>
<p>自然连接将两个关系组中在相同名称的属性上具有相同的值的行记录进行匹配（表A和表B中的Bid属性相等的行记录），并且重复的属性列去掉，这样新的一行将出现在查询结果中，而那些没被匹配的行不出现在结果中（结合A、B表和查询的结果可以看出来）。因此自然连接的结果会有数据丢失，这些丢失的数据就是那些没有匹配的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> A <span class="keyword">natural</span> <span class="keyword">join</span> B</span><br></pre></td></tr></table></figure>

<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a,stu <span class="keyword">as</span> b <span class="keyword">where</span> a.sutid = b.stuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h4><p>以左表为基准，将a.stuid = b.stuid的数据进行连接，然后将左表没有的对应项显示，右表的列为NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">left</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h4 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h4><p>是以右表为基准，将a.stuid = b.stuid的数据进行连接，然以将右表没有的对应项显示，左表的列为NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">right</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h4 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h4><p>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">as</span> a <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> stu <span class="keyword">as</span> b <span class="keyword">on</span> a.sutid = b.stuid</span><br></pre></td></tr></table></figure>

<h3 id="交叉连接（笛卡尔积）"><a href="#交叉连接（笛卡尔积）" class="headerlink" title="交叉连接（笛卡尔积）"></a>交叉连接（笛卡尔积）</h3><p>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from book as a cross join stu as b order by a.id</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-3-SQL-子查询"><a href="#1-3-SQL-子查询" class="headerlink" title="1.3 SQL 子查询"></a>1.3 SQL 子查询</h2><h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h3><p>单行子查询是指子查询的返回结果只有一行数据。当主查询语句的条件语句中引用子查询结果时可用单行比较符号（＝, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;）来进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select ename, deptno, sal</span><br><span class="line">from emp</span><br><span class="line">where deptno=(select deptno from dept where loc=&apos;NEW YORK&apos;)；</span><br></pre></td></tr></table></figure>

<h3 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h3><p>多行子查询即是子查询的返回结果是多行数据。当主查询语句的条件语句中引用子查询结果时必须用多行比较符号（IN，ALL,ANY）来进行比较。其中，IN的含义是匹配子查询结果中的任一个值即可（”IN” 操作符，能够测试某个值是否在一个列表中），ALL则必须要符合子查询的所有值才可，ANY要符合子查询结果的任何一个值即可。而且须注意ALL 和ANY 操作符不能单独使用，而只能与单行比较符（=、&gt;、&lt; 、&gt;= 、&lt;= 、&lt;&gt;）结合使用。</p>
<ol>
<li>多行子查询使用IN操作符号例子：查询选修了老师名叫Rona(假设唯一)的学生名字</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select stName</span><br><span class="line"></span><br><span class="line">from Student</span><br><span class="line"></span><br><span class="line">where stId in(selectdistinct stId from score where teId=(select teId from teacher where teName=&apos;Rona&apos;));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询所有部门编号为A的资料</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT ename,job,sal</span><br><span class="line"></span><br><span class="line">FROM EMP</span><br><span class="line"></span><br><span class="line">WHERE deptno in ( SELECT deptno FROM dept WHERE dname LIKE &apos;A%&apos;)；</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多行子查询使用ALL操作符号例子：查询有一门以上的成绩高于Kaka的最高成绩的学生的名字:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select stName</span><br><span class="line"></span><br><span class="line">from Student</span><br><span class="line"></span><br><span class="line">where stId in(select distinct stId from score where score &gt;all(select score from score where stId=(select stId from Student where stName= &apos;Kaka&apos;) ));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>多行子查询使用ANY操作符号例子：查询有一门以上的成绩高于Kaka的任何一门成绩的学生的名字:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select stName</span><br><span class="line"></span><br><span class="line">from Student</span><br><span class="line"></span><br><span class="line">where stId in(select distinct stId from score where score &gt;any(select score from score where stId=(select stId from Student where stName=&apos;Kaka&apos;)));</span><br></pre></td></tr></table></figure>

<h1 id="2-索引-Indexing"><a href="#2-索引-Indexing" class="headerlink" title="2. 索引 Indexing"></a>2. 索引 Indexing</h1><h2 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1 Introduction"></a>2.1 Introduction</h2><p><strong>使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度</strong>。</p>
<p>一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。<strong>请记住记住这一点：索引是一种数据结构 。</strong></p>
<p><strong>B-Tree</strong> 是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是<strong>有序的</strong>。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。</p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希表是另外一种你可能看到用作索引的数据结构-这些索引通常被称为哈希索引。使用哈希索引的原因是，在寻找值时哈希表效率极高。所以，如果使用哈希索引，对于比较字符串是否相等的查询能够极快的检索出的值。例如之前我们讨论过的这个查询(SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’) 就可以受益于创建在Employee_Name 列上的哈希索引。哈系索引的工作方式是将列的值作为索引的键值（key），和键值相对应实际的值（value）是指向该表中相应行的指针。因为哈希表基本上可以看作是关联数组，一个典型的数据项就像“Jesus =&gt; 0x28939″，而0x28939是对内存中表中包含Jesus这一行的引用。在哈系索引的中查询一个像“Jesus”这样的值，并得到对应行的在内存中的引用，明显要比扫描全表获得值为“Jesus”的行的方式快很多。</p>
<h4 id="哈希索引的缺点"><a href="#哈希索引的缺点" class="headerlink" title="哈希索引的缺点"></a>哈希索引的缺点</h4><p>哈希表是无顺的数据结构，对于很多类型的查询语句哈希索引都无能为力。举例来说，假如你想要找出所有小于40岁的员工。你怎么使用使用哈希索引进行查询？这不可行，因为哈希表只适合查询键值对-也就是说查询相等的查询（例：like “WHERE name = ‘Jesus’）。哈希表的键值映射也暗示其键的存储是无序的。这就是为什么哈希索引通常不是数据库索引的默认数据结构-<strong>因为在作为索引的数据结构时，其不像B-Tree那么灵活</strong></p>
<h4 id="索引是怎么提升性能的"><a href="#索引是怎么提升性能的" class="headerlink" title="索引是怎么提升性能的"></a>索引是怎么提升性能的</h4><p>因为索引基本上是用来存储列值的数据结构，这使查找这些列值更加快速。如果索引使用最常用的数据结构-B-Tree-那么其中的数据是有序的。有序的列值可以极大的提升性能。下面解释原因。</p>
<p>假设我们在 Employee_Name这一列上创建一个B-Tree索引。这意味着当我们用之前的SQL查找姓名是‘Jesus’的雇员时，不需要再扫描全表。而是用索引查找去查找名字为‘Jesus’的雇员，因为索引已经按照按字母顺序排序。索引<strong>已经排序</strong>意味着查询一个名字会快很多，因为名字少字母为‘J’的员工都是排列在一起的。另外重要的一点是，索引同时存储了表中相应行的指针以获取其他列的数据。</p>
<h4 id="索引里究竟存的是什么"><a href="#索引里究竟存的是什么" class="headerlink" title="索引里究竟存的是什么"></a>索引里究竟存的是什么</h4><p>你现在已经知道数据库索引是创建在表的某列上的，并且存储了这一列的所有值。但是，需要理解的重点是<strong>数据库索引并不存储这个表中其他列（字段）的值</strong>。举例来说，如果我们在Employee_Name列创建索引，那么列Employee_Age和Employee_Address上的值并不会存储在这个索引当中。如果我们确实把其他所有字段也存储在个这个索引中，那就成了拷贝一整张表做为索引-这样会占用太大的空间而且会十分低效。</p>
<p><strong>索引存储了指向表中某一行的指针。</strong>如果我们在索引里找到某一条记录作为索引的列的值，如何才能找到这一条记录的其它值呢？这是很简单 - 数据库索引同时存储了指向表中的相应行的指针。指针是指一块内存区域， 该内存区域记录的是对硬盘上记录的相应行的数据的引用。因此，索引中除了存储列的值，还存储着一个指向在行数据的索引。也就是说，索引中的Employee_Name这列的某个值（或者节点）可以描述为 (“Jesus”, 0x82829)， 0x82829 就是包含 “Jesus”那行数据在硬盘上的地址。如果没有这个引用，你就只能访问到一个单独的值（“Jesus”），而这样没有意义，因为你不能获取这一行记录的employee的其他值-例如地址（address）和年龄（age）。</p>
<h4 id="数据库怎么知道什么时候使用索引？"><a href="#数据库怎么知道什么时候使用索引？" class="headerlink" title="数据库怎么知道什么时候使用索引？"></a>数据库怎么知道什么时候使用索引？</h4><p>当这个SQL （<code>SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’</code> ）运行时，数据库会检查在查询的列上是否有索引。假设Employee_Name列上确实创建了索引，数据库会接着检查使用这个索引做查询是否合理 - 因为有些场景下，使用索引比起全表扫描会更加低效。</p>
<h4 id="你能强制数据库使用索引吗？"><a href="#你能强制数据库使用索引吗？" class="headerlink" title="你能强制数据库使用索引吗？"></a>你能强制数据库使用索引吗？</h4><p>通常来说， 你不会告诉数据库什么时候使用索引 - 数据库自己决定。然而，值得注意的是在大多数数据库中（像Oracle 和 MYSQL）， 你实际上可以制订你想要使用的索引。</p>
<h4 id="MyISAM-和-InnoDB-两种索引实现"><a href="#MyISAM-和-InnoDB-两种索引实现" class="headerlink" title="MyISAM 和 InnoDB 两种索引实现"></a>MyISAM 和 InnoDB 两种索引实现</h4><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地 址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据 表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<h4 id="如何在使用SQL创建索引"><a href="#如何在使用SQL创建索引" class="headerlink" title="如何在使用SQL创建索引"></a>如何在使用SQL创建索引</h4><p>之前的例子中，在Employee_Name列上创建索引的SQL如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX name_index</span><br><span class="line">ON Employee (Employee_Name)</span><br></pre></td></tr></table></figure>

<h4 id="如何创建联合索引"><a href="#如何创建联合索引" class="headerlink" title="如何创建联合索引"></a>如何创建联合索引</h4><p>我们可以在雇员表上创建两个列的联合索引，SQL如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX name_index</span><br><span class="line">ON Employee (Employee_Name, Employee_Age)</span><br></pre></td></tr></table></figure>

<h4 id="把数据库索引类比成什么比较好呢"><a href="#把数据库索引类比成什么比较好呢" class="headerlink" title="把数据库索引类比成什么比较好呢?"></a>把数据库索引类比成什么比较好呢?</h4><p>一个非常好的类比是把数据库索引看作是书的索引。如果你有一本关于狗的书，你想要找关于‘黄金猎犬’的那部分。当你可以通过在书背的索引找到哪几页有关于‘黄金猎犬’信息的时候，你为什么要翻完正本书 - 这相当于数据库中的全表扫描。同样的，就像一本书的索引包含页码一样，数据库的索引包含了指针，指向你在SQL中想要查询的值所在的行。</p>
<h4 id="使用数据库索引会有什么代价"><a href="#使用数据库索引会有什么代价" class="headerlink" title="使用数据库索引会有什么代价"></a>使用数据库索引会有什么代价</h4><p>那么，使用数据库索引有什么缺点呢？其一，索引会占用空间 - 你的表越大，索引占用的空间越大。其二，性能损失（主要值更新操作），当你在表中添加、删除或者更新行数据的时候， 在索引中也会有相同的操作。<strong>记住：建立在某列（或多列）索引需要保存该列最新的数据</strong>。</p>
<p><strong>基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引</strong>。</p>
<h2 id="2-2-MySQL的索引方法"><a href="#2-2-MySQL的索引方法" class="headerlink" title="2.2 MySQL的索引方法"></a>2.2 MySQL的索引方法</h2><h4 id="full-text索引"><a href="#full-text索引" class="headerlink" title="full-text索引"></a><strong>full-text索引</strong></h4><p>full-text在mysql里仅有myisam支持它，而且支持full-text的字段只有char、varchar、text数据类型。</p>
<p>full-text主要是用来代替like “%***%”效率低下的问题</p>
<h4 id="b-tree索引"><a href="#b-tree索引" class="headerlink" title="b-tree索引"></a><strong>b-tree索引</strong></h4><p>b-tree在myisam里的形式和innodb稍有不同</p>
<p>在 innodb里，有两种形态：一是primary key形态，其leaf node里存放的是数据，而且不仅存放了索引键的数据，还存放了其他字段的数据。二是secondary index，其leaf node和普通的b-tree差不多，只是还存放了指向主键的信息.</p>
<p>而在myisam里，主键和其他的并没有太大区别。不过和innodb不太一样的地方是在myisam里，leaf node里存放的不是主键的信息，而是指向数据文件里的对应数据行的信息.</p>
<h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a><strong>hash索引</strong></h4><p>目前我所知道的就只有memory和ndb cluster支持这种索引.</p>
<p>hash索引由于其结构，所以在每次查询的时候直接一次到位，不像b-tree那样一点点的前进。所以hash索引的效率高于b-tree，但hash也有缺点，主要如下：</p>
<p>(1)由于存放的是hash值，所以仅支持&lt;=&gt;以及in操作.</p>
<p>(2)hash索引无法通过操作索引来排序，这是因为存放的时候经过hash计算，但是计算的hash值和存放的不一定相等，所以无法排序.</p>
<p>(3)在组合所以里，无法对部分使用索引.</p>
<p>(4)不能避免全表扫描，只是由于在memory表里支持非唯一值hash索引，<a href="http://www.linuxidc.com就是不同的索引键，可能存在相同的hash值" target="_blank" rel="noopener">www.linuxidc.com就是不同的索引键，可能存在相同的hash值</a>.</p>
<p>(5)当存在大量相同hash值得时候，hash索引的效率会变低.</p>
<h4 id="r-tree索引"><a href="#r-tree索引" class="headerlink" title="r-tree索引"></a><strong>r-tree索引</strong></h4><p>r-tree在mysql很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。</p>
<p>相对于b-tree，r-tree的优势在于范围查找.</p>
<h2 id="2-3-索引的优化"><a href="#2-3-索引的优化" class="headerlink" title="2.3 索引的优化"></a>2.3 索引的优化</h2><ol>
<li><strong>如果MySQL估计使用索引比全表扫描还慢，则不会使用索引</strong>（explain 估计）<ol>
<li>返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。</li>
</ol>
</li>
<li><strong>前导模糊查询查询不能命中索引</strong><ol>
<li>EXPLAIN SELECT * FROM user WHERE name LIKE ‘%s%’; 不能命中</li>
<li>优化为 EXPLAIN SELECT * FROM user WHERE name LIKE ‘s%’;</li>
</ol>
</li>
<li><strong>数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来</strong></li>
<li><strong>复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引</strong></li>
<li><strong>union、in、or 都能够命中索引，建议使用 in。</strong></li>
<li><strong>用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到</strong></li>
<li><strong>负向条件查询不能使用索引，可以优化为 in 查询。</strong><ol>
<li>负向条件有：!=、&lt;&gt;、not in、not exists、not like 等。</li>
</ol>
</li>
<li><strong>范围条件查询可以命中索引</strong><ol>
<li>范围条件有：&lt;、&lt;=、&gt;、&gt;=、between等</li>
</ol>
</li>
<li><strong>数据库执行计算不会命中索引</strong></li>
</ol>
<ol>
<li><strong>建立索引的列，不允许为 null</strong></li>
<li><strong>更新十分频繁的字段上不宜建立索引</strong></li>
<li><strong>区分度不大的字段上不宜建立索引</strong></li>
<li><strong>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引</strong></li>
<li><strong>多表关联时，要保证关联字段上一定有索引</strong></li>
</ol>
<p>返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。</p>
<h2 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引"></a><strong>为什么要使用联合索引</strong></h2><ul>
<li><strong>减少开销</strong>。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引</strong>。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select <em>from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W<em>10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w</em>10%</em> 10% *10%=1w，效率提升可想而知！</li>
</ul>
<h1 id="3-数据库事务-Transaction-和锁"><a href="#3-数据库事务-Transaction-和锁" class="headerlink" title="3. 数据库事务(Transaction)和锁"></a>3. 数据库事务(Transaction)和锁</h1><h2 id="3-1-事务的ACID"><a href="#3-1-事务的ACID" class="headerlink" title="3.1 事务的ACID"></a>3.1 事务的ACID</h2><h4 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h4><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<h4 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h4><p> 数据库总是从一个一致性的状态转换到另一个一致性的状态。在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，前面执行的语句也不会生效。因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。</p>
<h4 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h4><p> 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。当执行完第三条语句、第四条语句还未开始时，此时有另外一个程序开始运行，则看不到第三条语句做出的改变。</p>
<h4 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h4><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证策略。</p>
<p>作者：是一动不动的friend<br>链接：<a href="https://www.jianshu.com/p/65275368eff2" target="_blank" rel="noopener">https://www.jianshu.com/p/65275368eff2</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="3-2-事务的四个隔离级别"><a href="#3-2-事务的四个隔离级别" class="headerlink" title="3.2 事务的四个隔离级别"></a>3.2 事务的四个隔离级别</h2><h4 id="读未提交-Read-uncommitted"><a href="#读未提交-Read-uncommitted" class="headerlink" title="读未提交  Read uncommitted"></a>读未提交  Read uncommitted</h4><p>其隔离级别最低，允许脏读。换句话说就是，如果一个事务正在处理某一数据，并对其进行了更新，但是同时没有提交事务，允许另一个事务也可以访问</p>
<p>事务在读数据的时候并未对数据加锁。</p>
<p>事务在修改数据的时候只对数据增加行级共享锁。</p>
<h4 id="读已提交-Read-committed"><a href="#读已提交-Read-committed" class="headerlink" title="读已提交  Read committed"></a>读已提交  Read committed</h4><p>和读未提交的区别就是。读未提交可以读取到别人没有提交的数据，但是读已提交只能读取到别人提交后的值，事务进行的中间值不会读取到</p>
<p>事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；</p>
<p>事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</p>
<h4 id="可重复读-Repeatable-read"><a href="#可重复读-Repeatable-read" class="headerlink" title="可重复读  Repeatable read"></a>可重复读  Repeatable read</h4><p>简单来说就是事务处理过程中多次读取同一个数据的时候，这个值不会发生改变，其值都和第一次查询到的数据是一致的</p>
<p>事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；</p>
<p>事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。</p>
<h4 id="可串行化-Serializable"><a href="#可串行化-Serializable" class="headerlink" title="可串行化  Serializable"></a>可串行化  Serializable</h4><p>是最严格的隔离级别，他要求所有的事务都被串行执行，既事务只能一个接一个的进行处理，不能并发执行</p>
<p>事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；</p>
<p>事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。</p>
<h2 id="3-3-锁"><a href="#3-3-锁" class="headerlink" title="3.3 锁"></a>3.3 锁</h2><h4 id="设立隔离级别"><a href="#设立隔离级别" class="headerlink" title="设立隔离级别"></a>设立隔离级别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL</span><br></pre></td></tr></table></figure>

<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁也称为读锁，读锁允许多个连接可以同一时刻并发的读取同一资源,互不干扰；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK IN SHARE MODE(加共享锁)</span><br></pre></td></tr></table></figure>

<h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><p>排他锁也称为写锁，一个写锁会阻塞其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOR UPDATE(加排他锁)</span><br></pre></td></tr></table></figure>

<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。</p>
<p>通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>与乐观锁相对应的就是悲观锁了。悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p>
<p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p>
<h1 id="4-查询优化"><a href="#4-查询优化" class="headerlink" title="4. 查询优化"></a>4. 查询优化</h1><p>1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num is null</p>
<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<p>select id from t where num=0</p>
<p>4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p>select id from t where num=10 or num=20</p>
<p>可以这样查询：</p>
<p>select id from t where num=10</p>
<p>union all</p>
<p>select id from t where num=20</p>
<p>5、下面的查询也将导致全表扫描：(不能前置百分号)</p>
<p>select id from t where name like ‘%c%’</p>
<p>下面走索引</p>
<p>select id from t where name like ‘c%’</p>
<p>若要提高效率，可以考虑全文检索。</p>
<p>6、in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<p>select id from t where num in(1,2,3)</p>
<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<p>select id from t where num between 1 and 3</p>
<p>7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<p>select id from t where num=@num</p>
<p>可以改为强制查询使用索引：</p>
<p>select id from t with(index(索引名)) where num=@num</p>
<p>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where num/2=100</p>
<p>应改为:</p>
<p>select id from t where num=100*2</p>
<p>9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<p>select id from t where substring(name,1,3)=’abc’ –name以abc开头的id</p>
<p>select id from t where datediff(day,createdate,’2005-11-30′)=0 –’2005-11-30′生成的id</p>
<p>应改为:</p>
<p>select id from t where name like ‘abc%’</p>
<p>select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</p>
<p>10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>12、不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<p>select col1,col2 into #t from t where 1=0</p>
<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<p>create table #t(…)</p>
<p>13、很多时候用 exists 代替 in 是一个好的选择：</p>
<p>select num from a where num in(select num from b)</p>
<p>用下面的语句替换：</p>
<p>select num from a where exists(select 1 from b where num=a.num)</p>
<p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
<p>15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数较好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
<p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<p>22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，较好使 用导出表。</p>
<p>23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p>24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
<p>26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONEINPROC 消息。</p>
<p>29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>30、尽量避免大事务操作，提高系统并发能力。</p>
<h1 id="5-数据库范式"><a href="#5-数据库范式" class="headerlink" title="5. 数据库范式"></a>5. 数据库范式</h1><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>1NF是对属性的<strong><code>原子性</code></strong>，要求属性具有原子性，不可再分解；</p>
<p>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p>
<h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>2NF是对记录的<strong><code>惟一性</code></strong>，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。</p>
<p>简而言之，第二范式（2NF）就是非主属性完全依赖于主关键字。</p>
<h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>3NF是对字段的<strong><code>冗余性</code></strong>，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p>
<p>在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。简而言之，第三范式就是属性不依赖于其它非主属性。</p>
<h4 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h4><p>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合鲍依斯-科得范式。</p>
<h1 id="6-数据库分页分表"><a href="#6-数据库分页分表" class="headerlink" title="6. 数据库分页分表"></a>6. 数据库分页分表</h1><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4><p>假设QQ的用户有100亿，如果只有一张表，每个用户登录的时候数据库都要从这100亿中查找，会很慢很慢。如果将这一张表分成100份，每张表有1亿条，就小了很多，比如qq0,qq1,qq1…qq99表。</p>
<p>用户登录的时候，可以将用户的id%100，那么会得到0-99的数，查询表的时候，将表名qq跟取模的数连接起来，就构建了表名。比如123456789用户，取模的89，那么就到qq89表查询，查询的时间将会大大缩短。</p>
<p>水平拆分的优点：</p>
<p>◆表关联基本能够在数据库端全部完成；</p>
<p>◆不会存在某些超大型数据量和高负载的表遇到瓶颈的问题；</p>
<p>◆应用程序端整体<strong><a href="https://link.zhihu.com/?target=http%3A//lib.csdn.net/base/architecture" target="_blank" rel="noopener">架构</a></strong>改动相对较少；</p>
<p>◆事务处理相对简单；</p>
<p>◆只要切分规则能够定义好，基本上较难遇到扩展性限制；</p>
<p>水平切分的缺点：</p>
<p>◆切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则；</p>
<p>◆后期数据的维护难度有所增加，人为手工定位数据更困难；</p>
<p>◆应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难。</p>
<h4 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h4><p>如果一张表某个字段，信息量大，但是我们很少查询，则可以考虑把这些字段，单独的放入到一张表中，这种方式称为垂直分割.</p>
<p>作文字段的内容较多，可能影响查询的速率，单独抽出来放在一张表中，和主表之间保持关系</p>
<p>垂直切分的优点</p>
<p>◆ 数据库的拆分简单明了，拆分规则明确；</p>
<p>◆ 应用程序模块清晰明确，整合容易；</p>
<p>◆ 数据维护方便易行，容易定位；</p>
<p>垂直切分的缺点</p>
<p>◆ 对于访问极其频繁且数据量超大的表仍然存在性能平静，不一定能满足要求；</p>
<p>◆ 事务处理相对更为复杂；</p>
<p>◆ 切分达到一定程度之后，扩展性会遇到限制；</p>
<p>◆ 过读切分可能会带来系统过渡复杂而难以维护。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>一般来说都是通过 主从复制（Master-Slave）的方式来同步数据，再通过读写分离（MySQL-Proxy）来提升数据库的并发负载能力</p>
<p><strong><a href="https://link.zhihu.com/?target=http%3A//lib.csdn.net/base/14" target="_blank" rel="noopener">MySQL</a></strong> Proxy最强大的一项功能是实现“读写分离(Read/Write Splitting)”。基本的原理是让主数据库处理事务性查询，而从数据库处理SELECT查询。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h4 id="一般的分页查询"><a href="#一般的分页查询" class="headerlink" title="一般的分页查询"></a>一般的分页查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</span><br></pre></td></tr></table></figure>

<p>IMIT 子句可以被用于指定 SELECT 语句返回的记录数。需注意以下几点：</p>
<ul>
<li>第一个参数指定第一个返回记录行的偏移量</li>
<li>第二个参数指定返回记录行的最大数目</li>
<li>如果只给定一个参数：它表示返回最大的记录行数目</li>
<li>第二个参数为 -1 表示检索从某一个偏移量到记录集的结束所有的记录行</li>
<li>初始记录行的偏移量是 0(而不是 1)</li>
</ul>
<p>下面是一个应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type=8 limit 1000,10;</span><br></pre></td></tr></table></figure>

<p>该条语句将会从表 orders_history 中查询第1000条数据之后的10条数据，也就是第1001条到第1010条数据。</p>
<h4 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h4><p>这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type=8 limit 100000,1;</span><br><span class="line">select id from orders_history where type=8 limit 100000,1;</span><br><span class="line">select * from orders_history where type=8 and </span><br><span class="line">id&gt;=(select id from orders_history where type=8 limit 100000,1) </span><br><span class="line">limit 100;</span><br><span class="line">select * from orders_history where type=8 limit 100000,100;</span><br></pre></td></tr></table></figure>

<h4 id="使用id限定优化"><a href="#使用id限定优化" class="headerlink" title="使用id限定优化"></a>使用id限定优化</h4><p>这种方式假设数据表的id是连续递增的，则我们根据查询的页数和查询的记录数可以算出查询的id的范围，可以使用 id between and 来查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from orders_history where type=2 </span><br><span class="line">and id between 1000000 and 1000100 limit 100;</span><br></pre></td></tr></table></figure>

<h1 id="8-No-SQL"><a href="#8-No-SQL" class="headerlink" title="8.  No-SQL"></a>8.  No-SQL</h1><h2 id="RDBMS-的瓶颈"><a href="#RDBMS-的瓶颈" class="headerlink" title="RDBMS 的瓶颈"></a>RDBMS 的瓶颈</h2><h4 id="行存储结构"><a href="#行存储结构" class="headerlink" title="行存储结构"></a>行存储结构</h4><p>如<strong>关系型数据库是行存储结构</strong>，所以当你只想拿一行里面的几列时，从硬盘读取到内存中的数据也会是整行的数据，当数据量很大的时候，IO就吃不消了。当然是可以通过垂直分表来解决这种情况，但是垂直分表也会带来复杂性</p>
<p>还有例如头条的关注列表，如果放在关系型数据库中，那肯定就是你的id,你关注的人的id,这样一行数据保存着，然后关注的人有10个就会有10条这样的记录，然后你查看你关注的列表的时候，就需要从数据库里面查10行记录，然后组装起来返回给前端展示。</p>
<h4 id="强结构"><a href="#强结构" class="headerlink" title="强结构"></a>强结构</h4><p>强结构的意思就是<strong>关系型数据库的表结构有很强的约束，必须按照这么个格式存储，就不够灵活</strong>。所以当有新需求需要加字段的时候就需要修改表的结构，如果表的数据很多的话<strong>修改表的结构可能会长时间锁表</strong>，而导致表的不可用。</p>
<h4 id="没内存型数据库快"><a href="#没内存型数据库快" class="headerlink" title="没内存型数据库快"></a>没内存型数据库快</h4><p>例如redis,人家在内存里，咱们关系型数据库比不上它的速度。</p>
<h4 id="全文检索能力弱"><a href="#全文检索能力弱" class="headerlink" title="全文检索能力弱"></a>全文检索能力弱</h4><p>如果提供全文检索，一般关系型数据库只能like全表扫描，性能很差，虽然像mysql也有全文索引。但是我觉得术业有专攻。因为数据库的这些厂商想扩张一下他们软件的广度，他们当然想自己软件支持所有的需求，然后让大家都来用它。如果效果真的这么好的话，像elasticsearch还活的下去嘛。例如mongodb4要支持acid事务等等这类。</p>
<p>一个软件基础的设计就决定了它在一方面是优的，一方面是欠缺的。<strong>一般而言想实现本来就不属于它的领域的东西，要么会牺牲性能，要么会牺牲灵活性。</strong>所以我如下讲的是针对每个类型NoSQL的优势点，也就是它们的最强点。</p>
<h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><p>简而言之，sql不支持分布式且且有性能瓶颈且不支持分布式，不同NoSQL适合不同的场景。</p>
<h4 id="MySQL的扩展性瓶颈"><a href="#MySQL的扩展性瓶颈" class="headerlink" title="MySQL的扩展性瓶颈"></a>MySQL的扩展性瓶颈</h4><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>k-v 数据库，适用于内容缓存，主要用于处理大量数据的高访问负载等； </li>
<li>bson：文档数据库，MongoDB 是一个基于分布式文件存储的数据库，C++编写的。皆在为web应用提供可扩展的高性能数据存储解决方案。它介于关系型数据库与非关系型数据库之间的产品，是非关系型中功能最丰富的，且最像关系型数据库的； </li>
<li>列存储数据库：分布式文件系统</li>
<li>图关系型数据库 ：它不是放图的，放的是 关系：如朋友圈社交网络等。专注于关系图谱。GraphDB</li>
</ol>
<h4 id="K-V-数据库"><a href="#K-V-数据库" class="headerlink" title="K-V 数据库"></a>K-V 数据库</h4><p>全称Key-Value，这应该是我们都熟悉就像Map一样。代表数据库就是redis,redis的value还分了很多结构，例如:list、set、sorted set、hash、string等。</p>
<p><strong>它是存储在内存中的，所以速度快常用来作为缓存服务器</strong>。 而且因为<strong>它的结构导致有些操作比关系型数据库简单</strong>。</p>
<p>举个例子例如List的[LPUSHX key value]操作，将一个值插入到已存在的列表头部，列表是有序的，如果在关系型数据库中得怎么办，插入一条数据，并且将控制位置的那个字段例如叫index，设为1。那是不是还得修改本来的那些数据，把后面所有行的index值都加一，这样才能控制有序，之后删除哪条数据，还得维护修改index。操作是比较麻烦的。</p>
<p>但是它ACID事务只支持I和C也就是隔离性和一致性，<strong>不支持原子性和持久性</strong>。所以在一些对事务要求的情况下就不适合了。</p>
<h4 id="BSON"><a href="#BSON" class="headerlink" title="BSON"></a>BSON</h4><p>这个类型它的结构没有约束，可以存储任意结构,因为是文档嘛。啥意思呢，就是例如关系型数据库中规定这个表字段就两个，一个id,一个name。如果你想存个sex字段你就得修改表结构。那文档型不用，因为<strong>文档型存储的数据格式一般都是Json,Json里面的字段我任意填，无拘无束。</strong></p>
<h4 id="列式存储型"><a href="#列式存储型" class="headerlink" title="列式存储型"></a>列式存储型</h4><p>也就是按列来存储数据，关系型是按行存储。 按行存储的好处是业务可以简单的获取一行也就是多个列的数据，因为按行存储数据都是连续的，所以磁盘一次操作就读取所有列的数据。</p>
<p>但是<strong>按列的话，因为列的存储是不连续的，所以磁盘读取效率比行低</strong></p>
<p>按行存储写如果操作也是一行一起的，保证的所有列的数据要么都成功写入，要么的失败 。 如果是<strong>按列的话就有可能有些列成功，有些列失败</strong>。</p>
<p>但是在大数据统计的时候，一般就统计某一列或者某几列的数据。如果这时候是按行存储的话，那么每次从磁盘读取到内存时都会读取整行数据导致IO过大和资源的浪费。</p>
<p>所以<strong>节省I/O就采用按列存储</strong>，这样每次只需要拿想要的列进行统计。</p>
<p>代表的数据库是HBase,<strong>多用于离线的大数据分析和统计</strong>。为啥离线？上面说了写的操作可能会有问题，并且整行读的效率低，所以一般都是线上数据拷过来弄成列数据库，专门用户数据分析。</p>
<h4 id="全文检索型"><a href="#全文检索型" class="headerlink" title="全文检索型"></a>全文检索型</h4><p>这种型的数据库<strong>主要是用在传统关系型数据库在全文检索无力的情况下</strong>。因为搜索的条件很多，例如找对象在网站搜，女+170+杭州+爱吃辣+爱健身+爱旅游+28岁。来想想关系型数据库得怎么建这个索引。。。就是搜索条件的排列组合太多了。所以关系型数据库吃不消。这时候记得引入全文检索型数据库。</p>
<p><strong>全文检索引擎采用倒排索引，也就是每个单词都是索引，建立单词到文档的索引</strong>，这样满足你搜索条件的当此的结果都会快速的显示出来。</p>
<p>代表的有Elasticsearch，分布式文档存储方式。使用方式就是我们从关系数据库中导出数据，转换成Json格式然后将其输入Elasticsearch中建立索引然后使用。</p>
<p>具体Elasticsearch的东西这里不做深入分析，不然就跑题了。有需自己查找相关资料。还有虽然Elasticsearch也是面向文档的，但是人家的重点在于全文检索</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2019/12/22/network-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/22/network-interview/" itemprop="url">【面试系列】 - 计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-22T16:53:38+08:00">
                2019-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h1><h2 id="1-1-OSI七层模型"><a href="#1-1-OSI七层模型" class="headerlink" title="1.1 OSI七层模型"></a>1.1 OSI七层模型</h2><ol>
<li>应用层（Application）</li>
<li>表示层（Presentation）</li>
<li>会话层（Session）</li>
<li>传输层（Transport）</li>
<li>网络层（Network）</li>
<li>数据链路层（Data Link）</li>
<li>物理层（Physical）</li>
</ol>
<h4 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h4><p>各种应用协议，如：</p>
<ol>
<li>HTTP  超文本传输协议</li>
<li>FTP  文件传输协议</li>
</ol>
<h4 id="1-1-2-表示层"><a href="#1-1-2-表示层" class="headerlink" title="1.1.2 表示层"></a>1.1.2 表示层</h4><p>信息的语法语义以及他们的关联，如加密解密，转换翻译，压缩解压缩。</p>
<ol>
<li>TELNET   TCP/IP 终端仿真协议</li>
</ol>
<h4 id="1-1-3-会话层"><a href="#1-1-3-会话层" class="headerlink" title="1.1.3 会话层"></a>1.1.3 会话层</h4><p>不同机器上的用户之间建立和管理回话，如：</p>
<ol>
<li>SSL 安全套接字层协议</li>
<li>TLS 传输层安全协议</li>
<li>RPC 远程过程调用协议</li>
<li>SMTP  简单邮件传输协议</li>
</ol>
<h4 id="1-1-4-传输层"><a href="#1-1-4-传输层" class="headerlink" title="1.1.4 传输层"></a>1.1.4 传输层</h4><p>接受上一层的数据，在必要的时候把数据进行分割，并将这些数据交给网络层，且保证这些数据段有效的到达对端，如：</p>
<ol>
<li>Mobile IP 移动IP协议</li>
<li>TCP</li>
<li>UDP</li>
<li>TLS</li>
</ol>
<h4 id="1-1-5-网络层"><a href="#1-1-5-网络层" class="headerlink" title="1.1.5 网络层"></a>1.1.5 网络层</h4><p>控制子网的运行，如逻辑编址、分组传输、路由选择</p>
<ol>
<li>IP/IPV6</li>
<li>ICMP   internet控制报文协议</li>
<li>ARP  地域解析协议</li>
<li>RARP</li>
<li>AKP</li>
<li>UUCP</li>
</ol>
<h4 id="1-1-6-数据链路层"><a href="#1-1-6-数据链路层" class="headerlink" title="1.1.6 数据链路层"></a>1.1.6 数据链路层</h4><p>物理寻址，同时将原始比特流转变为逻辑传输线路。</p>
<ol>
<li>Ethernet</li>
<li>PPP   点对点协议，通过拨号或专线方式建立点对点连接发送数据</li>
</ol>
<h4 id="1-1-7-物理层"><a href="#1-1-7-物理层" class="headerlink" title="1.1.7 物理层"></a>1.1.7 物理层</h4><ol>
<li>IEEE 802.1.A</li>
<li>IEEE 802.2</li>
</ol>
<h2 id="1-2-五层协议"><a href="#1-2-五层协议" class="headerlink" title="1.2 五层协议"></a>1.2 五层协议</h2><ol>
<li>应用层  -  七层协议的前三层</li>
<li>运输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ol>
<h2 id="1-3-TCP-IP-四层协议"><a href="#1-3-TCP-IP-四层协议" class="headerlink" title="1.3 TCP/IP 四层协议"></a>1.3 TCP/IP 四层协议</h2><ol>
<li>应用层  -  七层协议的前三层</li>
<li>运输层</li>
<li>网络层</li>
<li>网络接口层  -  七层协议的后两层</li>
</ol>
<h2 id="1-4-数据包如何传输"><a href="#1-4-数据包如何传输" class="headerlink" title="1.4 数据包如何传输"></a>1.4 数据包如何传输</h2><p><img src="https://img-blog.csdn.net/20180115134155605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2MxOTQ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h2 id="1-5-报文，数据报，分片，分组，帧的区别"><a href="#1-5-报文，数据报，分片，分组，帧的区别" class="headerlink" title="1.5 报文，数据报，分片，分组，帧的区别"></a>1.5 报文，数据报，分片，分组，帧的区别</h2><p><strong>报文（message）</strong>：传输协议交给ip的数据称为报文；典型的报文包含一个传输层首部和应用程序数据；</p>
<p><strong>数据报（datagram）</strong>：在报文首部加上ip首部形成一个数据报；</p>
<p><strong>分片（fragment）</strong>：如果在选定网络中，数据报的长度太大，ip就会把数据报分裂成几个分片，每个分片含有它自己的ip首部和一段原来数据报的数据；</p>
<p><strong>分组（packet）：</strong>提交给数据链路层进行传送时，一个ip分片或者一个很小的无需分片的ip数据报成为分组；</p>
<p><strong>帧（frame）：</strong>数据链路层在分组前面加上它自己的首部形成帧，并发送该帧；</p>
<p><img src="http://www.linuxtcpipstack.com/wp-content/uploads/2017/10/117565-20170828104429593-312233677_%E5%89%AF%E6%9C%AC.png" alt="img"></p>
<h1 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h1><h2 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1 Overview"></a>2.1 Overview</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，他是应用层协议，为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP遵循经典的 <strong>客户端 - 服务端</strong> 模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。</p>
<p>HTTP是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TCP/IP 层，但可以在任何可靠的<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>上使用；也就是说，不像 UDP，它是一个不会静默丢失消息的协议。<a href="https://en.wikipedia.org/wiki/Reliable_User_Datagram_Protocol" target="_blank" rel="noopener">RUDP</a>——作为 UDP 的可靠化升级版本——是一种合适的替代选择。</p>
<p>HTTP是一个client-server协议：请求通过一个实体被发出，实体也就是用户代理。大多数情况下，这个用户代理都是指浏览器，当然它也可能是任何东西，比如一个爬取网页生成维护搜索引擎索引的机器爬虫。</p>
<p>每一个发送到服务器的请求，都会被服务器处理并返回一个消息，也就是<em>response。</em>在这个请求与响应之间，还有许许多多的被称为proxies的实体，他们的作用与表现各不相同，比如有些是网关，还有些是<a href="https://developer.mozilla.org/en-US/docs/Glossary/Cache" target="_blank" rel="noopener">caches</a>等。</p>
<p>实际上，在一个浏览器和处理请求的服务器之间，还有路由器、调制解调器等许多计算机。由于Web的层次设计，那些在网络层和传输层的细节都被隐藏起来了。HTTP位于最上层的应用层。虽然底层对于分析网络问题非常重要，但是大多都跟对HTTP的描述不相干。</p>
<h2 id="2-2-HTTP-的基本性质"><a href="#2-2-HTTP-的基本性质" class="headerlink" title="2.2 HTTP 的基本性质"></a>2.2 HTTP 的基本性质</h2><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><p>当客户端向服务器端发送请求时，只是简单的填写请求路径和请求方法即可，然后就可以通过浏览器或其他方式将该请求发送就行了。HTTP的报文也是可以容易读懂的，允许简单的测试</p>
<h4 id="可扩展-amp-灵活"><a href="#可扩展-amp-灵活" class="headerlink" title="可扩展 &amp; 灵活"></a>可扩展 &amp; 灵活</h4><p>在 HTTP/1.0 中出现的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP headers</a> 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。同时也允许客户端和服务器端传输任意类型任意格式的数据对象。</p>
<h4 id="无状态-有会话"><a href="#无状态-有会话" class="headerlink" title="无状态 有会话"></a>无状态 有会话</h4><p>HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p>
<p>注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。</p>
<h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。</p>
<p>为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection" target="_blank" rel="noopener"><code>Connection</code></a>头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 </p>
<p>为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议<a href="https://en.wikipedia.org/wiki/QUIC" target="_blank" rel="noopener">QUIC</a>。</p>
<h2 id="2-3-HTTP-能控制什么"><a href="#2-3-HTTP-能控制什么" class="headerlink" title="2.3 HTTP 能控制什么"></a>2.3 HTTP 能控制什么</h2><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。</p>
<h4 id="开放同源限制"><a href="#开放同源限制" class="headerlink" title="开放同源限制"></a>开放同源限制</h4><p>为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于<strong>相同来源</strong>的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。</p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用<code>Authenticate</code>相似的头部即可，或用HTTP Cookies来设置指定的会话。</p>
<h4 id="代理和隧道"><a href="#代理和隧道" class="headerlink" title="代理和隧道"></a>代理和隧道</h4><p>通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址。因此 HTTP 请求就要通过代理越过这个网络屏障。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。</p>
<h2 id="2-4-HTTP-1-1-真正的标准化"><a href="#2-4-HTTP-1-1-真正的标准化" class="headerlink" title="2.4 HTTP/1.1 - 真正的标准化"></a>2.4 HTTP/1.1 - 真正的标准化</h2><h4 id="进步"><a href="#进步" class="headerlink" title="进步"></a>进步</h4><ul>
<li>连接可以复用，节省了多次打开TCP连接加载网页文档资源的时间。</li>
<li>增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li>
<li>支持断点续传。</li>
<li>引入额外的缓存控制机制。</li>
<li>引入内容协商机制，包括语言，编码，类型等，并允许客户端和服务器之间约定以最合适的内容进行交换。</li>
<li>Host头，能够使不同域名配置在同一个IP地址的服务器上。</li>
</ul>
<h2 id="2-5-HTTP-2-0-为了更好的表现"><a href="#2-5-HTTP-2-0-为了更好的表现" class="headerlink" title="2.5 HTTP/2.0 为了更好的表现"></a>2.5 HTTP/2.0 为了更好的表现</h2><h4 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h4><ul>
<li>加入了帧的概念，二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li>
<li>这是一个复用协议，完全多路复用。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。</li>
<li>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本，降低了开销</li>
<li>HTTP/2让服务器可以将响应主动“推送”到客户端缓存中</li>
</ul>
<h2 id="2-6-HTTP-协议头（Header）"><a href="#2-6-HTTP-协议头（Header）" class="headerlink" title="2.6 HTTP 协议头（Header）"></a>2.6 HTTP 协议头（Header）</h2><h4 id="2-6-1-HTTP-数据组成"><a href="#2-6-1-HTTP-数据组成" class="headerlink" title="2.6.1 HTTP 数据组成"></a>2.6.1 HTTP 数据组成</h4><p>http数据由请求行，首部字段，空行，报文主体四个部分组成。</p>
<h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>请求方法 + 请求url + HTTP 协议及版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /chapter11/user.html HTML/1.1</span><br></pre></td></tr></table></figure>

<h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><h5 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h5><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><h4 id="2-6-2-首部字段信息解读"><a href="#2-6-2-首部字段信息解读" class="headerlink" title="2.6.2 首部字段信息解读"></a>2.6.2 首部字段信息解读</h4><p>HTTP的头域包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。</p>
<h5 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h5><p>是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部</p>
<h5 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h5><p>是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。</p>
<h5 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h5><p>便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。</p>
<h5 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h5><p>指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。</p>
<h4 id="2-6-3-常见返回状态码"><a href="#2-6-3-常见返回状态码" class="headerlink" title="2.6.3 常见返回状态码"></a>2.6.3 常见返回状态码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">200：请求被正常处理</span><br><span class="line">204：请求被受理但没有资源可以返回</span><br><span class="line">206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</span><br><span class="line">301：永久性重定向</span><br><span class="line">302：临时重定向</span><br><span class="line">303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</span><br><span class="line">304：发送附带条件的请求时，条件不满足时返回，与重定向无关</span><br><span class="line">307：临时重定向，与302类似，只是强制要求使用POST方法</span><br><span class="line">400：请求报文语法有误，服务器无法识别</span><br><span class="line">401：请求需要认证</span><br><span class="line">403：请求的对应资源禁止被访问</span><br><span class="line">404：服务器无法找到对应资源</span><br><span class="line">500：服务器内部错误</span><br><span class="line">503：服务器正忙</span><br></pre></td></tr></table></figure>

<h4 id="2-6-4-常见请求方法"><a href="#2-6-4-常见请求方法" class="headerlink" title="2.6.4 常见请求方法"></a>2.6.4 常见请求方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">GET方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</span><br><span class="line">HEAD</span><br><span class="line">HEAD方法请求一个与GET请求的响应相同的响应，但没有响应体.</span><br><span class="line">POST</span><br><span class="line">POST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </span><br><span class="line">PUT</span><br><span class="line">PUT方法用请求有效载荷替换目标资源的所有当前表示。</span><br><span class="line">DELETE</span><br><span class="line">DELETE方法删除指定的资源。</span><br><span class="line">OPTIONS</span><br><span class="line">获取服务器支持的HTTP请求方法；</span><br><span class="line">用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。</span><br></pre></td></tr></table></figure>

<h4 id="2-6-5-GET-POST-区别"><a href="#2-6-5-GET-POST-区别" class="headerlink" title="2.6.5 GET/POST 区别"></a>2.6.5 GET/POST 区别</h4><p>区别一：<br>get重点在从服务器上获取资源，post重点在向服务器发送数据；<br>区别二：<br>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；" target="_blank" rel="noopener">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；</a><br>post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；<br>区别三：<br>Get传输的数据量小，因为受URL长度限制，但效率较高；<br>Post可以传输大量数据，所以上传文件时只能用Post方式；<br>区别四：<br>GET请求返回的内容可以被浏览器缓存起来。而每次提交的<strong>POST</strong>，浏览器在你按下<strong>F5</strong>的时候会跳出确认框，浏览器不会缓存<strong>POST</strong>请求返回的内容。</p>
<p>GET 有个安全隐患在于 url 可能被服务器的 access log 记录并保存。在浏览器也能查到历史记录，但是post请求的参数都在body里面，服务器日志记录不到，浏览器历史也记录不到。前端安全上POST可能确实更好。</p>
<p>但根据RFC官方的定义，GET, HEAD, OPTIONS 和 TRACE 这几个方法是安全的。但这里的意思是GET不会改变服务端的数据，不会有副作用。关键还是在正确的地方使用GET/POST</p>
<h2 id="2-7-HTTP安全"><a href="#2-7-HTTP安全" class="headerlink" title="2.7 HTTP安全"></a>2.7 HTTP安全</h2><h4 id="2-7-1-HTTPS"><a href="#2-7-1-HTTPS" class="headerlink" title="2.7.1 HTTPS"></a>2.7.1 HTTPS</h4><p>HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS</p>
<p>HTTPS相比HTTP，在请求前多了一个「握手」的环节。在握手时，你和你想访问的网站会交换一个密钥；握手完成后，你的请求先用密钥加密才会发出去，网站服务器的响应会先用密钥加密再传给你。由于整条链路上的节点拿到的数据都是加密过的，所以他们即无法分析出源数据的内容，也无法篡改这个加密过的数据（如果一个节点篡改了加密后的数据，你和服务器都没办法用密钥解密出来，会认为数据是无效的）。</p>
<p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL/TLS层（在传输层），HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><ol>
<li>Client发起一个HTTPS的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。</li>
<li>Server把事先配置好的公钥证书（public key certificate）返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li>
<li>Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li>
<li>Server使用对称密钥加密“明文内容A”，发送给Client。</li>
<li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li>
<li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</li>
</ol>
<h5 id="为什么HTTPS-可以防御住中间人攻击"><a href="#为什么HTTPS-可以防御住中间人攻击" class="headerlink" title="为什么HTTPS 可以防御住中间人攻击"></a>为什么HTTPS 可以防御住中间人攻击</h5><p>因为中间人没有私钥，没有办法解密公钥加密的对称密码。</p>
<h5 id="和HTTP的区别"><a href="#和HTTP的区别" class="headerlink" title="和HTTP的区别"></a>和HTTP的区别</h5><ol>
<li><p>https协议需要到CA申请证书（包含公钥和私钥，因此是非对称加密），用户证书的发放是基于相关机构的。</p>
<ol>
<li><p>公钥加密，私钥解密。</p>
<p>私钥数字签名，公钥验证。</p>
</li>
</ol>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p>
</li>
<li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议</p>
</li>
<li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议</p>
</li>
</ol>
<h5 id="客户端解析证书"><a href="#客户端解析证书" class="headerlink" title="客户端解析证书"></a>客户端解析证书</h5><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>
<p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>
<h4 id="2-7-2-对称-非对称加密"><a href="#2-7-2-对称-非对称加密" class="headerlink" title="2.7.2 对称/非对称加密"></a>2.7.2 对称/非对称加密</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>双方使用的同一个密钥，既可以加密又可以解密，这种加密方法称为对称加密，也称为单密钥加密。</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>速度快，对称性加密通常在消息发送方需要加密大量数据时使用，算法公开、计算量小、加密速度快、加密效率高。</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>在数据传送前，发送方和接收方必须商定好秘钥，然后 使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘 钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<h6 id="常见的对称加密算法"><a href="#常见的对称加密算法" class="headerlink" title="常见的对称加密算法"></a>常见的对称加密算法</h6><ul>
<li>aes-128 &amp; aes-256，也就是16个字节和32个字节</li>
</ul>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>一对密钥由公钥和私钥组成（可以使用很多对密钥）。私钥解密公钥加密数据，公钥解密私钥加密数据（私钥公钥可以互相加密解密）。</p>
<p>私钥只能由一方保管，不能外泄。公钥可以交给任何请求方。</p>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><p>安全</p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>速度较慢</p>
<h6 id="常见的非对称加密算法"><a href="#常见的非对称加密算法" class="headerlink" title="常见的非对称加密算法"></a>常见的非对称加密算法</h6><ul>
<li>RSA</li>
<li>ECC</li>
</ul>
<h2 id="2-8-浏览器中输入一个URL发生什么，用到哪些协议？"><a href="#2-8-浏览器中输入一个URL发生什么，用到哪些协议？" class="headerlink" title="2.8 浏览器中输入一个URL发生什么，用到哪些协议？"></a>2.8 <strong>浏览器中输入一个URL发生什么，用到哪些协议？</strong></h2><p>浏览器中输入URL，首先浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理。如果采用https，TLS或者SSL还会被用到，先进行一次握手协商出一份对称的秘钥，然后对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<hr>
<h1 id="3-IP"><a href="#3-IP" class="headerlink" title="3. IP"></a>3. IP</h1><h2 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 Overview"></a>3.1 Overview</h2><p>IP提供的事<strong>不可靠、无连接</strong>的数据报传送服务</p>
<ul>
<li>不可靠（unreliable）的意思是它不能保证IP数据能成功的送到目的地。IP仅提供最好的传输服务，如果发生某种错误，则往往丢弃该数据报。任何要求的可靠性必须靠上层来提供（如TCP）</li>
<li>无连接（connectionless）这个术语的意思是，IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，两个独立的数据报并不保证接受的先后顺序。</li>
</ul>
<h2 id="3-2-IP地址"><a href="#3-2-IP地址" class="headerlink" title="3.2 IP地址"></a>3.2 IP地址</h2><h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><p>IP地址主要有两个功能：标识<em>主机</em>或者<em>网络</em>和寻址。IPV4 把IP地址定义为32位二进制数。通过在IP地址上添加有效位数的后缀（例如192.168.1.15/24），以<strong>CIDR</strong>（英语：Classless Inter-Domain Routing，又翻译为：<strong>无类域间路由</strong>）表示法用来指定地址的路由前缀的大小，这等效于历史上使用的子网掩码255.255.255.0。为便于使用，常以XXX.XXX.XXX.XXX形式表现，每组XXX代表小于或等于255的10进制数，该表示方法称为点分十进制。前IPv4技术可能使用的IP地址最多可有4,294,967,296个（即2^32）。据看可能觉得很难会用尽，但由于早期编码和分配上的问题，使很多区域的编码实际上被空出或不能使用。加上互联网的普及，使大部分家庭都至少有一部电脑，连同公司的电脑，以及连接网络的各种设备都消耗大量IPv4地址资源。</p>
<h4 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h4><p>IPv6地址为128位长，但通常写作8组，每组四个十六进制数的形式。如果四个数字都是0，可以被省略。例如：</p>
<ul>
<li>2001:0db8:85a3:08d3:1319:8a2e:0370:7344</li>
<li>2001:0db8:85a3::1319:8a2e:0370:7344</li>
</ul>
<h2 id="3-3-IP-首部"><a href="#3-3-IP-首部" class="headerlink" title="3.3 IP 首部"></a>3.3 IP 首部</h2><p><img src="/Users/ziliugao2/Desktop/blog/static/IPV4.png" alt="IPV4"></p>
<p>普通的IP首部长为20个字节，除非含有选项字段。</p>
<p><strong>服务类型</strong>：服务类型包括一个<em>3bit<em>的优先权字段（现已被忽略），</em>4bitTOS<em>字段和</em>1<em>位未用位但必须置为</em>0<em>。</em>4<em>位的</em>TOS<em>分别代表最小延迟、最大吞吐量、最高可靠性和最小费用。对于</em>TOS<em>值，不同应用有不同的最佳值。具体值可参考</em>RFC1394*文档</em></p>
<p><strong>总长度</strong>：数据包的总长度。该字段是<em>IP</em>首部的必要内容，因为链路层需要填充一些数据以达到最小长度。（<em>PS</em>：以太网的最小帧长为46B.</p>
<p><em>不分片位：表示该数据报是否被分片，如果被置为<em>1</em>，则不能对数据报进行分片，如果要对其进行分片处理，就应将其置为<em>0</em>。</em></p>
<p><em>更多片位：除了最后一个分片，其他每个组成数据报的片都要讲该位置为</em>1.</p>
<p><strong>*片偏移</strong>：该分片相对于原始数据报开始处位置的偏移量。*</p>
<p><strong>*生存时间</strong>：设置数据报可以经过的最多路由器数，它指定了数据报的生存时间。生存时间由源主机指定，在数据报传输过程中，每经过一个路由器，该值就减<em>1</em>，当该字段的值为<em>0</em>时，数据报就会被丢弃，并发送<em>ICMP*报文通知源主机。</em></p>
<p><strong>*协议</strong>：向<em>IP<em>层传输数据的协议类型，常见协议类型的值：*</em>表示</em></p>
<ol>
<li><p>ICMP协议表示</p>
</li>
<li><p>IGMP协议</p>
</li>
<li><p>表示TCP协议</p>
</li>
<li><p>表示UDP协议</p>
</li>
</ol>
<p>首部许校验和（checksum）：校验接收到的<em>IP</em>数据报是否有差错。</p>
<h2 id="3-4-IP-路由选择"><a href="#3-4-IP-路由选择" class="headerlink" title="3.4 IP 路由选择"></a>3.4 IP 路由选择</h2><h4 id="3-4-1-静态路由-amp-动态路由"><a href="#3-4-1-静态路由-amp-动态路由" class="headerlink" title="3.4.1 静态路由 &amp; 动态路由"></a>3.4.1 静态路由 &amp; 动态路由</h4><p>如果网络没有直接与它相连,路由器必须通过学习来了解如何到达这个远程网络。所采用的方法只有两种：</p>
<ul>
<li>静态路由方式<ul>
<li>即必须由人来手动输入所有网络位置到路由表中</li>
</ul>
</li>
<li>动态路由的方式<ul>
<li>在动态路由中，在一台路由器上运行的协议将与相邻路由器上运行的相同协议之间进行通信。然后,这些路由器会更新各自对整个网络的认识并将这些信息加入到路由表中去。如果在网络中有一个改变出现,动态路由协议将自动将这个改变通知给所有的路由器。如果使用的是静态路由,则管理员将负责通过手工方式在所有的路由器上更新所有的改变。动态路由与静态路由没有绝对的优劣之分</li>
</ul>
</li>
<li>在一个大型网络中，同时使用动态和静态路由是很典型的方式。</li>
</ul>
<h4 id="3-4-2-MAC-地址"><a href="#3-4-2-MAC-地址" class="headerlink" title="3.4.2 MAC 地址"></a>3.4.2 MAC 地址</h4><p><strong>MAC地址</strong>（<strong>英语：Media Access Control Address）</strong>，直译为<strong>媒体访问控制地址</strong>，也称为<strong>局域网地址</strong>（LAN Address），<strong>以太网地址</strong>（Ethernet Address）或<strong>物理地址</strong>（Physical Address），它是一个用来确认网络设备位置的地址。在<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>中，第三层网络层负责<a href="https://zh.wikipedia.org/wiki/IP地址" target="_blank" rel="noopener">IP地址</a>，第二层数据链接层则负责MAC地址。MAC地址用于在网络中唯一标示一个<a href="https://zh.wikipedia.org/wiki/网卡" target="_blank" rel="noopener">网卡</a>，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。</p>
<p>MAC地址共48位（6个字节），以<a href="https://zh.wikipedia.org/wiki/十六進位" target="_blank" rel="noopener">十六进制</a>表示。前24位由<a href="https://zh.wikipedia.org/wiki/IEEE" target="_blank" rel="noopener">IEEE</a>决定如何分配，后24位由实际生产该网络设备的厂商自行指定。</p>
<p>ff:ff:ff:ff:ff:ff则作为广播地址。</p>
<p>01:xx:xx:xx:xx:xx是多播地址，01:00:5e:xx:xx:xx是<a href="https://zh.wikipedia.org/wiki/IPv4" target="_blank" rel="noopener">IPv4</a>多播地址。</p>
<h4 id="3-4-3-ICMP-协议"><a href="#3-4-3-ICMP-协议" class="headerlink" title="3.4.3 ICMP 协议"></a>3.4.3 ICMP 协议</h4><p>ICMP（Internet Control Message Protocol）Internet控制报文协议。 它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。 控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。</p>
<h4 id="3-4-4-路由流程"><a href="#3-4-4-路由流程" class="headerlink" title="3.4.4 路由流程"></a>3.4.4 路由流程</h4><ol>
<li>因特网控制报文协议<strong>(lCMP)创建</strong>一个回应请求<strong>数据包</strong></li>
<li>ICMP将此包<strong>转交给IP</strong> </li>
<li>IP协议<strong>判断</strong>目的IP地址是处在本地网络中,还是处在一个远程网络上</li>
<li>这是一个远程请求,这个数据包需要被<strong>发送到默认网关</strong>（这也就是为什么要在终端上配置网关）网关(Gateway)又称网间连接器、协议转换器。 网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。 网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。</li>
<li>根据<strong>ARP缓存</strong>中的网关<strong>MAC地址</strong>，将数据进行<strong>帧</strong></li>
<li>帧到<strong>物理层</strong>以<strong>位(Bit)</strong>的形式传输</li>
<li>传输完成，<strong>校验</strong>数据，并向上<strong>解包</strong>，直到网络层</li>
<li>在<strong>路由表</strong>中检查其<strong>IP目的地址</strong></li>
<li>此路由表中必须包含有目的地址网络，<strong>否则</strong>将丢弃数据，并返回”<strong><em>\</em>destination network unavailable**</strong>“的ICMP信息，并被发送回原设备</li>
<li>数据包被交换到<strong>输出接口</strong>的缓存区</li>
<li>检查<strong>ARP缓存</strong>是否有<strong>目的地址</strong>，如果没有，则向目的主机发出ARP请求，取得地址</li>
<li>根据网关<strong>MAC地址</strong>，将数据进行<strong>帧(Frame)的封装</strong> </li>
<li>帧到<strong>物理层</strong>以<strong>位(Bit)</strong>的形式传输</li>
<li>传输完成，<strong>校验</strong>数据，并向上<strong>解包</strong>，直到网络层</li>
<li><strong>核对IP</strong>，正确后交<strong>付给ICMP</strong>，ICMP会丢弃这个数据包，产生一个新负荷来作为<strong>回应应答</strong></li>
<li><strong>创建应答</strong>，添加源方和目的方的地址、协议字段和有效负荷，此时目的方设备为主机A。然后就是经历一个<strong>相反的过程</strong>，将应答返回终端A</li>
<li>当数据包在返回源主机的途中被丢弃时,由于这是一个未知的错误,通常你将会看到“request timed out” 的信息。如果出现的错误是一个已知的错误,如假设在去往目的设各的路途中路由表内没有可用的路曲,你将会得到“destination unreachable” 的信息。根据这些信息,你可以判断问题是发生在去往目的的路上,还是在返回的途中。在这里要理解的关键问题是,即使对于一个非常大的网络,这个处理过程也将是同样的。在一个较大的互联网络中,数据包在找到目的主机之前,需要通过更多的路由器。</li>
<li>硬件地址总是保存在本地的,它们决不会跨过路由器的接口。理解这个过程是至关重要的,所以要将它刻在你的记忆中! 例如：主机A将向主机B发送出一个ARP请求，路由器将如何响应这个请求?由于MAC地址必须限定于本地网络内,路由器将用连接主机A接口的MAC地址响应这个请求,于是当主机A要发送数据包时，会将所有的数据帧发往路由接口的MAC地址。</li>
</ol>
<h2 id="3-5-子网掩码"><a href="#3-5-子网掩码" class="headerlink" title="3.5 子网掩码"></a>3.5 子网掩码</h2><p>作者：车小胖<br>链接：<a href="https://www.zhihu.com/question/56895036/answer/150953183" target="_blank" rel="noopener">https://www.zhihu.com/question/56895036/answer/150953183</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>从前有一个地主，有256间房子，地主家的门牌号码是“192.168.1”，那么他家第一间房子的门牌号码是192.168.1.0，第二间是192.168.1.1，…第256间的编号是192.168.1.255。</p>
<p>地主老了，需要把256间房子分给4个儿子，平均分配，每个儿子可以分64间。</p>
<p>请来一位先生主持公道，先生这么来操作：<br>192.168.1.0-192.168.1.63 分给大儿子<br>192.168.1.64-192.168.1.127 分给二儿子<br>192.168.1.128 -192.168.1.191 分给三儿子<br>192.168.1.192-192.168.1.255 分给四儿子</p>
<p>那如何来描述四个儿子的子网网段呢？<br>192.168.1.0/26<br>192.168.1.64/26<br>192.168.1.128/26<br>192.168.1.192/26</p>
<p><strong>/26是什么鬼？</strong><br>255.255.255.192的二进制是多少？ “<a href="tel:11111111" target="_blank" rel="noopener">11111111</a>-11111111-11111111-11”大家数数一共多少个1？不用数了，是26个1，为了简化子网掩码的表示，用/26代替255.255.255.192。</p>
<p><strong>按位与运算</strong><br>我们来看大儿子的网段192.168.1.0/26是如何得到的？</p>
<p>以大儿子的房间为例：<br>192.168.1.0-192.168.1.63</p>
<p>二进制表示：<br>192.168.1.0</p>
<p><a href="tel:11000000" target="_blank" rel="noopener">11000000</a>.<a href="tel:1010100" target="_blank" rel="noopener">1010100</a>0.00000001.00000000</p>
<p>192.168.1.63</p>
<p>11000000.10101000.00000001.00111111</p>
<p>首尾地址完全相同的是多少？<br>11000000.10101000.00000001.00</p>
<p>数数一共多少位？26位！那么用这个“192.168.1.0/26”就可以表示大儿子所有房间。</p>
<p>对照房间的门牌号码“192.168.1.199”，很显然属于四儿子的。</p>
<p>一个主机192.168.1.199/26 能否和直连主机192.168.1.200/24 通信？<strong>可以的</strong>，<strong>因为都是四儿子的房间。</strong></p>
<p>一个主机192.168.1.199/26 能否和直连主机<br>192.168.1.1/24 通信？ <strong>不可以</strong>，<strong>因为一个是大儿子的房间，一个是四儿子的房间，无法直连通信！</strong></p>
<h2 id="3-6-ICMP"><a href="#3-6-ICMP" class="headerlink" title="3.6 ICMP"></a>3.6 ICMP</h2><p>ICMP数据包由8bit的类型字段和8bit的代码字段以及16bit的校验字段再加上选项数据组成。</p>
<p>ICMP协议大致可分为两类：</p>
<ul>
<li>查询报文类型</li>
<li>差错报文类型</li>
</ul>
<h4 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h4><p>查询报文主要应用于：ping查询、子网掩码查询、时间戳查询等等。</p>
<p>上面讲到的ping命令的流程其实就对应ICMP协议查询报文类型的一种使用。在主机A构建ICMP请求数据包的时候，其ICMP的类型字段中使用的是 8 （回送请求），当主机B构建ICMP应答包的时候，其ICMP类型字段就使用的是 0 （回送应答），更多类型值参考上表。</p>
<p>对 查询报文类型 的理解可参考一下文章最开始讲的ping流程，这里就不做赘述。</p>
<h4 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h4><p>差错报文主要产生于当数据传送发送错误的时候。</p>
<p>它包括：目标不可达（网络不可达、主机不可达、协议不可达、端口不可达、禁止分片等）、超时、参数问题、重定向（网络重定向、主机重定向等）等等。</p>
<p>差错报文通常包含了引起错误的IP数据包的第一个分片的IP首部，加上该分片数据部分的前8个字节。</p>
<p>当传送IP数据包发生错误的时候（例如 主机不可达），ICMP协议就会把错误信息封包，然后传送回源主机，那么源主机就知道该怎么处理了。</p>
<p>那是不是只有遇到错误的时候才能使用 差错报文类型 呢？也不一定。</p>
<p>Traceroute 就是一个例外，Traceroute是用来侦测源主机到目标主机之间所经过路由情况的常用工具。Traceroute 的原理就是利用ICMP的规则，制造一些错误的事件出来，然后根据错误的事件来评估网络路由情况。</p>
<h1 id="4-ARP-amp-RARP"><a href="#4-ARP-amp-RARP" class="headerlink" title="4. ARP &amp; RARP"></a>4. ARP &amp; RARP</h1><h2 id="4-1-ARP（Address-Resolution-Protocol）"><a href="#4-1-ARP（Address-Resolution-Protocol）" class="headerlink" title="4.1 ARP（Address Resolution Protocol）"></a>4.1 ARP（<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocol）</h2><h4 id="4-1-1-Introduction"><a href="#4-1-1-Introduction" class="headerlink" title="4.1.1 Introduction"></a>4.1.1 Introduction</h4><p>地址解析协议，即ARP（Address Resolution Protocol），<strong>用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址</strong>。<a href="https://baike.baidu.com/item/主机/455151" target="_blank" rel="noopener">主机</a>发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个<a href="https://baike.baidu.com/item/ARP欺骗" target="_blank" rel="noopener">ARP欺骗</a>。<a href="https://baike.baidu.com/item/ARP命令" target="_blank" rel="noopener">ARP命令</a>可用于查询本机ARP缓存中IP地址和<a href="https://baike.baidu.com/item/MAC地址" target="_blank" rel="noopener">MAC地址</a>的对应关系、添加或删除静态对应关系等。</p>
<p>在网络通信中，主机和主机通信的数据包需要依据OSI模型从上到下进行数据封装，当数据封装完整后，再向外发出。所以在局域网的通信中，不仅需要源目IP地址的封装，也需要源目MAC的封装。</p>
<p>一般情况下，上层应用程序更多关心IP地址而不关心MAC地址，所以需要通过ARP协议来获知目的主机的MAC地址，完成数据封装。</p>
<h4 id="4-1-2-流程"><a href="#4-1-2-流程" class="headerlink" title="4.1.2 流程"></a>4.1.2 流程</h4><p>我们给PC1指令-“ping ip2”，这就告知了目的IP，此时PC1便有了通信需要的源目IP地址，但是PC1仍然没有通信需要的目的MAC地址。<strong>这就好比我们要寄一个快递，如果在快递单上仅仅写了收件人的姓名（IP），却没有写收件人的地址（MAC），那么这个快递就没法寄出，因为信息不完整。</strong></p>
<p>PC1和PC2进行了一次ARP请求和回复过程，通过这个交互工程，PC1便具备了PC2的MAC地址信息。</p>
<p>在真正进行通信之前，PC1还会将PC2的MAC信息放入本地的【ARP缓存表】，表里面放置了IP和MAC地址的映射信息，例如 IP2&lt;-&gt;MAC2。接下来，PC1再次进行数据封装，正式进入PING通信</p>
<p>经过上面6个步骤的处理，PC1终于把数据包发送出去了，之后便可以进行正常的通信了。看到了吧，ARP的功能和实现过程是如此的简单：它在发送方需要目标MAC地址的时及时出手，通过”一问一答”的方式获取到特定IP对应的MAC地址，然后存储到本地【<strong>ARP缓存表</strong>】，后续需要的话，就到这里查找。</p>
<p>既然是”缓存”表，意味着它有<strong>时效性</strong>，并且如果电脑或者通信设备重启的话，这张表就会<strong>清空</strong>；也就是说，如果下次需要通信，又需要进行ARP请求。在我们的windows/macos系统下，可以通过命令行”<strong>arp -a</strong>“查看具体信息</p>
<h4 id="4-1-3-广播请求-单播回应"><a href="#4-1-3-广播请求-单播回应" class="headerlink" title="4.1.3 广播请求 单播回应"></a>4.1.3 广播请求 单播回应</h4><p>ARP协议就需要采用以太网的”广播”功能：将请求包<strong>以广播的形式</strong>发送，交换机或WiFi设备（无线路由器）收到广播包时，会将此数据发给同一局域网的其他所有主机。</p>
<p>那么，什么是广播？对于初学者而言，我们只需要知道，大部分的广播包，它们有一个共同特征：<strong>二层封装时目的MAC是全f（ffff.ffff.ffff）或三层封装时目的IP是全1（255.255.255.255）</strong>。可以这样更方便的记住：目的地址最大的，就是广播。</p>
<p>根据上图我们看到，PC1发送的请求广播包同时被其他主机收到，然后PC3和PC4收到之后（发现不是问自己）则丢弃。<strong>而PC2收到之后，根据请求包里面的信息（有自己的IP地址），判断是给自己的，所以不会做丢弃动作，而是返回ARP回应包。</strong></p>
<p>简单来说，<strong>ARP请求首先有”自我介绍”，然后才是询问</strong>。这样的话，PC2在收到请求之后，就可以将PC1的IP和MAC映射信息存储在本地的【ARP缓存表】，既然知道PC1在哪里，就可以返回ARP单播回应包。</p>
<h4 id="4-1-4-ARP到底是链路层还是网络层？"><a href="#4-1-4-ARP到底是链路层还是网络层？" class="headerlink" title="4.1.4 ARP到底是链路层还是网络层？"></a>4.1.4 ARP到底是链路层还是网络层？</h4><p><strong>协议到底所属哪一层，可以从应用/功能来考虑，也可以从层次/包封装来考虑。</strong></p>
<p>以ARP协议为例，它的功能最终是获取到MAC信息，服务于链路层，从这点考虑，ARP是链路层协议；但是从层次来看，ARP基于Ethernet协议，IP协议基于Ethernet协议，它们在Ethernet协议里面有独立的Type类型，前者是0x0806，后者是0x0800，既然ARP和IP协议”平起平坐”，那么IP是网络层，ARP难道就不是网络层？</p>
<p>基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议。（此方法对于ICMP协议（网络层）同样管用）</p>
<h2 id="4-2-RARP"><a href="#4-2-RARP" class="headerlink" title="4.2 RARP"></a>4.2 RARP</h2><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p>反向地址转换协议（RARP：Reverse Address Resolution Protocol） 反向地址转换协议（RARP）允许局域网的物理机器从<a href="https://baike.baidu.com/item/网关/98992" target="_blank" rel="noopener">网关</a>服务器的 ARP 表或者缓存上请求其 IP 地址。RARP用于无盘服务器，开机后通过发送RARP包给RARP服务器，通过mac地址得到IP地址（因为无法从本地读取IP地址）</p>
<p><a href="https://baike.baidu.com/item/网络管理员/595848" target="_blank" rel="noopener">网络管理员</a>在局域网<a href="https://baike.baidu.com/item/网关/98992" target="_blank" rel="noopener">网关</a><a href="https://baike.baidu.com/item/路由器/108294" target="_blank" rel="noopener">路由器</a>里创建一个表以映射<a href="https://baike.baidu.com/item/物理地址/2129" target="_blank" rel="noopener">物理地址</a>（MAC）和与其对应的 IP 地址。当设置一台新的机器时，其 RARP 客户机程序需要向<a href="https://baike.baidu.com/item/路由器/108294" target="_blank" rel="noopener">路由器</a>上的 RARP 服务器请求相应的 IP 地址。假设在<a href="https://baike.baidu.com/item/路由表/2707408" target="_blank" rel="noopener">路由表</a>中已经设置了一个记录，RARP 服务器将会返回 IP 地址给机器，此机器就会存储起来以便日后使用。 RARP 可以使用于<a href="https://baike.baidu.com/item/以太网/99684" target="_blank" rel="noopener">以太网</a>、<a href="https://baike.baidu.com/item/光纤分布式数据接口/3004891" target="_blank" rel="noopener">光纤分布式数据接口</a>及<a href="https://baike.baidu.com/item/令牌环/986104" target="_blank" rel="noopener">令牌环</a> LAN</p>
<p>RARP以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。</p>
<h4 id="4-2-2-流程"><a href="#4-2-2-流程" class="headerlink" title="4.2.2 流程"></a>4.2.2 流程</h4><ol>
<li>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li>
<li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li>
<li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li>
<li>如果不存在，RARP服务器对此不做任何的响应；</li>
<li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li>
</ol>
<h4 id="4-2-3-每个网络有多个RARP服务器"><a href="#4-2-3-每个网络有多个RARP服务器" class="headerlink" title="4.2.3 每个网络有多个RARP服务器"></a>4.2.3 每个网络有多个RARP服务器</h4><p>RARP服务器实现的一个复杂因素是RARP请求是在硬件层上进行广播的。这意味着它们不经过路由器进行转发。为了让无盘系统在RARP服务器关机的状态下也能引导，通常在一个网络上（例如一根电缆）要提供多个RARP服务器。</p>
<p>当服务器的数目增加时（以提供冗余备份），网络流量也随之增加，因为每个服务器对每个RARP请求都要发送RARP应答。发送RARP请求的无盘系统一般采用最先收到的RARP应答（对于ARP，我们从来没有遇到这种情况，因为只有一台主机发送ARP应答）。另外，还有一种可能发生的情况是每个RARP服务器同时应答，这样会增加以太网发生冲突的概率。</p>
<h1 id="5-TCP"><a href="#5-TCP" class="headerlink" title="5. TCP"></a>5. TCP</h1><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h2><ol>
<li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li>
<li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ol>
<p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>
<hr>
<h2 id="5-2-TCP首部"><a href="#5-2-TCP首部" class="headerlink" title="5.2 TCP首部"></a>5.2 TCP首部</h2><p><img src="https://img-blog.csdn.net/20170720200127136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXJjaHlMaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<ul>
<li><p>源和目的端口（各16bits）</p>
</li>
<li><p>占16比特。用于多路复用/多路分解来自或送至上层应用的数据，端口用来标识同一台计算机的不同进程。</p>
</li>
<li><p>序列号和确认号（各32bits）</p>
</li>
<li><p>这两个字段是TCP可靠传输服务的关键部分，序列号是该报文段首字节的字节流编号(TCP把数据看成是有序的字节流，TCP隐式地对数据流的每个字节进行编号)。这样理解可能更直观，当报文被分解成多个报文段时，序列号就是报文段首字节在整个报文的偏移量。确定号指定下一个期待的字节。TCP是全双工的，假设从主机A接收到主机B的数据，则主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节序号。还没理清这两者的关系？</p>
</li>
<li><p>报头长度(4bits)</p>
<ul>
<li>以32位字长为单位。因为选项是不定长的，这就需要标识整个首部字段的长度(单位是32位字)，即5+选项个数。4位，单位是32位字，所以首部最长是15*4=60字节，即选项最长是40字节(10个选项)。</li>
</ul>
</li>
<li><p>保留（6bits）</p>
<ul>
<li>占6比特为将来的应用而保留，目前置为”0”。</li>
</ul>
</li>
<li><p>编码位<strong>（SYN、FIN、ACK、URG、PSH、RST）</strong> 6bits</p>
<ul>
<li><p><strong>URG</strong>：紧急比特。指示报文段里存在着被发送方的上层实体标记为”紧急”数据，当URG=1时，其后的紧急指针指示紧急数据在当前数据段中的位置(相对于当前序列号的字节偏移量)，TCP接收方必须通知上层实体。</p>
</li>
<li><p><strong>ACK</strong>：确认比特。当ACK=0时，表示该数据段不包含确认信息，当ACK=1时，表示该报文段包括一个对已被成功接收报文段的确认。</p>
</li>
<li><p><strong>PSH</strong>：推送比特。当PSH=1时，接收方在收到数据后立即将数据交给上层，而不是直到整个缓冲区满。</p>
</li>
<li><p><strong>RST</strong>：复位比特。用于重置一个已经混乱的连接(如主崩溃)，也可用于拒绝一个无效的数据段或者拒绝一个连接请求。一般而言，如果你得到的数据段被设置了RST位，那说明你这一端有问题了。</p>
</li>
<li><p><strong>SYN</strong>：同步比特。用于建立连接过程，在连接请求中，<strong>SYN=1和ACK=0</strong>表示该数据段没有使用<strong>捎带</strong>的确认域，而连接应答捎带一个确认，即<strong>SYN=1和ACK=1</strong>。</p>
</li>
<li><p><strong>FIN</strong>：终止比特。用于释放一个连接，表示发送方已经没有数据要传输了。此时，接收方可能继续接收数据，好在SYN和FIN数据段都有序列号，从而保证了这两种数据段以正确顺序被处理。</p>
</li>
<li><p>URG与PSH的区别：</p>
<p>两者都可理解为处理紧急数据的标志位，只是处理方法不同。URG的紧急数据仅在报文内，而PSH的紧急数据还在接收缓冲区内。</p>
<p>发送方URG有效的时候，发送的数据不用进入缓冲区而直接交付给上一层；</p>
<p>发送方PSH有效的时候，接收方收到后，发送的数据要进入缓冲区但不用等缓冲区满就交给上一层</p>
</li>
</ul>
</li>
<li><p>窗口大小（32bits）</p>
<ul>
<li>用于流控制(确保连接的任何一方都不会过快地发送过量的分组而淹没另一方)，窗口大小指定了从<strong>被确认的字节</strong>算起可以发送多少个字节。</li>
</ul>
</li>
<li><p>校验和（32bits）</p>
<ul>
<li>提供了额外可靠性，在计算检验和的时候，TCP的Checksum域设为0，如果数据域的字节数为奇数，则数据域填补一个额外的0字节。校验和<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>：将所有的16位字按1的补码形式累加起来，取累加结果的补码。因此，当接收方执行同样计算时(包括Checksum域)，结果应该是0。</li>
</ul>
</li>
<li><p>紧急指针（16bits）</p>
<ul>
<li>占16比特，参考标志字段的URG位。</li>
</ul>
</li>
<li><p><strong>选项</strong></p>
<ul>
<li>选项部分是为了适合复杂网络环境和更好地服务于应用层设计的。TCP选项最长是40字节。</li>
</ul>
</li>
<li><p>数据</p>
<ul>
<li>无任何数据的TCP段也是合法的，通常用于确认和控制信息。</li>
</ul>
</li>
</ul>
<h4 id="选项字段"><a href="#选项字段" class="headerlink" title="选项字段"></a>选项字段</h4><p>TCP选项部分很好出现在已经建立连接的会话中，只要出现在TCP连接建立阶段，即三次握手。TCP选项部分实际运用有以下几种：</p>
<p><strong>(1)最大报文传输段(MMS, Maximum Segment Size)</strong></p>
<p>用于发送发与接收方协商<strong>最大报文段长度</strong>(仅仅是净荷数据，不包括TCP首部字段)。TCP在三次握手中，每一方都会通告期望收到的MSS(MSS只出现在SYN数据包中)，如果一方不接受另一方的MSS值，则使用默认的<strong>536</strong>字节净荷数据，即主机能够接受20+536字节的TCP报文段。</p>
<p><strong>(2)窗口扩大选项(Window scaling)</strong></p>
<p>TCP报文的窗口大小字段占16位，即最大值是65535，<strong>但随着时延和带宽比较大的通信产生(如卫星通信)，需要更大的窗口满足性能和吞吐率</strong>，这就是窗口扩大选项存在的意义。</p>
<p>Windows scaling占3个字节，最后一个字节是<strong>移位值(Shift count)</strong>，即首部的窗口位数16向左移动，如移位值为14，则新的窗口最大值增大到65535*(2^14)。</p>
<p>窗口扩大选项是在TCP建立之初进行协商，如果已实现了窗口扩大，当不再需要扩大窗口时，发送<strong>移位值=0</strong>就可以恢复到原窗口大小，即65535。</p>
<p><strong>(3)选择确认选项(SACK, Selective Acknowledgements)</strong></p>
<p>考虑这样情况，主机A发送报文段12345，主机B收到135且报文无差错，<strong>SACK用来确保只重传缺少的报文段</strong>，而不是重传所有报文段。</p>
<p>SACK选项需要2个功能字节，一个用来指明使用SACK选项(SACK Permission)，另一指明这个选项占多少字节。</p>
<p>那怎么形容丢失的报文段2，说明2的左右边界分别是1、3。TCP的数据报文是有字块边界的，而这种边界是由序列号表示的。</p>
<p>最多能指明多少个字节块的边界信息呢？答案是4个。这是因为选项字段最大是40字节，去除2个功能字节，序列号是32位即4字节，并且需要左右边界，所以(40-2)/8 = 4。</p>
<p><strong>(4)时间戳选项(timestamps)</strong></p>
<p>时间戳选项用来计算往返时间RTT，发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方将该时间戳字段的值复制到确认报文中，当接收方收到确认报文，对比确认报文的时间戳(等于发送方发送报文段的时间戳)和现在的时钟，即可算出RTT。</p>
<p>时间戳选项还可用于防止回绕序号PAWS。序列号只有32位，每2^32个序列号就会回绕(想想环形队列)，采用时间戳选项很容易区分相同序列号的报文段。</p>
<p><strong>(5)NOP(NO-Operation)</strong></p>
<p>TCP的首部必须是4字节的倍数，而大多数选项不是4字节倍数，不足的用NOP填充。除此之外，NOP也用于分割不同的选项数据，如窗口扩大选项和SACK之间使用NOP隔离(下面的实例将看到这一点)。</p>
<h2 id="5-3-三次握手-和-四次挥手"><a href="#5-3-三次握手-和-四次挥手" class="headerlink" title="5.3 三次握手 和 四次挥手"></a>5.3 三次握手 和 四次挥手</h2><h3 id="5-3-1-三次握手（建立连接）"><a href="#5-3-1-三次握手（建立连接）" class="headerlink" title="5.3.1 三次握手（建立连接）"></a>5.3.1 三次握手（建立连接）</h3><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p>
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>
<ul>
<li><p>第一次握手(SYN=1, seq=x)</p>
<ul>
<li>客户端执行<code>connect()</code>发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</li>
<li>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li>
</ul>
</li>
<li><p>第二次握手(SYN=1, ACK=1, seq=y, ACK=x+1):</p>
<ul>
<li>服务器执行<code>listen()</code>发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
</ul>
</li>
<li><p>第三次握手(ACK=1，ACKnum=y+1)</p>
<ul>
<li>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</li>
<li>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>
</ul>
</li>
</ul>
<p>  三次握手的过程的示意图如下：</p>
<p>  <img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png" alt="three-way-handshake"></p>
<h3 id="5-3-2-为什么是三次握手不是两次"><a href="#5-3-2-为什么是三次握手不是两次" class="headerlink" title="5.3.2 为什么是三次握手不是两次"></a>5.3.2 为什么是三次握手不是两次</h3><h4 id="为什么不是两次"><a href="#为什么不是两次" class="headerlink" title="为什么不是两次"></a>为什么不是两次</h4><ol>
<li>A 发送同步信号<strong>SYN</strong> + Seq Number</li>
<li>B 发送同步信号SYN + Seq Number + ACK + ACKnum</li>
</ol>
<p>这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。<strong>但是</strong>B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，<strong>A和B就B的初始序列号将无法达成一致。</strong></p>
<p>有童鞋会说，如果A发给B的确认丢了，该如何？A会超时重传这个ACK吗？不会！<strong>TCP不会为没有数据的ACK超时重传</strong>。</p>
<p>那该如何是好？<strong>B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</strong></p>
<h4 id="为什么不是四次"><a href="#为什么不是四次" class="headerlink" title="为什么不是四次"></a>为什么不是四次</h4><ol>
<li>A 发送同步信号<strong>SYN</strong> + <strong>A’sInitial sequence number</strong></li>
<li>B 确认收到A的同步信号，并记录A’s ISN 到本地，命名 B’s ACK sequence number</li>
<li>B发送同步信号<strong>SYN</strong> + <strong>B’s Initial sequence number</strong> </li>
<li>A确认收到B的同步信号，并记录B’s ISN 到本地，命名 <strong>A’s ACK sequence number</strong></li>
</ol>
<p>很显然1.2和1.3 这两个步骤可以合并，<strong>只需要三次握手，</strong>可以提高连接的速度与效率。</p>
<h4 id="TCP-三次握手阶段的可靠性保证（丢失重传）"><a href="#TCP-三次握手阶段的可靠性保证（丢失重传）" class="headerlink" title="TCP 三次握手阶段的可靠性保证（丢失重传）"></a>TCP 三次握手阶段的可靠性保证（丢失重传）</h4><ul>
<li><strong>A发给B的SYN 中途被丢，没有到达B</strong><ul>
<li>A会周期性超时重传，直到收到B的确认</li>
</ul>
</li>
<li><strong>即B发给A的SYN +ACK 中途被丢，没有到达A</strong><ul>
<li>B会周期性超时重传，直到收到A的确认</li>
</ul>
</li>
<li><strong>即A发给B的ACK 中途被丢，没有到达B</strong><ul>
<li>A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态。A不会超时重传，因为ATCP不会为没有数据的ACK超时重传。</li>
<li>假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包</li>
<li>假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data</li>
<li>假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-数据传输"><a href="#5-3-3-数据传输" class="headerlink" title="5.3.3 数据传输"></a>5.3.3 数据传输</h3><ol>
<li>客户端发送一个一个字节的数据，因此序列号为x+1；</li>
<li>服务端发送一个应答包，应答号为x+2，告诉客户端下次从x+2开始发；</li>
</ol>
<p><img src="https://www.polarxiong.com/usr/uploads/2017/04/3086068925.png" alt="tcp"></p>
<h3 id="5-3-4-四次挥手-amp-amp-为什么四次"><a href="#5-3-4-四次挥手-amp-amp-为什么四次" class="headerlink" title="5.3.4 四次挥手 &amp;&amp; 为什么四次"></a>5.3.4 四次挥手 &amp;&amp; 为什么四次</h3><p>确保数据能够完成传输。</p>
<p>但关闭连接时，当收到对方的<em>FIN</em>报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭<em>SOCKET,</em>也即你可能还需要发送一些数据给对方之后，再发送<em>FIN</em>报文给对方来表示你同意现在可以关闭连接了，所以它这里的<em>ACK</em>报文和<em>FIN</em>报文多数情况下都是分开发送的。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p>
<ul>
<li><p>第一次挥手(FIN=1，seq=x)</p>
<ul>
<li><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>
<p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p>
</li>
</ul>
</li>
<li><p>第二次挥手(ACK=1，ACKnum=x+1)</p>
<ul>
<li><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>
<p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p>
</li>
</ul>
</li>
<li><p>第三次挥手(FIN=1，seq=y)</p>
<ul>
<li>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</li>
<li>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</li>
</ul>
</li>
<li><p>第四次挥手(ACK=1，ACKnum=y+1)</p>
<ul>
<li><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p>
<p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p>
</li>
</ul>
</li>
</ul>
<p>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
<p>TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。</p>
<p><img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png" alt="four-way-handshake"></p>
<h2 id="5-4-TCP相关技术"><a href="#5-4-TCP相关技术" class="headerlink" title="5.4 TCP相关技术"></a>5.4 TCP相关技术</h2><h3 id="5-4-1-TCP重发机制"><a href="#5-4-1-TCP重发机制" class="headerlink" title="5.4.1 TCP重发机制"></a>5.4.1 TCP重发机制</h3><h4 id="Acknowledgement-of-delay"><a href="#Acknowledgement-of-delay" class="headerlink" title="Acknowledgement of delay"></a>Acknowledgement of delay</h4><p>通常TCP在收到数据的时候不会立刻发送一个ACK确认，它会延迟发送，可以和对方需要的数据一起发送（数据捎带ACK）或者是等待第二个数据来了直接回复第二个ACK，通常的实现采用的延迟是200ms(就是说它会等待200ms有没有数据一起发送)</p>
<h4 id="Nagle"><a href="#Nagle" class="headerlink" title="Nagle"></a>Nagle</h4><p>在数据传输过程中，通常会遇到一些小分组的传输（比如 41 bit的数据分组，除去TCP首部和IP首部真正传输的数据只有1 bit），这里的小分组指的是报文长度小于MSS(Max Segment Size)长度的分组，像这种小分组多的话，在网络上传输就加大了造成网络拥塞的可能。为了提传输效率，所以提出了Nagle算法。<br> 这个算法要求一个TCP连接最多只能有一个未被确认的未完成的小分组，在该分组到达之前不能发送其他的小分组。然后，TCP会收集这些小分组，并在确认到来时以一个分组的方式发送出去，这样就可以有效的减少了小分组。 在一些实时性要求比较高的场景下，采用了Nagle算法会让用户感觉到时延，所以我们可以选择关闭Nagle算法，Socket API 可以用 TCP_NODELAY 选项来关闭，nginx上的 tcp_nodely也是采用的这个系统调用。</p>
<h4 id="Retransmission"><a href="#Retransmission" class="headerlink" title="Retransmission"></a>Retransmission</h4><p>TCP为了保证数据不丢失所采用的重传策略。 TCP超时重传比较严重，它表示已经超时了还没有收到数据确认的回复，所以他会进入到慢启动，而快速重传则不用。<br> TCP超时重传：TCP发送方首先会维护一个TCP的重传定时器(有的也叫超时时间RTO)，这个定时器是根据往返时间（RTT）进行计算，具体算法的实现可以参考 <a href="https://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC 6298</a>，当RTO到了还没有收到数据的确认，那么TCP就认为数据已经丢失了。TCP会重传数据，接着进入到拥塞控制里的慢启动（关于拥塞控制会在后面讲）。<br> TCP快速重传：<strong>它主要是收到了三个重复的ACK后</strong>（接受方如果收到的数据是乱序的。它会重发自己最近接收到的正确顺序的ACK）进行重传，因为收到重复的ACK代表数据已经发送过去了，其中的一个数据可能因为其他原因（如数据传输中换了比较远的路由，或者是数据干脆直接丢了）造成数据没有收到。所以这个情况不算太严重，它不会进入到慢启动，它会进入到快速恢复。<br> TCP 在收到连续重复ACK后会重传最后顺序确认包的下一个，这样原先已经正确传输的包可能会重复发送，降低了TCP性能。为改善这种情况，发展出SACK（Selective Acknowledgement）技术，使用SACK选项可以告知发包方收到了哪些数据，发包方收到这些信息后就会知道哪些数据丢失，然后立即重传丢失的部分。</p>
<h3 id="5-4-2-TCP的窗口滑动"><a href="#5-4-2-TCP的窗口滑动" class="headerlink" title="5.4.2 TCP的窗口滑动"></a>5.4.2 TCP的窗口滑动</h3><p>TCP在双方数据传输的过程中，都会维护一个窗口，它代表了我还可以接受的数据的大小。如果接收方窗口大小为0，发送方就会停止发送。之所以叫滑动窗口（Sliding Window）是因为它是动态可变的，不是固定的（张开、合拢、收缩）。它保证了数据的可靠传递、它确保数据按顺序传递、并且它强制发送者之间的流量控制。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/8/169fb10212cec833?imageslim" alt="img"></p>
<p>上图中我们可以看到：<br> 发送端的LastByteAcked指向了接收端最后一次顺序ACK的位置，LastByteSent指向了发送出的数据，但是还没有收到确认ACK。<br> 接收端的NextByteExpected指向了已经收到的最后一个连续数据，LastByteAcked指向了接收到的最后一个数据，其中的空白代表还未收到的数据。<br> 下面看一张滑动窗口的示意图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/8/169fb10317b2e09e?imageslim" alt="img"></p>
<p>SND.UNA：已发送但尚未确认的数据的第一个字节的序列号。 这标志着传输类别＃2的第一个字节; 所有先前的序列号都是指传输类别＃1中的字节。<br> SND.NXT：要发送到另一个设备（在这种情况下是服务器）的下一个数据字节的序列号。 这标志着传输类别＃3的第一个字节。<br> SND.WND：发送窗口的大小。 回想一下，窗口指定任何设备在任何时候都可能具有“未完成”（ 未确认 ）的总字节数。 因此，添加第一个未确认字节（ SND.UNA ）和发送窗口（SND.WND ）的序列号标记发送类别＃4的第一个字节。 SND.UNA：已经发送但是尚未确认的 SND.NXT：将要发送的 SND.WND：发送窗口的大小 #1 表示已经确认过的数据，所以窗口右移，黑色代表窗口大小。<br> #2 表示已经发送的，但是还没有收到确认。<br> #3 表示还没有发送的，接受方可以接收的数据。<br> #4 表示不能发送的数据，接收方不能接收的数据。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/8/169fb10675f6d119?imageslim" alt="img"></p>
<h4 id="糊涂窗口"><a href="#糊涂窗口" class="headerlink" title="糊涂窗口"></a>糊涂窗口</h4><p>我们看到了TCP通过让<strong>接收方</strong>指明窗口来进行流量控制，这将有效的组织发送方放松数据，直到窗口变为非0为止。但是其中会遇到一个问题，就是接收方发送的的的窗口更新数据丢失，这样会让发送方进入到无限等待状态，因为他要等待窗口更新为非0。为了解决这个问题TCP采用了<strong>坚持定时器（persist timer）</strong>去探测窗口更新。 这样又会导致一种被称为“糊涂窗口综合症SWS (Silly Window Syndrome）”的状况。如果发生这种情况，则少量的数据将通过连接进行交换，而不是满长度的报文段。<br> 该现象可发生在两端中的任何一段，接受方可以通告一个小的窗口（而不是一直等待有大的窗口才通告），发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的数据段）。可以在任何一端采取避免SWS的现象。</p>
<ol>
<li>接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间的一半，不论实际有多少。</li>
<li>发送方避免出现糊涂窗口综合症的措施是只有以下条件之一满足时才发送数据：<ol>
<li>可以发送一个满长度的报文段；</li>
<li>可以发送至少是接收方通告窗口大小一半的报文段；</li>
<li>可以发送任何数据并且不希望接收ACK（也就是说，我们没有还未被确认的数据）或者该连接上不能使用Nagle算法。</li>
</ol>
</li>
</ol>
<h3 id="5-4-3-TCP的拥塞控制"><a href="#5-4-3-TCP的拥塞控制" class="headerlink" title="5.4.3 TCP的拥塞控制"></a>5.4.3 TCP的拥塞控制</h3><p>TCP不仅可以可以控制端到端的数据传输，还可以对网络上的传输进行监控。这使得TCP非常强大智能，它会根据网络情况来调整自己的收发速度。网络顺畅时就可以发的快，拥塞时就发的相对慢一些。拥塞控制算法主要有四种：慢启动，拥塞避免，快速重传和快速恢复。</p>
<h4 id="慢启动和拥塞避免"><a href="#慢启动和拥塞避免" class="headerlink" title="慢启动和拥塞避免"></a>慢启动和拥塞避免</h4><p>min(cwnd, rwnd)</p>
<p>慢启动和拥塞避免算法必须被<strong>TCP发送端</strong>用来控制正在向网络输送的数据量。为了 实现这些算法，必须向TCP每连接状态加入两个参量。拥塞窗口（cwnd）是对发送端收到确认（ACK）之前能向网络传送的最大数据量的一个发送端限制，<strong>接收端</strong>通知窗口（rwnd）是对 未完成数据量的接收端限制。cwnd和rwnd的最小值决定了数据传送。 另一个状态参量，慢启动阀值（ssthresh），被用来确定是用慢启动还是用拥塞避免 算法来控制数据传送。 在不清楚环境的情况下向网络传送数据，要求TCP缓慢地探测网络以确定可用流量，避免突然传送大量数据而使网络拥塞。在开始慢启动时cwnd为1，每收到一个用于确认新数据的ACK至多增加SMSS（SENDER MAXIMUM SEGMENT SIZE）字节。 慢启动算法在cwnd&lt;ssthresh时使用，拥塞避免算法在cwnd&gt;ssthresh时使用。当cwnd和ssthresh相等时，发送端既可以使用慢启动也可以使用拥塞避免。 当拥塞发生时，ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。如果是超时重传，cwnd被设置为1个报文段（这就是慢启动，其实慢启动也不慢，它是指数性增长，只是它的起始比较低）当达到ssthresh时，进入拥塞避免算法（拥塞避免是线性增长）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/8/169fb1080e36e3ce?imageslim" alt="img"></p>
<p>在该图中我们可以清楚的看到，ssthresh最初等于8 MSS 。 拥塞窗口在慢启动期间以指数方式快速上升并在第三次传输时达到ssthresh。 然后，拥塞窗口线性地爬升，直到发生丢失（超时），就在发送7之后。当发生丢失时，拥塞窗口是12 MSS 。 然后将ssthresh设置为6 MSS并且将cwnd设置为1，并且该过程继续。</p>
<h4 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h4><p>当接收端收到一个顺序混乱的数据，它应该立刻回复一个重复的ACK。这个ACK的目的是通知发送端收到了一个顺序紊乱的数据段，以及期望的序列号。发送端收到这个重复的ACK可能有多种原因，可能丢失或者是网络对数据重新排序等。在收到三个重复ACK之后（包含第一次收到的一共四个同样的ACK），TCP不等重传定时器超时就重传看起来已经丢失（可能数据绕路并没有丢失）的数据段。因为这个在网络上并没有超时重传那么恶劣，所以不会进入慢启动，<strong>而进入快速恢复</strong>。快速恢复首先会把ssthresh减半(一般还会四舍五入到数据段的倍数)，然后cwnd=ssthresh+收到重复ACK报文段累计的大小。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/8/169fb1094686172d?imageslim" alt="img"></p>
<p>这个图上我们可以看出，在三次重复ACK后cwnd并没有进入到慢启动，而是进入到了快速重传。在第二段超时重传时，进入到了慢启动cwnd置1。</p>
<p>本节转载来源：</p>
<p>作者：今晚打老虎吗<br>链接：<a href="https://juejin.im/post/5caac4586fb9a05e6668bbba" target="_blank" rel="noopener">https://juejin.im/post/5caac4586fb9a05e6668bbba</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="5-5-TCP的C-S模型，用到哪些函数"><a href="#5-5-TCP的C-S模型，用到哪些函数" class="headerlink" title="5.5 TCP的C/S模型，用到哪些函数"></a>5.5 TCP的C/S模型，用到哪些函数</h2><h4 id="5-5-1-服务器端"><a href="#5-5-1-服务器端" class="headerlink" title="5.5.1 服务器端"></a>5.5.1 服务器端</h4><h5 id="创建套接字socket"><a href="#创建套接字socket" class="headerlink" title="创建套接字socket()"></a>创建套接字socket()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>; 　　　</span><br><span class="line"> 　　 　返回：非负描述字－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

<p>第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF_INET(IPv4协议)和AF_INET6(IPv6协议)；第二个参数指明套接口类型，有三种类型可选：SOCK_STREAM(字节流套接口)、SOCK_DGRAM(数据报套接口)和SOCK_RAW(原始套接口)；如果套接口类型不是原始套接口，那么第三个参数就为0。</p>
<h5 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * server, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"> 返回：<span class="number">0</span>－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

<p>把一个套接字地址（本机IP和端口号）绑定到创建的套接字上。绑定套接字时可以选择指定IP地址和端口，也可以不指定。通配的IP地址用INADDR_ANY表示，通配的端口用0表示，通配的情况下由内核为其指定相应的IP地址和端口号。<br>对于客户端可以绑定套接字，但是一般不需要，因为客户端的端口号只是临时的，由内核来分配更合理。但是对服务器而言，一般要使用知名端口号，如果不进行绑定，客户端不知道目的端口号，连接不能完成。</p>
<h5 id="监听listen"><a href="#监听listen" class="headerlink" title="监听listen()"></a>监听listen()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>

<h5 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h5><p>accept函数从已完成连接的队列中取走一个套接字，如果该队列为空，则accept函数阻塞。accept函数的返回值称为已连接套接字，已连接的套接字就建立一个完整的TCP连接，源IP地址，源端口号，目的IP地址，目的端口号都是唯一确定了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; 　　 　 　 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *client, <span class="keyword">socklen_t</span> * addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="read-函数用于数据的接收"><a href="#read-函数用于数据的接收" class="headerlink" title="read() 函数用于数据的接收"></a>read() <strong>函数用于数据的接收</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; 　　 　 　 　</span><br><span class="line"> int read(int sockfd, char *buf, intlen); 　</span><br><span class="line">  回：非负－－－成功　　　-1－－－失败</span><br></pre></td></tr></table></figure>

<h5 id="write-函数用于数据的发送"><a href="#write-函数用于数据的发送" class="headerlink" title="write() 函数用于数据的发送"></a>write() <strong>函数用于数据的发送</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; 　　 　 　 　</span><br><span class="line"> int write(int sockfd, char *buf, int len);　</span><br><span class="line">  回：非负－－－成功　　　-1－－－失败</span><br></pre></td></tr></table></figure>

<p>send和recv函数：TCP套接字提供了send()和recv()函数，用来发送和接收操作。这两个函数与write()和read()函数很相似，只是多了一个附加的参数。</p>
<h5 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt; sys/socket.h &gt; 　　 　 　 　</span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>

<h5 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt; sys/socket.h &gt; 　　 　 　 　</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>

<h5 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h5><p>close函数关闭套接字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int sockfd);</span><br></pre></td></tr></table></figure>

<h4 id="5-5-2-TCP-客户端"><a href="#5-5-2-TCP-客户端" class="headerlink" title="5.5.2 TCP 客户端"></a>5.5.2 TCP 客户端</h4><h5 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h5><p>创建套接字</p>
<h5 id="connect-创建连接"><a href="#connect-创建连接" class="headerlink" title="connect() 创建连接"></a>connect() 创建连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;　　 　 　</span><br><span class="line">int connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<h5 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h5><h5 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h5><h2 id="5-6-TCP的适用场景"><a href="#5-6-TCP的适用场景" class="headerlink" title="5.6 TCP的适用场景"></a>5.6 TCP的适用场景</h2><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<ul>
<li>浏览器HTTP</li>
<li>邮件的SMTP</li>
<li>SSH/TELNET</li>
<li>QQ文件传输</li>
</ul>
<h1 id="6-UDP"><a href="#6-UDP" class="headerlink" title="6. UDP"></a>6. UDP</h1><h2 id="6-1-Overview"><a href="#6-1-Overview" class="headerlink" title="6.1 Overview"></a>6.1 Overview</h2><p>UDP是User Datagram Protocol的简称，中文名是用户数据报协议，是OSI参考模型中的传输层协议，它是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 </p>
<p>UDP传输与IP传输非常类似。你可以将UDP协议看作IP协议暴露在传输层的一个接口。UDP协议同样以数据包的方式传输，它的传输方式也是”Best Effort”的，所以UDP协议也是不可靠的。</p>
<p>那么，我们为什么不直接使用IP协议而要额外增加一个UDP协议呢？ 一个重要的原因是IP协议中并没有端口(port)的概念。IP协议进行的是IP地址到IP地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用</p>
<p>一个端口就代表了这样的一个通信通道。</p>
<p>UDP只在IP的数据报服务之上增加了一点的功能，这就是复用和分用的功能以及差错检测的功能，UDP的主要特点是：</p>
<ul>
<li>UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表</li>
<li>UDP是面向报文（message）的。发送方的UDP对应程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文既不合并也不拆分，而是保留这些报文的边界。</li>
<li>UDP没有拥塞控制</li>
<li>UDP支持一对一，一对多，多对一和多对多交换通信。</li>
<li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li>
</ul>
<h2 id="6-2-Header"><a href="#6-2-Header" class="headerlink" title="6.2 Header"></a>6.2 Header</h2><p><img src="https://www.linuxidc.com/upload/2018_09/180924145972611.jpg" alt="img"></p>
<p>如果接收方UDP发现收到的报文中的目的端口号不正确，就会丢弃改报文，并由网际控制协议ICMP发送“端口不可达”差错报文给发送方。</p>
<p>ICMP应用Traceroute,就是让发送的UDP用户数据报故意使用一个非法的UDP端口，结果ICMP返回“端口不可达”差错报文，因而达到了测试的目的。</p>
<ul>
<li>在目的端口后面是长度固定的以字节为单位的报文长度域，用来指定UDP数据报包括数据部分的长度，长度最小值为8byte。</li>
<li>首部剩下地16bit是用来对首部和数据部分一起做校验和（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。</li>
<li>UDP和TCP的校验和都覆盖到了他们的首部和数据，而之前介绍的IP首部的校验和只覆盖了IP首部。</li>
</ul>
<h2 id="6-2-5-端口Port和Socket"><a href="#6-2-5-端口Port和Socket" class="headerlink" title="6.2.5 端口Port和Socket"></a>6.2.5 端口Port和Socket</h2><p>端口(port)是伴随着传输层诞生的概念。它可以将网络层的IP通信分送到各个通信通道。UDP协议和TCP协议尽管在工作方式上有很大的不同，但它们都建立了从一个端口到另一个端口的通信。</p>
<p>随着我们进入传输层，我们也可以调用操作系统中的API，来构建socket。Socket是操作系统提供的一个编程接口，它用来代表某个网络通信。应用程序通过socket来调用系统内核中处理网络协议的模块，而这些内核模块会负责具体的网络协议的实施。这样，我们可以让内核来接收网络协议的细节，而我们只需要提供所要传输的内容就可以了，内核会帮我们控制格式，并进一步向底层封装。因此，在实际应用中，我们并不需要知道具体怎么构成一个UDP包，而只需要提供相关信息(比如IP地址，比如端口号，比如所要传输的信息)，操作系统内核会在传输之前会根据我们提供的相关信息构成一个合格的UDP包(以及下层的包和帧)。</p>
<p><img src="https://www.linuxidc.com/upload/2018_09/180924145972612.jpg" alt="img"></p>
<h2 id="6-3-UDP的使用场景"><a href="#6-3-UDP的使用场景" class="headerlink" title="6.3 UDP的使用场景"></a>6.3 UDP的使用场景</h2><p>对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p>
<ul>
<li>游戏</li>
<li>语音/视频通话</li>
<li>直播</li>
<li>小文件传输</li>
</ul>
<h2 id="6-4-如何实现可靠UDP"><a href="#6-4-如何实现可靠UDP" class="headerlink" title="6.4 如何实现可靠UDP"></a>6.4 如何实现可靠UDP</h2><p>即通过UDP实现类似TCP的可靠性</p>
<p>KCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。本文传输协议之考虑UDP的情况。</p>
<p>比较两者的区别主要应该是说TCP比UDP多了什么？</p>
<p><strong>面向连接</strong>：TCP接收方与发送方维持了一个状态（建立连接，断开连接），双方知道对方还在。<br><strong>可靠的</strong>：发送出去的数据对方一定能够接收到，而且是按照发送的顺序收到的。<br><strong>流量控制与拥塞控制</strong>：TCP靠谱通过滑动窗口确保，发送的数据接收方来得及收。<strong>TCP无私</strong>，发生数据包丢失的时候认为整个网络比较堵，自己放慢数据发送速度。</p>
<ul>
<li>1、添加seq/ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
<p>UDP本身是不可靠的，所以需要额外信息来保证传输数据的可靠性。因此，我们需要在传输的数据上增加一个包头。用于确保数据的可靠、有序。</p>
<p>再加上TCP式的超时重传、流量控制和拥堵控制。</p>
<p>conv:连接号。UDP是无连接的，conv用于表示来自于哪个客户端。对连接的一种替代<br>cmd:命令字。如，IKCP_CMD_ACK确认命令，IKCP_CMD_WASK接收窗口大小询问命令，IKCP_CMD_WINS接收窗口大小告知命令，<br>frg:分片，用户数据可能会被分成多个KCP包，发送出去<br>wnd:接收窗口大小，发送方的发送窗口不能超过接收方给出的数值<br>ts:时间序列<br>sn:序列号<br>una:下一个可接收的序列号。其实就是确认号，收到sn=10的包，una为11<br>len：数据长度<br>data:用户数据</p>
<h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><h2 id="7-1-RPC"><a href="#7-1-RPC" class="headerlink" title="7.1 RPC"></a>7.1 RPC</h2><p>先回答第一个问题：<code>什么是RPC框架</code>？ 如果用一句话概括RPC就是：远程调用框架（Remote Procedure Call）</p>
<p>那什么是<code>远程调用</code>？</p>
<p>通常我们调用一个php中的方法，比如这样一个函数方法: localAdd(10, 20)，localAdd方法的具体实现要么是用户自己定义的，要么是php库函数中自带的，也就说在localAdd方法的代码实现在本地，它是一个本地调用！</p>
<p><code>远程调用</code>意思就是：被调用方法的具体实现<code>不在</code>程序运行本地，而是在别的某个远程地方。</p>
<p><strong>远程过程调用带来的新问题</strong></p>
<p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：</p>
<ol>
<li><strong>Call ID映射</strong>。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li>
<li><strong>序列化和反序列化</strong>。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li>
<li><strong>网络传输</strong>。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</li>
</ol>
<p>作者：洪春涛<br>链接：<a href="https://www.zhihu.com/question/25536695/answer/221638079" target="_blank" rel="noopener">https://www.zhihu.com/question/25536695/answer/221638079</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="7-1-1-远程调用原理"><a href="#7-1-1-远程调用原理" class="headerlink" title="7.1.1 远程调用原理"></a>7.1.1 远程调用原理</h3><p>比如 A (client) 调用 B (server) 提供的<code>remoteAdd</code>方法：</p>
<ol>
<li>首先A与B之间建立一个TCP连接；</li>
<li>然后A把需要调用的方法名（这里是remoteAdd）以及方法参数（10， 20）序列化成字节流发送出去；</li>
<li>B接受A发送过来的字节流，然后反序列化得到目标方法名，方法参数，接着执行相应的方法调用（可能是localAdd）并把结果30返回；</li>
<li>A接受远程调用结果,输出30。</li>
</ol>
<p><strong>RPC框架就是把这几点些细节给封装起来，给用户暴露简单友好的API使用</strong>。</p>
<h3 id="7-1-2-远程调用的好处"><a href="#7-1-2-远程调用的好处" class="headerlink" title="7.1.2 远程调用的好处"></a>7.1.2 远程调用的好处</h3><p><strong>解耦</strong>：当server需要对方法内实现修改时，client完全感知不到，不用做任何变更；这种方式在跨部门，跨公司合作的时候经常用到，并且方法的提供者我们通常称为：服务的暴露。</p>
<h3 id="7-1-3-RPC和Socket的区别"><a href="#7-1-3-RPC和Socket的区别" class="headerlink" title="7.1.3 RPC和Socket的区别"></a>7.1.3 RPC和Socket的区别</h3><p>RPC（远程过程调用）采用客户机/服务器模式实现两个进程之间相互通信。socket是RPC经常采用的通信手段之一，RPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。除了Socket，RPC还有其他的通信方法，比如：http、操作系统自带的管道等技术来实现对于远程程序的调用。微软的Windows系统中，RPC就是采用命名管道进行通信。</p>
<h3 id="7-1-4-RPC和REST的区别"><a href="#7-1-4-RPC和REST的区别" class="headerlink" title="7.1.4 RPC和REST的区别"></a>7.1.4 RPC和REST的区别</h3><p>通过了解RPC后，我们知道是RPC是client/server模式的，调用远程的方法，REST也是我们熟悉的一套API调用协议方法，它也是基于client/server模式的，调用远程的方法的，那他俩又有啥区别呢？</p>
<p>REST API 和 RPC 都是在 <code>Server端</code> 把一个个函数封装成接口暴露出去，以供 <code>Client端</code> 调用，不过 REST API 是基于<code>HTTP协议</code>的，REST致力于通过http协议中的POST/GET/PUT/DELETE等方法和一个可读性强的URL来提供一个http请求。而 RPC 则可以不基于 HTTP协议<br>因此，如果是后端两种语言互相调用，用 RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西），应该也更容易配置。如果是前端通过 AJAX 调用后端，那么用 REST API 的形式比较好（因为无论如何也避不开 HTTP 这道坎）。</p>
<h2 id="7-2-Ping"><a href="#7-2-Ping" class="headerlink" title="7.2 Ping"></a>7.2 Ping</h2><p>ping 程序是用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。ping 使用的是ICMP协议。</p>
<p>ping命令是ICMP 回送请求和回答报文的一个应用。它发送icmp回送请求消息给目的主机。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。</p>
<ol>
<li>ping命令会先发送一个 ICMP Echo Request给对端</li>
<li>对端接收到之后, 会返回一个ICMP Echo Reply</li>
<li>若没有返回，就是超时了，会认为指定的网络地址不存在。</li>
</ol>
<p>TTL(time to live)生存时间，就是一条域名解析记录在DNS服务器中的存留时间。当各地的DNS服务器接受到解析请求时，就会向域名指定的NS服务器(权威域名服务器）发出解析请求从而获得解析记录；在获得这个记录之后，记录会在DNS服务器(各地的缓存服务器，也叫递归域名服务器）中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向NS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值</p>
<h2 id="Ping命令后发生了什么"><a href="#Ping命令后发生了什么" class="headerlink" title="Ping命令后发生了什么"></a>Ping命令后发生了什么</h2><h4 id="在同一网段内"><a href="#在同一网段内" class="headerlink" title="在同一网段内"></a>在同一网段内</h4><ol>
<li>A主机构建一个ICMP格式的数据包；</li>
<li>ICMP协议+B主机的IP地址 交给IP协议；</li>
<li>IP层构建一个数据包（A主机的IP地址+控制信息+B主机的IP地址），获得B主机的MAC地址，以便构建一个数据帧；<ol>
<li>（IP协议会根据B主机的IP地址和自己的子网掩码判断是不是属于同一层网络。如果是属于同一层网络的话,就会获得B主机的MAC地址) ARP</li>
</ol>
</li>
<li>主机B接受到主机A的发过来的数据帧以后，先检查该帧中包含的B的IP地址，并和本地的物理地址进行比对，如果符合的话，就接受，否则，就抛弃。同样，需要将该数据帧交由自己的IP层协议，IP层检查以后，再交由ICMP协议，构建一个ICMP的应答包，发送给主机A。</li>
</ol>
<h4 id="不在同一网段内"><a href="#不在同一网段内" class="headerlink" title="不在同一网段内"></a>不在同一网段内</h4><p>在主机A上运行“Ping 192.168.1.4”后，开始跟上面一样，到了怎样得到MAC地址时，IP协议通过计算发现D机与自己不在同一网段内，就直接将交由路由处理，也就是将路由的MAC取过来，至于怎样得到路由的MAC，跟上面一样，先在ARP缓存表找，找不到就广播吧。路由得到这个数据帧后，再跟主机D进行联系，如果找不到，就向主机A返回一个超时的信息。</p>
<h2 id="7-3-Traceroute"><a href="#7-3-Traceroute" class="headerlink" title="7.3 Traceroute"></a>7.3 Traceroute</h2><p>Traceroute会设置特殊的TTL值，来追踪源主机和目标主机之间的路由数。首先它给目标主机发送一个 TTL=1 的UDP数据包，那么这个数据包一旦在路上遇到一个路由器，TTL就变成了0（TTL规则是每经过一个路由器都会减1），因为TTL=0了，所以路由器就会把这个数据包丢掉，然后产生一个错误类型（超时）的ICMP数据包回发给源主机，也就是差错包。这个时候源主机就拿到了第一个路由节点的IP和相关信息了。</p>
<p>接着，源主机再给目标主机发一个 TTL=2 的UDP数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息了。</p>
<p>如此反复进行，Traceroute就可以拿到从主机A到主机B之间所有路由器的信息了。</p>
<p>但是有个问题是，如果数据包到达了目标主机的话，即使目标主机接收到TTL值为1的IP数据包，它也是不会丢弃该数据包的，也不会产生一份超时的ICMP回发数据包的，因为数据包已经达到了目的地嘛。那我们应该怎么认定数据包是否达到了目标主机呢？</p>
<p>Traceroute的方法是在源主机发送UDP数据包给目标主机的时候，会设置一个不可能达到的目标端口号（例如大于30000的端口号），那么当这个数据包真的到达目标主机的时候，目标主机发现没有对应的端口号，因此会产生一份“端口不可达”的错误ICMP报文返回给源主机。</p>
<h2 id="7-4-DNS"><a href="#7-4-DNS" class="headerlink" title="7.4 DNS"></a>7.4 DNS</h2><p>当我们需要向互联网请求资源时，需要获取资源所在服务器的IP地址，以进行通信。而实际上，IP地址由32位的二进制数字组成，即使是点分十进制的IP地址也很难记忆。但服务器主机名则比较容易记住。故而，需有一个主机名到IP的映射关系，以获取主机服务器对应的IP地址。DNS（域名系统）即保存了互联网上所有域名与IP的映射关系，通过主机名获取对应主机IP的流程即DNS解析流程。</p>
<p>从DNS域名结构上我们得知，域名是分层级的，最上层为根域，下一级为顶级域（Top<br>Level Domain，如com, org等）。域名解析授权是个树状结构，自上而下的分层体系。</p>
<p>首先，根DNS把顶级域名按后缀分别授权给不同的DNS，以有利于管理。修改顶级域名的授权要到根DNS上才能完成。我们可以用dig +@某根服务器IP com. ns来查看根服务器下com顶级域名服务器授权的NS服务器详情。</p>
<p>DNS是分级别进行授权，由根授权一些NS管理com区的域名，再由com授权<a href="https://link.zhihu.com/?target=http%3A//wangsu.com" target="_blank" rel="noopener">http://wangsu.com</a>区管理自己区的域名，故DNS查询时，在没有缓存的情况下，也是由根DNS开始查询，一次查询每一级的NS记录，最终得到对应域名的IP地址。</p>
<h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><p>DNS分为递归查询和迭代查询。</p>
<ol>
<li><p>主机向本地域名服务器的查询一般都是采用递归查询。</p>
<ol>
<li>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</li>
</ol>
</li>
<li><p>本地域名服务器向根域名服务器的查询的迭代查询。</p>
<ol>
<li><p>迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。</p>
</li>
<li><p>然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。</p>
<p>顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机</p>
</li>
</ol>
</li>
</ol>
<h2 id="7-5-REST-REpresentational-State-Transfer"><a href="#7-5-REST-REpresentational-State-Transfer" class="headerlink" title="7.5 REST REpresentational State Transfer"></a>7.5 REST REpresentational State Transfer</h2><p>看Url就知道要什么<br>看http method就知道干什么<br>看http status code就知道结果如何</p>
<p>作者：覃超<br>链接：<a href="https://www.zhihu.com/question/28557115/answer/48094438" target="_blank" rel="noopener">https://www.zhihu.com/question/28557115/answer/48094438</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>\0. REST不是”rest”这个单词，而是几个单词缩写。但即使那几个单词说出来，也无法理解在说什么 -_-!! （不是要贬低人，是我自己也理解困难）；<br>\1. REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）；<br>\2. Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。比如：<br><a href="https://link.zhihu.com/?target=http%3A//api.qc.com/v1/newsfeed" target="_blank" rel="noopener">http://api.qc.com/v1/newsfeed</a>: 获取某人的新鲜;<br><a href="https://link.zhihu.com/?target=http%3A//api.qc.com/v1/friends" target="_blank" rel="noopener">http://api.qc.com/v1/friends</a>: 获取某人的好友列表;<br><a href="https://link.zhihu.com/?target=http%3A//api.qc.com/v1/profile" target="_blank" rel="noopener">http://api.qc.com/v1/profile</a>: 获取某人的详细信息;3. 用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：<br>GET    用来获取资源，<br>POST  用来新建资源（也可以用于更新资源），<br>PUT    用来更新资源，<br>DELETE  用来删除资源。比如：<br>DELETE <a href="https://link.zhihu.com/?target=http%3A//api.qc.com/v1/friends" target="_blank" rel="noopener">http://api.qc.com/v1/</a>friends: 删除某人的好友 （在http parameter指定好友id）<br>POST <a href="https://link.zhihu.com/?target=http%3A//api.qc.com/v1/friends" target="_blank" rel="noopener">http://api.qc.com/v1/</a>friends: 添加好友<br>UPDATE <a href="https://link.zhihu.com/?target=http%3A//api.qc.com/v1/profile" target="_blank" rel="noopener">http://api.qc.com/v1/profile</a>: 更新个人资料</p>
<p>\4. Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。当然还可以压缩HTTP传输时的数据（on-wire data compression）。<br>\5. 用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。</p>
<p>主要信息就这么点。最后是要解放思想，Web端不再用之前典型的PHP或JSP架构，而是改为前段渲染和附带处理简单的商务逻辑（比如AngularJS或者BackBone的一些样例）。Web端和Server只使用上述定义的API来传递数据和改变数据状态。格式一般是JSON。iOS和Android同理可得。由此可见，Web，iOS，Android和第三方开发者变为平等的角色通过一套API来共同消费Server提供的服务。</p>
<p>URI使用名词而不是动词，且推荐用复数。<br>BAD</p>
<ul>
<li>/getProducts</li>
<li>/listOrders</li>
<li>/retrieveClientByOrder?orderId=1</li>
</ul>
<p>GOOD</p>
<ul>
<li>GET /products : will return the list of all products</li>
<li>POST /products : will add a product to the collection</li>
<li>GET /products/4 : will retrieve product #4</li>
<li>PATCH/PUT /products/4 : will update product #4</li>
</ul>
<h2 id="7-6-NAT"><a href="#7-6-NAT" class="headerlink" title="7.6 NAT"></a>7.6 NAT</h2><h3 id="NAT概念"><a href="#NAT概念" class="headerlink" title="NAT概念"></a>NAT概念</h3><p>在计算机网络中，网络地址转换(Network Address Translation，缩写为NAT)，也叫做网络掩蔽或者IP掩蔽(IP masquerading)，是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。1990年代中期，NAT是作为一种解决IPv4地址短缺以避免保留IP地址困难的方案而流行起来的。</p>
<h3 id="NAPT概念"><a href="#NAPT概念" class="headerlink" title="NAPT概念"></a>NAPT概念</h3><p>NAT虽然名为网络地址转换，但是常见的工作模式实际上是NAPT(网络地址端口转换)。这种方式支持端口的映射，并允许多台主机共享一个公网IP地址。 支持端口转换的NAT又可以分为两类：源地址转换和目的地址转换。前一种情形下发起连接的计算机的IP地址将会被重写，使得内网主机发出的数据包能够到达外网主机。后一种情况下被连接计算机的IP地址将被重写，使得外网主机发出的数据包能够到达内网主机。实际上，以上两种方式通常会一起被使用以支持双向通信。NAPT维护一个带有IP以及端口号的NAT表，结构如下：</p>
<h3 id="STUN概念"><a href="#STUN概念" class="headerlink" title="STUN概念"></a>STUN概念</h3><p>STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。 是不是感觉STUN干的活儿非常熟悉，没错，STUN负责的就是前面提到的Server1所做的内容。只不过STUN协议还具备另一个关键功能，就是确认Client的NAT类型（网络类型）。至于STUN是怎么获取Client公网地址这部分内容，我就不赘述了。接下来我会介绍一下STUN是如何确定Client的NAT类型（网络类型）的。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c8d71348e48860644c70a39fdef063c9_1440w.jpg" alt="img"></p>
<p>一旦路径通过红色箱子的终点时，UDP的直接沟通是没有可能性的。一旦通过黄色或是绿色的箱子，就有连线的可能。 上图中的大部分内容我相信各位童鞋应该都能看懂，其中关于”Public IP is link’s IP?”这一步我简单的讲一下： 1. Client向STUN服务器发送请求 2. STUN将检测出的Client外网地址(eAddr:ePort)回传 3. Client比对创建Socket时使用的地址(localAddr:localPort)和(eAddr:ePort)是否一致，如果完全相同，则Client在NAT后。</p>
<h2 id="TURN"><a href="#TURN" class="headerlink" title="TURN"></a>TURN</h2><p>TURN（全名Traversal Using Relay NAT），是一种数据传输协议（data-transfer protocol）。允许在TCP或UDP的连接跨越NAT或防火墙。 TURN是一个client-server协议。TURN的NAT穿透方法与STUN类似，都是通过获取应用层中的公有地址达到NAT穿透。但实现TURN client的终端必须在通信开始前与TURN server进行交互，并要求TURN server产生”relay port”，也就是relayed-transport-address。这时TURN server会创建peer，即远程端点（remote endpoints），开始进行中继（relay）的动作，TURN client利用relay port将数据发送至peer，再由peer转传到另一方的TURN client。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="NewReStarter.github.io/2019/12/22/c-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ReStartercc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Restartercc">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/22/c-interview/" itemprop="url">【面试系列】 - C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-22T16:53:27+08:00">
                2019-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<p>本系列是  <strong><a href="https://blog.csdn.net/shanghairuoxiao/article/details/72876248" target="_blank" rel="noopener">C++后台开发校招面试常见问题</a></strong> 的扩充版，旨在通过填写checklist的答案进行最后一轮面试基础知识的复习。</p>
<p>参考书籍 : </p>
<p>《The C++ Programming Language》 4th Edition by Bjarne Stroustrup (以下均称TCPL)</p>
<p>《STL 源码剖析》侯捷</p>
<h2 id="1-常见关键字"><a href="#1-常见关键字" class="headerlink" title="1. 常见关键字"></a>1. 常见关键字</h2><h4 id="extern关键字作用"><a href="#extern关键字作用" class="headerlink" title="extern关键字作用"></a>extern关键字作用</h4><ol>
<li><p>extern 声明变量在外部被定义</p>
<ol>
<li>引用在同一个文件中在被使用行后声明的变量</li>
<li>引用其他文件的变量（只有当一个变量是一个全局变量时，extern变量才会起作用）。注意extern只能指明类型和变量名，不能在extern处再重新赋值。但在extern行之后就可以了。</li>
</ol>
</li>
<li><p>extern 修饰函数</p>
<ol>
<li>引用在其他文件里的函数</li>
</ol>
</li>
<li><p>extern “C”</p>
<ol>
<li><p>目的: 实现类C和C++的混合编程。</p>
</li>
<li><p>实质：根据C的编译和连接规约来链接</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; char* strcpy(char*, const char*)</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p><strong>extern</strong> 的 前两个用途对应的是 static</p>
<p><em>Ref: (1)TCPL Chapter 15: Source File (2) C语言正确使用extern关键字<a href="https://blog.csdn.net/xingjiarong/article/details/47656339" target="_blank" rel="noopener">https://blog.csdn.net/xingjiarong/article/details/47656339</a></em></p>
<hr>
<h4 id="static关键字作用"><a href="#static关键字作用" class="headerlink" title="static关键字作用"></a>static关键字作用</h4><p>简而言之两大作用，改变生存期和作用域。</p>
<p>the word static means “no access from other source file”, use internal linkage</p>
<ol>
<li>static 修饰局部变量</li>
</ol>
<p>static 的局部变量改变的事变量的生存周期，因为不在栈中而在静态存储区，他的内存保留直到程序结束。</p>
<ol start="2">
<li>static 修饰全局变量</li>
</ol>
<p>静态变量和全局变量的存储区都在全局/静态变量存储区，所以存储方式没有改变。静态全局变量改变的是作用域，为该文件内的函数公用，不被其他源文件可见。</p>
<ol start="3">
<li>static修饰普通（全局）函数</li>
</ol>
<p>用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。避免被其他文件所用或者其他文件中有相同名字的函数，不会发生冲突。</p>
<ol start="4">
<li>static修饰成员变量</li>
</ol>
<p>全部类对象共享的是同一个static成员变量，而不是普通对象一样的每个类对象都有一份</p>
<ol>
<li>static修饰成员函数</li>
</ol>
<p>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员。</p>
<p><em>Ref: (1) <a href="https://blog.csdn.net/artechtor/article/details/2312766" target="_blank" rel="noopener">C++中Static作用和使用方法</a> (2) TCPL Chpt 14-17</em></p>
<hr>
<h4 id="const-和-constexpr"><a href="#const-和-constexpr" class="headerlink" title="const 和 constexpr"></a>const 和 constexpr</h4><ul>
<li><p>区别：</p>
<ul>
<li>const: 用于明确interface，意思是data可以被安心的传递而不用怕被修改过，是runtime evaluation</li>
<li>constexpr: 用于明确常数，为了更好的performance。是compile time evaluation</li>
</ul>
</li>
<li><p>经典的constexpr(用于模板特化):</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * factorial(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  constN&lt;factorial(<span class="number">4</span>)&gt; out1;		<span class="comment">// compute at compile time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>const 的作用（不可修改 + 必须初始化）</li>
</ul>
<ol>
<li><p>const 修饰变量</p>
</li>
<li><p>const放在*前面，const char *ch，表示一个指向const char的指针，即指针本身可以变化，指向的对象不可以。</p>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ch = <span class="string">"12345"</span>;</span><br><span class="line">ch++;					<span class="comment">// ok</span></span><br><span class="line">p1[<span class="number">0</span>] = <span class="string">'w'</span>;  <span class="comment">// compilation error</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>const放在*后面，char * const ch，表示一个const的char指针，指针本身不能变化，但指向的对象可以</p>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> ch = <span class="string">"hello"</span>;</span><br><span class="line">ch[<span class="number">1</span>] = <span class="string">'w'</span>;			<span class="comment">// ok, but runtime error</span></span><br><span class="line">ch++;							<span class="comment">// compilation error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* msg = <span class="string">"hello"</span>;</span><br><span class="line">ch[<span class="number">1</span>] = <span class="string">"w"</span>;			<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
</li>
<li><p>const修饰引用做形参(避免复制又避免修改)</p>
</li>
<li><p>const修饰成员变量，必须在构造函数列表中初始化，但不能直接给一个值；</p>
</li>
<li><p>const修饰成员函数，说明该函数不应该修改非静态成员，但是这并不是十分可靠的，指针所指的非成员对象值可能会被改变</p>
</li>
</ol>
<p>const static</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> a);</span><br><span class="line">	<span class="function">staticvoid <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//静态成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> aa;<span class="comment">//静态数据成员的声明</span></span><br><span class="line">	staticconst <span class="keyword">int</span> count;<span class="comment">//常量静态数据成员（可以在构造函数中初始化）</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> bb;<span class="comment">//常量数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> A::aa=<span class="number">0</span>;<span class="comment">//静态成员的定义+初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A::count=<span class="number">25</span>;<span class="comment">//静态常量成员定义+初始化</span></span><br></pre></td></tr></table></figure>

<p><em>Ref: <a href="https://blog.csdn.net/tobefxz/article/details/14109697" target="_blank" rel="noopener">C++ static、const和static const类型成员变量声明以及初始化</a></em></p>
<hr>
<h4 id="new-delete-和-malloc-free-的区别"><a href="#new-delete-和-malloc-free-的区别" class="headerlink" title="new/delete 和 malloc/free 的区别"></a>new/delete 和 malloc/free 的区别</h4><ol>
<li><p>new/delete 是operator，因此可以重载；malloc/free 是标准库函数</p>
</li>
<li><p>申请的内存所在位置存在差异</p>
<ol>
<li>new操作符从<strong>自由存储区（free store）</strong>上为对象动态分配内存空间，free store是C++基于new的一个抽象概念，绝大多数时候是堆，但不绝对是堆。</li>
<li>malloc函数从<strong>堆</strong>上动态分配内存</li>
</ol>
</li>
<li><p>返回类型安全性</p>
<ol>
<li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合<strong>类型安全</strong>性的操作符。</li>
<li>malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</li>
</ol>
</li>
<li><p>内存分配失败时的返回值</p>
<ol>
<li>new 返回 bad_alloc expection</li>
<li>malloc 返回 NULL</li>
</ol>
</li>
<li><p>是否需要制定内存大小</p>
<ol>
<li>new分配的大小是按数据类型的，编译器自行计算需要的内存块大小</li>
<li>malloc是要显式指名尺寸的</li>
</ol>
</li>
<li><p>是否调用构造函数/析构函数</p>
<ol>
<li>new会分配一块足够大的原始未命名空间然后运行构造函数构造对象，传入初值，完成构造后返回指针。</li>
<li>delete会运行析构函数，然后编译器调用operator delete 释放内存空间</li>
<li>malloc没有</li>
</ol>
</li>
<li><p>new可以用malloc实现，反之不可以</p>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">void</span>* mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *mem)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>已分配内存的扩充</p>
<ol>
<li>malloc分配的内存不够时，可以realloc进行重新分配。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</li>
<li>new没有办法直观的处理</li>
</ol>
</li>
<li><p>对于内存不够的情况</p>
<ol>
<li>new可以用new_handler调用的set_new_handler制定接下来的步骤</li>
<li>malloc只能返回NULL</li>
</ol>
</li>
</ol>
<ul>
<li>new/delete的实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>; <span class="comment">//allocate an object</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> )</span></span>; <span class="comment">//free an object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[]; <span class="comment">//allocate an array</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> ); <span class="comment">//free an array</span></span><br></pre></td></tr></table></figure>

<ul>
<li>空闲链表分配方法。</li>
</ul>
<p>（1）首次适应法（First Fit）：选择第一个满足要求的空闲块</p>
<p>（2）最佳适应法（Best Fit）：选择满足要求的，且大小最小的空闲块</p>
<p>（3）最坏适应法（Worst Fit）：选择最大的空闲块</p>
<p>（4）循环首次适应法（Next Fit）：从上次分配位置开始找到第一个满足要求的空闲块</p>
<ul>
<li>free为什么知道销毁多大的空间</li>
</ul>
<p>malloc 和 free不是直接向操作系统申请或者释放内存，而是维护空闲链表。malloc返回的指针可能有4个字节存成该块内存的大小（也就是申请100，可能实际有104），当然也有可能是8字节头部，另外4个表示是否正在使用。free释放的时候向前偏移 4/8个字节就行了</p>
<p><em>Ref : (1)TCPL Chpt 11: Select Operation - Free Store  (2)<a href="https://www.cnblogs.com/QG-whz/p/5140930.html" target="_blank" rel="noopener">细说new与malloc的10点区别</a> (3) effictive c++ Item 49</em></p>
<hr>
<h4 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h4><ol>
<li>告知编译器这个变量很可能会被某些编译器的未知因素更改，所以编译器不应该对他做aggressive的优化，每次都从内存重新读</li>
<li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li>
<li>一个参数可以即是const又是volatile的吗？可以，一个例子是只读状态寄存器，是volatile是因为它可能被意想不到的被改变，是const告诉程序不应该试图去修改他。</li>
</ol>
<hr>
<h4 id="inline-的作用-内联函数"><a href="#inline-的作用-内联函数" class="headerlink" title="inline 的作用 内联函数"></a>inline 的作用 内联函数</h4><p>在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即<strong>函数栈</strong>，会造成栈空间或<strong>栈内存</strong>的大量消耗。为了解决这个问题，特别的引入了<strong>inline修饰符</strong>，表示为<strong>内联函数</strong>。</p>
<p>如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
<p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 <strong>inline</strong>，在调用函数之前需要对函数进行定义。</p>
<p>inline比宏安全的地方在于inline可以检查参数</p>
<hr>
<h4 id="explicit-的作用"><a href="#explicit-的作用" class="headerlink" title="explicit 的作用"></a>explicit 的作用</h4><p>explicit 是用来修饰构造函数的，被修饰的构造函数不可以有隐式转换，用来避免隐式转换可能产生的逻辑错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">      String(<span class="keyword">const</span> <span class="keyword">char</span> *p);</span><br><span class="line">&#125;;</span><br><span class="line">String s1 = <span class="string">'a'</span>; <span class="comment">//错误：不能做隐式char-&gt;String转换</span></span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">//可以：调用explicit String(int n);</span></span><br><span class="line">String s3 = String(<span class="number">10</span>);<span class="comment">//可以：调用explicit String(int n);再调用默认的复制构造函数</span></span><br><span class="line">String s4 = <span class="string">"Brian"</span>; <span class="comment">//可以：隐式转换调用String(const char *p);再调用默认的复制构造函数</span></span><br><span class="line"><span class="function">String <span class="title">s5</span><span class="params">(<span class="string">"Fawlty"</span>)</span></span>; <span class="comment">//可以：正常调用String(const char *p);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(String)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="number">10</span>); <span class="comment">//错误：不能做隐式int-&gt;String转换</span></span><br><span class="line">    f(<span class="string">"Arthur"</span>); <span class="comment">//可以：隐式转换，等价于f(String("Arthur"));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>; <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id><a href="#" class="headerlink" title></a></h4><h2 id="2-C-对象模型"><a href="#2-C-对象模型" class="headerlink" title="2. C++ 对象模型"></a>2. C++ 对象模型</h2><h4 id="public-amp-protected-amp-private"><a href="#public-amp-protected-amp-private" class="headerlink" title="public &amp; protected &amp; private"></a>public &amp; protected &amp; private</h4><p>分成两类讨论，访问权限和继承方式。</p>
<ul>
<li><p>访问权限</p>
<ul>
<li>private: 只能被该类的函数和该类的友元函数访问，该类的对象不能直接访问</li>
<li>protected：可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问</li>
<li>public：可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问</li>
</ul>
</li>
<li><p>继承方式改变的方法属性</p>
<ul>
<li>private：父类所有方法在子类中都变private</li>
<li>protected：父类的public和protected方法在子类中变为protected，private方法不变</li>
<li>public：父类的方法属性不改变。</li>
</ul>
</li>
<li><p>组合结果（成员访问权限）</p>
<ul>
<li>public + public继承 = public</li>
<li>public + protected继承 = protected</li>
<li>public + private继承 = private</li>
<li>protected + public继承 = protected</li>
<li>protected + protected继承 = protected</li>
<li>protected + private继承 = private</li>
<li>private + public继承 = 子类无权访问</li>
<li>private + protected继承 = 子类无权访问</li>
<li>private + private继承 = 子类无权访问</li>
</ul>
</li>
<li><p>C++ 默认的是private继承</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method 1</span></span><br><span class="line"><span class="comment">// class derived-class: access-specifier base-class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="struct-和-class-的关系"><a href="#struct-和-class-的关系" class="headerlink" title="struct 和 class 的关系"></a>struct 和 class 的关系</h4><p>struct就是默认成员是public的class，默认继承也是public</p>
<p>A struct is a class where members are by default public.</p>
<hr>
<p>####struct 和 union 的区别</p>
<p>union （ 共用体）：构造数据类型,也叫联合体<br> 用途：使几个不同类型的变量共占一段内存(相互覆盖)</p>
<p> struct ( 结构体 )：是一种构造类型<br> 用途： 把不同的数据组合成一个整体——自定义数据类型</p>
<p>主要区别：</p>
<ol>
<li>struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员; 而struct的所有成员都存在。</li>
<li>在struct中，各成员都占有自己的内存空间，它们是同时存在的,一个struct变量的总长度等于所有成员长度之和，遵从字节对其原则; 在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在 , Union变量的长度等于最长的成员的长度。</li>
<li>对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,所以，共同体变量中起作用的成员是最后一次存放的成员; 而对于struct的不同成员赋值是互不影响的。</li>
</ol>
<hr>
<h4 id="空类有什么"><a href="#空类有什么" class="headerlink" title="空类有什么"></a>空类有什么</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;  <span class="comment">// class A 跟 class1有一样的成员</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    class1()&#123;&#125; <span class="comment">//缺省构造函数</span></span><br><span class="line"></span><br><span class="line">    class1(<span class="keyword">const</span> class1&amp;)&#123;&#125; <span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    ~class1()&#123;&#125; <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    class1&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> class1&amp;)&#123;&#125; <span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">    class1*<span class="keyword">operator</span>&amp;()&#123;&#125; <span class="comment">//取址运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class1*<span class="keyword">operator</span>&amp;()<span class="keyword">const</span>&#123;&#125; <span class="comment">//取址运算符 const</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="内存对齐（字节对齐）"><a href="#内存对齐（字节对齐）" class="headerlink" title="内存对齐（字节对齐）"></a>内存对齐（字节对齐）</h4><ul>
<li>什么是内存对齐</li>
</ul>
<p>1，计算机中的内存是按字节（byte）划分的，从理论上讲对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型的数据按照一定的规则在内存空间上排序，而不是顺序的一个接一个的排放，这就是内存对齐。（粒度存取）</p>
<p>2，内存对齐是为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段。</p>
<p>3，内存对齐是指首地址对齐，而不是说每个变量大小对齐。对不同类型的数据，首先计算出它的自身对齐值N，由它的对齐值获取它在内存中的存储起始地址，”存储起始地址  %  N == 0”。</p>
<ul>
<li>几个built-in type的大小<ul>
<li>char 1</li>
<li>short 2</li>
<li>int 4</li>
<li>float 4</li>
<li>double 8</li>
<li>long 8</li>
<li>long long 8</li>
<li>NULL/nullptr/指针 32位系统 4 64位系统8</li>
<li>数组的大小 = 类型大小 * 个数</li>
</ul>
</li>
<li>对齐规则<ul>
<li>N = min(pragma pack(n), longest member);</li>
<li>对于类里有类，里面类的对齐值（即起始位置必须是N的倍数）为类里最长元素的对齐值。</li>
<li>整个struct的大小，应该为最大数据成员大小的整数倍。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;        <span class="comment">//内存位置：[0]</span></span><br><span class="line">    <span class="keyword">double</span> d;      <span class="comment">//内存位置：[8] - [15]</span></span><br><span class="line">    <span class="keyword">int</span> i;         <span class="comment">//内存位置：[16] - [19]</span></span><br><span class="line">&#125;;                 <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;                  <span class="comment">// 16</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">   Data d;</span><br><span class="line">&#125;;                 <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;        <span class="comment">//内存位置：[0]</span></span><br><span class="line">    <span class="keyword">int</span> i;         <span class="comment">//内存位置：[4] - [7]</span></span><br><span class="line">    <span class="keyword">double</span> d;      <span class="comment">//内存位置：[8] - [15]</span></span><br><span class="line">&#125;;                  <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> s;       <span class="comment">//内存位置：[0] - [1]</span></span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">20</span>];     <span class="comment">//内存位置：[4] - [83]</span></span><br><span class="line">    <span class="keyword">double</span> d;      <span class="comment">//内存位置：[88] - [95]</span></span><br><span class="line">&#125;;                 <span class="comment">// 4 + 4 * 20 + 4 + 8 = 96</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> s;      <span class="comment">//内存位置：[0] - [1]</span></span><br><span class="line">    B b;          <span class="comment">//内存位置：[8] - [23]</span></span><br><span class="line">    <span class="keyword">int</span> i;        <span class="comment">//内存位置：[24] - [27]</span></span><br><span class="line">&#125;;                <span class="comment">// 8 + 16 + 4 = 28 = 32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];				<span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><p>多态分为 <strong>静态多态</strong> 和 <strong>动态多态</strong> 。静态多态是通过重载和模板技术实现，在编译的时候确定；动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
<p>动态多态实现有几个条件：</p>
<p>（1）虚函数</p>
<p>（2）一个基类（Base）的指针或者引用指向派生类对象</p>
<p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表（vtbl）。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。</p>
<p>每个对象中保存的只是一个虚函数表的指针（vptr），<strong>C++内部为每一个类维持一个虚函数表</strong>，该类的对象的都指向这同一个虚函数表。</p>
<p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。</p>
<hr>
<h4 id="虚函数的作用"><a href="#虚函数的作用" class="headerlink" title="虚函数的作用"></a>虚函数的作用</h4><ol>
<li>作为实现多态的必要条件（非虚函数的调用是静态类型决定的）</li>
<li>在设计上作为封装和抽象的必要工具</li>
</ol>
<hr>
<h4 id="静态多态和动态多态"><a href="#静态多态和动态多态" class="headerlink" title="静态多态和动态多态"></a>静态多态和动态多态</h4><ul>
<li>静态多态</li>
</ul>
<p>compile time 通过重载和模板实现的</p>
<ul>
<li>动态多态</li>
</ul>
<p>runtime 通过虚函数技术实现的动态绑定技术</p>
<hr>
<h4 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h4><ol>
<li>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</li>
<li>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</li>
<li>静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。通过函数签名实现。</li>
<li>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</li>
</ol>
<p><em>Ref ： <a href="https://blog.csdn.net/chgaowei/article/details/6427731" target="_blank" rel="noopener">深入理解C++的动态绑定和静态绑定</a></em></p>
<hr>
<h4 id="虚函数-amp-抽象类"><a href="#虚函数-amp-抽象类" class="headerlink" title="虚函数 &amp; 抽象类"></a>虚函数 &amp; 抽象类</h4><p>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。</p>
<p>纯虚函数是虚函数再加上=0。并且该函数只有声明，没有实现。</p>
<p>抽象类是指包括至少一个纯虚函数的类。</p>
<p>定义一个函数为虚函数，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<hr>
<h4 id="虚函数表-和-虚指针"><a href="#虚函数表-和-虚指针" class="headerlink" title="虚函数表 和 虚指针"></a>虚函数表 和 虚指针</h4><p>虚函数表（vtbl） - 每个含有虚函数的类一个，是一个一维数组而不是链表。编译器在编译的时候，发现Base类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表。</p>
<p>虚指针（vptr） - 该类的每个对象一个，在构造函数中进行虚表指针的初始化，放在内存地址的最前面。因此静态函数不可以是虚函数，构造函数也不可以。</p>
<p>虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类有3个虚函数，那么基类的虚表中就有三项（虚函数地址），派生类也会有虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现。如果派生类有自己的虚函数，那么虚表中就会添加该项。</p>
<p>派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。</p>
<p>对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息(Run-Time Type Identification, RTTI)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前面。</p>
<hr>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为<strong>虚拟继承</strong>，而A就成了<strong>虚拟基类</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; ;</span><br><span class="line">&#125;;                      <span class="comment">// 16 本来是12，因为sizeof(vptr) == 8，所以内存要对齐。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;&#125;;   <span class="comment">// 16</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> A &#123;&#125;;   <span class="comment">// 16</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;&#125;;  <span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;  <span class="comment">// 24</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;&#125;;  <span class="comment">// 24</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;&#125;; <span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(D)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(B1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(C1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(D1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="构造函数和析构函数在多态的执行过程"><a href="#构造函数和析构函数在多态的执行过程" class="headerlink" title="构造函数和析构函数在多态的执行过程"></a>构造函数和析构函数在多态的执行过程</h4><p>构造函数bottom-up</p>
<ol>
<li>基类的构造函数</li>
<li>类里成员的构造函数</li>
<li>execute its own body</li>
</ol>
<p>析构函数tears down</p>
<ol>
<li>execute its own body</li>
<li>类里成员的析构函数</li>
<li>基类的析构函数</li>
</ol>
<hr>
<h4 id="C-的-重载-覆盖-隐藏"><a href="#C-的-重载-覆盖-隐藏" class="headerlink" title="C++ 的 重载 覆盖 隐藏"></a>C++ 的 重载 覆盖 隐藏</h4><ul>
<li>重载 overload</li>
</ul>
<ol>
<li>相同的scope（在同一个类中）</li>
<li>函数名字相同</li>
<li>函数参数不同</li>
<li>virtual关键字可有可无</li>
</ol>
<ul>
<li>覆盖（重写） override</li>
</ul>
<ol>
<li>不同的scope（分别位于基类和派生类）</li>
<li>函数名字相同</li>
<li>参数相同</li>
<li>基类函数必须要virtual</li>
</ol>
<ul>
<li>隐藏 hide</li>
</ul>
<ol>
<li>如果派生类的函数与基类的函数名相同，但是参数不同。此时，不论有无virtual关键字。此时，基类函数会被隐藏。</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关<br>键字。此时，基类的函数被隐藏。</li>
<li>不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</li>
<li>即使派生类的成员（包括成员变量和成员函数）和基类中成员重名，造成遮蔽，仍然可以访问基类的成员变量和成员函数，不过要加上类名和域解析符。如</li>
</ol>
<hr>
<h4 id="override-的作用"><a href="#override-的作用" class="headerlink" title="override 的作用"></a>override 的作用</h4><p>c++ 11 新特性</p>
<p>强制编译器检查某个函数是否重写基类的虚函数，强制重新写，如果没有则报错。</p>
<hr>
<h4 id="final-的作用"><a href="#final-的作用" class="headerlink" title="final 的作用"></a>final 的作用</h4><p>c++ 11 新特性</p>
<ol>
<li>禁止虚函数被覆盖（修饰函数时必须与virtual合用）</li>
<li>禁止基类被继承</li>
</ol>
<hr>
<h4 id="friend-的作用"><a href="#friend-的作用" class="headerlink" title="friend 的作用"></a>friend 的作用</h4><p>C++中的友元机制允许类的非公有成员被一个类或者函数访问，友元按类型分为三种：</p>
<ul>
<li>普通非类成员函数作为友元</li>
<li>类的成员函数作为友元</li>
<li>类作为友元</li>
</ul>
<p>友元既不能被继承 也不能被传递</p>
<p>如果想要指定两个类都有成员函数作为对方的友元，那么必须第2个类是第一个类的友元</p>
<p><strong>普通非类成员函数作为友元</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//OpeClass.h</span><br><span class="line">#pragma once</span><br><span class="line">class OpeClass</span><br><span class="line">&#123;</span><br><span class="line">	friend int func(const OpeClass xx);</span><br><span class="line">public:</span><br><span class="line">	OpeClass(void);</span><br><span class="line">	OpeClass(int x,int y);</span><br><span class="line">	~OpeClass(void);</span><br><span class="line">private:</span><br><span class="line">	int width;</span><br><span class="line">	int height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//OpeClass.cpp</span><br><span class="line">#include &quot;OpeClass.h&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">OpeClass::OpeClass(void)</span><br><span class="line">&#123;</span><br><span class="line">	width = 50;</span><br><span class="line">	height = 50;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">OpeClass::OpeClass(int x,int y):width(x),height(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">OpeClass::~OpeClass(void)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int func(const OpeClass xx)</span><br><span class="line">&#123;</span><br><span class="line">	return xx.height * xx.width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类作为友元</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//A.h</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	friend class B;</span><br><span class="line">public:</span><br><span class="line">	~A(void);</span><br><span class="line">	static void func()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;This is in A&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	A()&#123;&#125;;</span><br><span class="line">	static const A Test;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>类成员函数作为友元函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//A.h</span><br><span class="line">#pragma once</span><br><span class="line">#include &quot;B.h&quot;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">friend int B::func(A xx);</span><br><span class="line">public:</span><br><span class="line">	A(void):mx(20),my(30)&#123;&#125;</span><br><span class="line">	~A(void)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	int mx;</span><br><span class="line">	int my;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Run-Time-Type-Information-RTII"><a href="#Run-Time-Type-Information-RTII" class="headerlink" title="Run-Time Type Information(RTII)"></a>Run-Time Type Information(RTII)</h4><p>RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。</p>
<ol>
<li>typeid</li>
</ol>
<p>对于c++的内置数据类型，typeid可以方便的输出它们的数据类型。对于自己定义的类，也能够输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is class A."</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is class B."</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is struct C."</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     A *pA1 = <span class="keyword">new</span> A();</span><br><span class="line">     A a2;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(pA1).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// class A *</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(a2).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// class A</span></span><br><span class="line"></span><br><span class="line">     B *pB1 = <span class="keyword">new</span> B();</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(pB1).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// class B *</span></span><br><span class="line"></span><br><span class="line">     C *pC1 = <span class="keyword">new</span> C();</span><br><span class="line">     C c2;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(pC1).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// struct C *</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="keyword">typeid</span>(c2).name()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// struct C</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是RTTI在捣鬼了，<strong>当类中不存在虚函数时</strong>，typeid是编译时期的事情，也就是静态类型，就如上面的cout&lt;&lt;typeid(*pA).name()&lt;&lt;endl;输出class A一样；</p>
<p><strong>当类中存在虚函数时</strong>，typeid是运行时期的事情，也就是动态类型，就如上面的cout&lt;&lt;typeid(*pA).name()&lt;&lt;endl;输出class B一样，关于这一点，我们在实际编程中，经常会出错，一定要谨记。</p>
<ol start="2">
<li><h5 id="type-info类里面的比较运算符"><a href="#type-info类里面的比较运算符" class="headerlink" title="type_info类里面的比较运算符"></a>type_info类里面的比较运算符</h5></li>
</ol>
<p>使用type_info类中重载的==和!=比较两个对象的类型是否相等</p>
<ol start="3">
<li>dynamic_cast</li>
</ol>
<p>dynamic_cast主要用于在多态的时候，它允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转换类型，把基类指针（引用）转换为派生类指针（引用）。</p>
<p>当我们进行dynamic_cast时，编译器会帮我们进行语法检查。如果vptr指针的静态类型和目标类型相同，那么就什么事情都不做；否则，首先对指针进行调整，使得它指向虚函数表，并将其和调整之后的指针、调整的偏移量、静态类型以及目标类型传递给内部函数。其中最后一个参数指明转换的是指针还是引用。两者唯一的区别是，如果转换失败，前者返回NULL，后者抛出bad_cast异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is class A."</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is class B."</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"This is class C."</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     A *pA = <span class="keyword">new</span> C;</span><br><span class="line">     <span class="comment">//C *pC = pA; // Wrong 编译器会提示错误</span></span><br><span class="line">     C *pC = <span class="keyword">dynamic_cast</span>&lt;C *&gt;(pA);</span><br><span class="line">     <span class="keyword">if</span> (pC != <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          pC-&gt;Print();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">delete</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="四种类型转换"><a href="#四种类型转换" class="headerlink" title="四种类型转换"></a>四种类型转换</h4><ul>
<li>static_cast</li>
<li>dynamic_cast</li>
<li>const_cast</li>
<li>reinterpret_cast</li>
</ul>
<ol>
<li>const_cast用于将const变量转为非const</li>
<li>static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知；</li>
<li>dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。</li>
<li>reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题</li>
<li>为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</li>
</ol>
<hr>
<h4 id="必须在构造函数初始化式里进行初始化的数据成员有哪些"><a href="#必须在构造函数初始化式里进行初始化的数据成员有哪些" class="headerlink" title="必须在构造函数初始化式里进行初始化的数据成员有哪些"></a>必须在构造函数初始化式里进行初始化的数据成员有哪些</h4><ul>
<li>常量成员（const）</li>
</ul>
<p>常量成员只能初始化不能赋值，所以必须放在初始化列表里。</p>
<ul>
<li>引用类型</li>
</ul>
<p>引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。</p>
<ul>
<li>对象成员</li>
</ul>
<p>见<strong>构造函数和析构函数在多态的执行过程</strong></p>
<hr>
<h2 id="3-指针和引用"><a href="#3-指针和引用" class="headerlink" title="3. 指针和引用"></a>3. 指针和引用</h2><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol>
<li>指针保存的是所指对象的地址，引用是所指对象的别名，指针需要通过解引用间接访问，而引用是直接访问</li>
<li>指针可以改变地址，从而改变所指的对象，而引用必须从一而终；</li>
<li>引用在定义的时候必须初始化，而指针则不需要；</li>
<li>指针有指向常量的指针和指针常量，而引用没有常量引用；</li>
</ol>
<hr>
<h4 id="指针和数组名"><a href="#指针和数组名" class="headerlink" title="指针和数组名"></a>指针和数组名</h4><ol>
<li><p>一个一维int数组的数组名实际上是一个int* const 类型</p>
</li>
<li><p>一个二维int数组的数组名实际上是一个int (*const p)[n];</p>
</li>
<li><p>数组名做参数会退化为指针，除了sizeof</p>
</li>
</ol>
<hr>
<h4 id="左值和右值的区别"><a href="#左值和右值的区别" class="headerlink" title="左值和右值的区别"></a>左值和右值的区别</h4><p>左右植的根本区别在于能否获取内存地址，左值是可以取内存的变量。</p>
<p>临时变量（右值）的生命周期：</p>
<ol>
<li>临时对象应该在完整表达式结束时销毁</li>
<li>常量左值引用会延长临时变量的生命</li>
</ol>
<p>右值引用：std::move()</p>
<hr>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>共有三种智能指针，unique_ptr，share_ptr，weak_ptr。</p>
<ul>
<li>unique_ptr</li>
</ul>
<p>unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权。所有权包括：</p>
<ol>
<li>他指向的对象；</li>
<li>无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作。</li>
<li>保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象</li>
</ol>
<p>unique_ptr可以实现：</p>
<ol>
<li>为动态申请的内存提供异常安全</li>
<li>将动态申请的内存所有权传递给某函数</li>
<li>从某个函数返回动态申请内存的所有权</li>
<li>在容器中保存指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Test&gt; fun() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;Test&gt;(<span class="keyword">new</span> Test(<span class="string">"789"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Test&gt; p1(<span class="keyword">new</span> Test(<span class="string">"123"</span>));</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Test&gt; p2(<span class="keyword">new</span> Test(<span class="string">"456"</span>));</span><br><span class="line">  p2 = <span class="built_in">std</span>::move(p1);				<span class="comment">// 之后 p1 为空 注意不能直接=</span></span><br><span class="line">  Test* p = p2.release();		<span class="comment">// p 为 Test("123")</span></span><br><span class="line">  p1.reset(p);</span><br><span class="line">  p2 = fun();								<span class="comment">// 这里可以直接等于是因为使用了移动构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p1, p2被delete</span></span><br></pre></td></tr></table></figure>

<ul>
<li>share_ptr</li>
</ul>
<p>它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。出了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>智能指针计数的实现</p>
<ol>
<li>构造函数中计数初始化为1；</li>
<li>拷贝构造函数中计数值加1；</li>
<li>赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；</li>
<li>析构函数中引用计数减一；</li>
<li>在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。</li>
</ol>
<ul>
<li>weak_ptr</li>
</ul>
<p><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题</strong>,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。weak_ptr是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<p>motivation也是区别，weak_ptr是一种弱引用，没有计数，可以解决循环引用的问题。</p>
<hr>
<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。野指针的成因主要有两种：</p>
<ol>
<li>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li>
<li>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。</li>
</ol>
<hr>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><ol>
<li>c++ 默认的就是浅拷贝。它能完成成员的意义复制，当数据成员没有指针的时候，浅拷贝是可行的；当数据成员有指针的时候，两个指针将指向同一个地址，将对象结束时，会调用两次析构函数导致指针悬挂现象（指向非法内存的指针，即野指针），所以此时必须要用深拷贝。</li>
<li>深拷贝和浅拷贝的区别在于会在自由内存区（堆里）申请空间来存储数据，从而解决悬挂指针的问题。</li>
</ol>
<hr>
<h2 id="4-STL"><a href="#4-STL" class="headerlink" title="4. STL"></a>4. STL</h2><h4 id="（STL的内存管理）内存池"><a href="#（STL的内存管理）内存池" class="headerlink" title="（STL的内存管理）内存池"></a>（STL的内存管理）内存池</h4><p>优点：<br>1、加快内存分配速度（快于标准的malloc），内存块够用时，仅是大小判断和指针偏移等简单操作；<br>2、小块内存的有效载荷高（没有合并内存块所需的指针），需要的额外信息少；<br>3、内存池上分配的内存通常不需要再单独释放，而是统一回收；<br>4、除了使用内存分配函数代替malloc，没有使用上的其他特殊约定。</p>
<p>缺点：<br>1、如果内存池的生命周期比较长，可能给系统造成较大的内存压力。<br>2、从内存池分配的内存，一般不能显式释放，造成某些内存得不到及时回收。</p>
<p>使用场景：<br>1、需要频繁分配小块内存。<br>2、内存使用有明确的生命周期。</p>
<p>当我们new一个对象的时候，实际上做了两件事：（1）使用malloc申请了一块内存（2）执行构造函数。在SGI中这两步独立出了两个函数：allocate申请内存，construct调用构造函数，这两个函数分别在&lt;stl_alloc.h&gt;和&lt;stl_construct.h&gt;里面。</p>
<ol>
<li>第一级配置器：</li>
</ol>
<p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p>
<ol start="2">
<li>第二级配置器</li>
</ol>
<p>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p>
<p>​        如果要分配的区块大于128bytes，则移交给第一级配置器处理。</p>
<p>​        如果要分配的区块小于128bytes，则以内存池管理，又称之为次层配置（sub-allocation）：每次配置一大块内存，并维护16个空闲链表（free-list）。下次若有相同大小的内存需求，就直接在free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p>
<p>这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个Union既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。</p>
<img src="/Users/ziliugao2/Desktop/20160819041312363.jpg" alt="20160819041312363" style="zoom:75%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//将bytes上调至8的倍数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN - <span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));<span class="comment">//等价于(bytes + 7) / 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空闲链表的节点构造</span></span><br><span class="line">    <span class="keyword">union</span> obj</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">union</span> obj * free_list_link;</span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//16个空闲链表，初始化为0,即每个链表中都没有空闲数据块</span></span><br><span class="line">    <span class="keyword">static</span> obj * <span class="keyword">volatile</span> free_list[__NFREELISTS];</span><br><span class="line">    <span class="comment">//根据申请数据块大小找到相应空闲链表的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN - <span class="number">1</span>)/__ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。</p>
<p>（3）空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。</p>
<p>（4）重新填充空闲链表</p>
<p>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。</p>
<p>（5）从内存池取空间</p>
<p>从内存池取空间给<strong>空闲链表</strong>用是chunk_alloc的工作：</p>
<p>首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。</p>
<h6 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h6><p>动态分区分配是根据进程的实际需要，动态地为之分配内存空间。在实现可变分区分配时，将涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作这样三个问题。</p>
<ul>
<li>分区分配中的数据结构</li>
</ul>
<p>为了实现分区分配，系统中必须配置相应的数据结构，用来描述空闲分区和已分配分区的情况，为分配提供依据。常用的数据结构有以下两种形式：</p>
<ol>
<li>空闲分区表：在系统中设置一张空闲分区表，用于记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。</li>
<li>空闲分区链：为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针；在分区尾部则设置一后向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。</li>
</ol>
<ul>
<li>分区分配算法</li>
</ul>
<ol>
<li>首次适应算法（First Fit）<ol>
<li>在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；</li>
<li>然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。</li>
<li>若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。</li>
</ol>
</li>
</ol>
<p>首次适应算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区。这给为以后到达的大作业分配大的内存空间创造了条件。其缺点是低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，而每次查找又都是从低址部分开始，这无疑会增加查找可用空闲分区时的开销。</p>
<ol start="2">
<li>循环首次适应算法（Next Fit）</li>
</ol>
<p>该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。<br>  为实现该算法，应设置一起始查寻指针，用于指示下一次起始查寻的空闲分区，并采用循环查找方式，即如果最后一个(链尾)空闲分区的大小仍不能满足要求，则应返回到第一个空闲分区，比较其大小是否满足要求。找到后，应调整起始查寻指针。<br>  该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。 </p>
<ol start="3">
<li>最佳适应算法(Best Fit)</li>
</ol>
<p>所谓“最佳”是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区，必然是最佳的。<br>  孤立地看，最佳适应算法似乎是最佳的，然而在宏观上却不一定。因为每次分配后所切割下来的剩余部分总是最小的，这样，在存储器中会留下许多难以利用的小空闲区。</p>
<ol start="4">
<li>最坏适应算法(Worst Fit)</li>
</ol>
<p>最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用，其优点是可使剩下的空闲区不至于太小，产生碎片的几率最小，对中、小作业有利，同时最坏适应分配算法查找效率很高。该算法要求将所有的空闲分区按其容量以从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。<br>  但是该算法的缺点也是明显的，它会使存储器中缺乏大的空闲分区。最坏适应算法与前面所述的首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。 </p>
<ol start="5">
<li>快速适应算法（Quick Fit）</li>
</ol>
<p>该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样，系统中存在多个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。<br>  空闲分区的分类是根据进程常用的空间大小进行划分，如2 KB、4 KB、8 KB等，对于其它大小的分区，如7 KB这样的空闲区，既可以放在8 KB的链表中，也可以放在一个特殊的空闲区链表中。<br>  该算法的优点是查找效率高，仅需要根据进程的长度，寻找到能容纳它的最小空闲区链表，并取下第一块进行分配即可。另外该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。<br>  该算法的缺点是在分区归还主存时算法复杂，系统开销较大。<br>  此外，该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，整体上会造成可观的存储空间浪费，这是典型的以空间换时间的作法。 </p>
<ul>
<li>如何回收内存</li>
</ul>
<p>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点。此时可能出现以下四种情况之一：</p>
<ol>
<li>回收区与插入点的前一个空闲分区相邻接。此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区的大小，大小为两者之和。</li>
<li>回收分区与插入点的后一空闲分区相邻接。此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。 </li>
<li>回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，使用前分区的表项和首址，取消后分区的表项，大小为三者之和。</li>
<li>回收区不邻接。这时应为回收区单独建立一新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</li>
</ol>
<p>原文链接：<a href="https://blog.csdn.net/a987073381/article/details/52245795" target="_blank" rel="noopener">https://blog.csdn.net/a987073381/article/details/52245795</a></p>
<hr>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。<br>我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3。<br>T1：线程创建时间<br>T2：线程执行时间，包括线程的同步等时间<br>T3：线程销毁时间<br>       那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。如果任务执行时间很长的话，这笔开销将是不可忽略的。<br>       除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。尽管这不是一个很大的数目，但是也有部分机器可能达不到这种要求。<br>       因此线程池的出现正是着眼于减少线程本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。<br>      基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销<br>线程池适合场景<br>       事实上，线程池并不是万能的。它有其特定的使用场合。线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。<br>总之线程池通常适合下面的几个场合：<br>(1)单位时间内处理任务频繁而且任务处理时间短<br>(2)对实时性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。<br>————————————————<br>版权声明：本文为CSDN博主「灿哥哥」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/caoshangpa/article/details/80374651" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/80374651</a></p>
<hr>
<h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><ul>
<li>支持随机存取</li>
<li>集合尾端增删速度很快 $O(1)$</li>
<li>集合中间增删速度很慢 $O(n)$</li>
<li>以模板（泛型）的方式实现，可以存储任意类型的变量</li>
</ul>
<h6 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h6><p>以容器模式为基准设计，有begin(), end(), size(), max_size(), empty(), swap()等用法</p>
<h6 id="存取"><a href="#存取" class="headerlink" title="存取"></a>存取</h6><ul>
<li>vec[i]</li>
<li>vector.at(i)</li>
<li>vec.front()</li>
<li>vec.back()</li>
</ul>
<p>用operator[]可能会Segmentation Fault，at()会做边界检查，超出边界会抛出exception</p>
<h6 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h6><ul>
<li>vec.push_back()</li>
<li>vec.pop_back()</li>
<li>vec.insert()</li>
<li>vec.erase()    删除一到多个元素</li>
<li>vec.clear()     清空</li>
<li>reserve() 设置Vector最小的元素容纳数量 </li>
<li>resize() 改变Vector元素数量的大小 </li>
</ul>
<p>vector优异性能的秘诀之一，就是配置比其所容纳的元素所需更多的内存，一般在使用vector之前，就先预留足够空间，以避免二次分配，这样可以使vector的性能达到最佳。</p>
<p>size = _Mylast - _Myfirst</p>
<p>capacity = _Myend - _Myfirst</p>
<h6 id="vector-扩容的本质"><a href="#vector-扩容的本质" class="headerlink" title="vector 扩容的本质"></a><strong>vector 扩容的本质</strong></h6><ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间</li>
<li>将旧内存空间的数据，按原有的顺序移动到新内存的空间中</li>
<li>最后将旧的内存空间释放</li>
</ol>
<p>因此vector进行扩容后，与其相关的指针、引用、迭代器可能失效。具体的扩容倍数依赖于实现，但1.5相对2是一个更加内存和cache友好的扩容倍数，因为允许上述第一步释放的空间得到重用。为了减少扩容的次数，活用reserve和resize是有必要的。</p>
<p><strong>如何解决扩容产生指针失效问题</strong></p>
<p>不要存元素的指针，存vector对象的下标或者指针</p>
<p><strong>如何解决扩容产生迭代器失效问题</strong></p>
<ol>
<li>减小迭代器的使用范围，不保存迭代器的值。</li>
<li>避免在遍历迭代器的过程中修改容器。</li>
<li>不要保存首前和尾后指针。</li>
<li>如果在删除后还想用迭代器，使用erase方法并接收返回的下一个迭代器</li>
</ol>
<h6 id="emplace-back-和-push-back-的区别"><a href="#emplace-back-和-push-back-的区别" class="headerlink" title="emplace_back 和 push_back 的区别"></a>emplace_back 和 push_back 的区别</h6><p>如果要将一个临时变量push到vector的末尾，push_back先要生成一个临时变量再拷贝到末尾，而emplace_back直接在尾部构造，少一步拷贝</p>
<hr>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list就是<strong>双向链表</strong>,<strong>而且是一个环状双向链表</strong>。<strong>元素也是在堆中存放,</strong>每个元素都是放在一块内存中,它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的<strong>随机存取变的非常没有效率</strong>，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。</p>
<p>list<strong>没有空间预留习惯</strong>,所以每分配一个元素都会从内存中分配,每删除一个元素都会释放它占用的内存.</p>
<p>list在哪里添加删除元素性能都很高,不需要移动内存,当然也不需要对每个元素都进行构造与析构了,所以常用来做随机操作容器.<br>但是访问list里面的元素时就开始和最后访问最快<br>访问其它元素都是O(n) ,所以如果需要经常随机访问的话,还是使用其它的好</p>
<hr>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p> deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。<br>  deque采用一块所谓的map（注意，不是STL的map容器）作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI STL 允许我们指定缓冲区大小，默认值0表示将使用512 bytes 缓冲区。</p>
<hr>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>STL实现并不是将这个节点直接删除，而是将其放在底层容器vector的尾端。</p>
<hr>
<h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p> 常见的Hash function 有如下几种：</p>
<ol>
<li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，其中a和b为常数（这种散列函数叫做自身函数）</li>
<li>除法散列法：关键字k 除以m 取余数， 将关键字k 映射到m个slots 中的一个上， 即 h(k) = k mod m， 一般取m 为素数。</li>
<li>乘法散列法：用关键字k 乘上常数A（0&lt;A &lt;1）, 并提取kA d的小数部分。用m 乘以这个小数部分的值， 再往下取整。</li>
</ol>
<p>STL中Hashtable底层实现是通过开链法来实现的，hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</p>
<p>结构中维护了一个 vector，vector 中每一个元素称为一个桶（bucket），它包含的是一个链表的第一个节点。</p>
<hr>
<h4 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map / unordered_map"></a>map / unordered_map</h4><p>红黑树和哈希表</p>
<hr>
<h4 id="set-unordered-set"><a href="#set-unordered-set" class="headerlink" title="set / unordered_set"></a>set / unordered_set</h4><p>set基于红黑树实现，红黑树具有自动排序的功能，因此map内部所有的数据，在任何时候，都是有序的。</p>
<p>unordered_set基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</p>
<hr>
<h4 id="strcpy，memcpy，strcat，strcmp-的实现"><a href="#strcpy，memcpy，strcat，strcmp-的实现" class="headerlink" title="strcpy，memcpy，strcat，strcmp 的实现"></a>strcpy，memcpy，strcat，strcmp 的实现</h4><h5 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* dst, const char* src)</span><br><span class="line">&#123;</span><br><span class="line">    assert(dst);</span><br><span class="line">    assert(src);</span><br><span class="line">    char* ret = dst;</span><br><span class="line">    while((*dst++ = *src++) != &apos;\0&apos;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">//该函数是没有考虑重叠的</span><br><span class="line"></span><br><span class="line">char* strcpy(char* dst, const char* src)</span><br><span class="line">&#123;</span><br><span class="line">    assert((dst != NULL) &amp;&amp; (src != NULL));</span><br><span class="line">    char* ret = dst;</span><br><span class="line">    int size = strlen(src) + 1;</span><br><span class="line">    if(dst &gt; src || dst &lt; src + len)</span><br><span class="line">    &#123;</span><br><span class="line">        dst = dst + size - 1;</span><br><span class="line">        src = src + size - 1;</span><br><span class="line">        while(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *dst-- = *src--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *dst++ = *src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(const char* str1, const char* str2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    while(*str1 == *str2 &amp;&amp; *str1 != &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        ++str1;</span><br><span class="line">        ++str2;</span><br><span class="line">    &#125;</span><br><span class="line">    return *str1 - *str2;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「oscarwin」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/shanghairuoxiao/article/details/72876248</span><br></pre></td></tr></table></figure>

<h5 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char* strcat(char* dst, const char* src)</span><br><span class="line">&#123;</span><br><span class="line">    char* ret = dst;</span><br><span class="line"></span><br><span class="line">    while(*dst != &apos;\0&apos;)</span><br><span class="line">        ++dst;</span><br><span class="line"></span><br><span class="line">    while((*dst++ = *src) != &apos;\0&apos;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「oscarwin」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/shanghairuoxiao/article/details/72876248</span><br></pre></td></tr></table></figure>

<h5 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void* memcpy_my(void* dst, const void* src, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">       if (dst == NULL || src == NULL)</span><br><span class="line">       &#123;</span><br><span class="line">              return NULL;</span><br><span class="line">       &#125;</span><br><span class="line">       void* res = dst;</span><br><span class="line">       char* pdst = (char*)dst;</span><br><span class="line">       char* psrc = (char*)src;</span><br><span class="line">       if (pdst &gt; psrc &amp;&amp; pdst &lt; psrc + size) //重叠</span><br><span class="line">       &#123;</span><br><span class="line">              pdst = pdst + size - 1;</span><br><span class="line">              psrc = pdst + size - 1;</span><br><span class="line">              while (size--)</span><br><span class="line">              &#123;</span><br><span class="line">                     *pdst-- = *psrc--;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else //无重叠</span><br><span class="line">       &#123;</span><br><span class="line">              while (size--)</span><br><span class="line">              &#123;</span><br><span class="line">                     *pdst++ = *psrc++;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="copy-move-的实现"><a href="#copy-move-的实现" class="headerlink" title="copy / move 的实现"></a>copy / move 的实现</h4><p>std::move实现，首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过T&amp;&amp;传递类型保持不变还是右值，而左值经过T&amp;&amp;变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。然后我们通过static_cast&lt;&gt;进行强制类型转换返回T&amp;&amp;右值引用，而static_cast<t>之所以能使用类型转换，是通过remove_refrence<t>::type模板移除T&amp;&amp;，T&amp;的引用，获取具体类型T。</t></t></p>
<p>作者：Siam Chen<br>链接：<a href="https://www.zhihu.com/question/277908001/answer/396588488" target="_blank" rel="noopener">https://www.zhihu.com/question/277908001/answer/396588488</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>也就是说，其实这个函数只是把输入的参数转换为右值引用而已，跟“移动”本身没有任何关系。至于什么是“右值引用”（R-value refernece, <code>T&amp;&amp;</code>），其与左值引用（L-value reference, <code>T&amp;</code>）类似，除了你可以将一个右值（往往是运算的中间结果）装入其中，同时延长这个右值的生存期。虽说右值引用的提出使得移动语义的实现成为了可能，但引用就是引用嘛。</p>
<p>正如左值引用本身并没有实现复制语义，即一个类型T的复制语义是通过一个类的拷贝构造函数（<code>T::T(const T&amp; another)</code>）和<code>=</code>运算符重载（<code>T&amp; T::operator=(const T&amp; rhs)</code>）实现的；移动语义是通过移动构造函数（<code>T::T(T&amp;&amp; another)</code>）和<code>=</code>运算符重载（<code>T&amp;&amp; T::operator=(T&amp;&amp; rhs)</code>）实现的，而这两个函数只不过是接收一个右值引用参数罢了。从某种程度上来讲，你可以认为<code>move(obj)</code>的用处是，生成一个指向<code>obj</code>的右值引用，这样在使用赋值运算符或构造函数时，编译器就可以选择最合适的、接收右值引用的函数重载（如果这样的重载存在的话）。而在函数定义中，类型的实现者会具体定义“移动语义”的实现。</p>
<p>可能你会问了，为啥 <code>T::T(T&amp;&amp; another)</code> 就一定是“移动语义”，而不是“格式化你的C盘”呢？简单！请你考虑一下为啥我们把 <code>T::T(const T&amp; another)</code> 叫做【拷贝】构造函数呢？一切都是约定而已。实际上，你完全可以在 <code>T::T(const T&amp; another)</code> 的实现中格式化你的D盘</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="C-和-C-的区别"><a href="#C-和-C-的区别" class="headerlink" title="C++ 和 C 的区别"></a>C++ 和 C 的区别</h4><p>C++ 是  C  的超集，多出了classes，templates，exception这些部分，标准库的功能也更加复杂。</p>
<p>C++ is a direct descendant of C that retains almost all of C as a subset. C++ provides stronger type checking than C and directly supports a wider range of programming styles than C. C++ is “a better C” in the sense that it supports the styles of programming done using C with better type checking and more notational support (without loss of efficiency). In the same sense, ANSI C is a better C than K&amp;R C. In addition, C++ supports data abstraction, object-oriented programming, and generic programming </p>
<hr>
<h4 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++ 11 新特性"></a>C++ 11 新特性</h4><p><a href="https://www.cnblogs.com/zhangbaochong/p/5873679.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangbaochong/p/5873679.html</a></p>
<hr>
<h4 id="C-内存分配方式"><a href="#C-内存分配方式" class="headerlink" title="C++ 内存分配方式"></a>C++ 内存分配方式</h4><p>C++中的内存主要分为5个存储区（1） 栈（2）堆（3）全局/静态变量存储区（4）文字（5）程序代码区</p>
<p>栈：局部变量，函数参数等存储在该区，由编译器自动分配和释放。栈属于计算机系统的数据结构，进栈出栈有相应的计算机指令支持，而且分配专门的寄存器存储栈的地址，效率分高，内存空间是连续的，但栈的内存空间有限。内存中的栈区是由相对较高的地址向较低的地址向下生长的。是runtime创建的。函数参数是从右往左入栈的。</p>
<p>堆：需要程序员手动分配和释放（new,delete），属于动态分配方式。内存空间几乎没有限制，内存空间不连续，因此会产生内存碎片。操作系统有一个记录空间内存的链表，当收到内存申请时遍历链表，找到第一个空间大于申请空间的堆节点，将该节点分配给程序，并将该节点从链表中删除。一般，系统会在该内存空间的首地址处记录本次分配的内存大小，用于delete释放该内存空间。堆区是向上增长的，也是runtime创建的。</p>
<p>全局/静态存储区:全局变量，静态变量分配到该区，到程序结束时自动释放，包括DATA段（全局初始化区）与BSS段（全局未初始化段）。其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BSS段。BSS段特点：在程序执行前BSS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0。</p>
<p>文字常量区：存放常量，而且不允许修改。程序结束后由系统释放。</p>
<p>程序代码区：存放程序的二进制代码。</p>
<ul>
<li>堆与栈的不同</li>
</ul>
<p>1、管理方式不同；</p>
<p>栈：编译器管理            堆：释放是程序员完成的</p>
<p>2、空间大小不同；</p>
<p>堆大栈小（因为栈得是连续的）</p>
<p>3、能否产生碎片不同；</p>
<p>4、生长方向不同；</p>
<p>5、分配方式不同；</p>
<p>堆都是动态分配的。栈分为静态分配的动态分配。静态分配是由编译器完成的，比如局部变量的分配。动态分配是由alloca进行的。但和堆不同的是，栈的动态分配是由编译器进行释放，无需手工实现。</p>
<p>alloca的优点：方便，不用自己释放 + 快，性能好，申请释放效率都很高</p>
<p>alloca的缺点：危险，栈溢出就UB。基本没有可移植性。</p>
<p>6、分配效率不同；</p>
<ul>
<li>堆和栈上的内存操作越界</li>
</ul>
<ol>
<li>堆内存越界主要是操作的内存超过了calloc/malloc/new等在堆上分配内存函数所分配的大小，后果导致下次calloc/malloc/new的失败，malloc失败发生_int_malloc错误（引起abort）大多是这种情况引起的。</li>
<li>栈内存越界的情况大多出现在对数组的操作上，数组下标超过了数组定义的长度，后果导致覆盖其他变量。</li>
</ol>
<p><em>Ref：<a href="https://blog.csdn.net/u013007900/article/details/79338653" target="_blank" rel="noopener">https://blog.csdn.net/u013007900/article/details/79338653</a> C++内存分配方式详解(堆、栈、自由存储区、全局/静态存储区和常量存储区) &amp; CSAPP 3rd edition</em></p>
<hr>
<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><hr>
<h4 id="模板特化（template-specialization）"><a href="#模板特化（template-specialization）" class="headerlink" title="模板特化（template specialization）"></a>模板特化（template specialization）</h4><p>针对特化的对象不同，分为两类：<strong>函数模板的特化</strong>和<strong>类模板的特化</strong></p>
<ul>
<li><p>函数模板的特化</p>
<p>当函数模板需要对某些类型进行特化处理，称为函数模板的特化。</p>
</li>
<li><p>类模板的特化</p>
<p>当类模板内需要对某些类型进行特别处理时，使用类模板的特化。</p>
</li>
</ul>
<p>特化整体上分为<strong>全特化</strong>和<strong>偏特化</strong></p>
<ul>
<li>全特化</li>
</ul>
<p>就是模板中模板参数全被指定为确定的类型。 全特化也就是定义了一个全新的类型，全特化的类中的函数可以与模板类不一样。</p>
<ul>
<li>偏特化</li>
</ul>
<p>就是模板中的模板参数没有被全部确定，需要编译器在编译时进行确定。</p>
<ol>
<li>模板函数只能全特化，没有偏特化（以后可能有）。</li>
<li>模板类是可以全特化和偏特化的。</li>
</ol>
<ul>
<li>模板函数特化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">int compare(const T &amp;left, const T&amp;right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in template&lt;class T&gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line">    return (left - right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt; &gt;</span><br><span class="line">int compare&lt;const char*&gt;(const char* left, const char* right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in special template&lt; &gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    return strcmp(left, right);</span><br><span class="line">&#125;</span><br><span class="line">// 也可以</span><br><span class="line">template &lt; &gt;</span><br><span class="line">int compare(const char* left, const char* right)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt;&quot;in special template&lt; &gt;...&quot; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    return strcmp(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类特化</li>
</ul>
<ol>
<li>特化为绝对类型</li>
<li>特化为引用，指针类型</li>
<li>特化为另外一个类模板</li>
</ol>
<ul>
<li>特化为绝对类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// general version</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Compare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(<span class="keyword">const</span> T&amp; lh, <span class="keyword">const</span> T&amp; rh)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"in the general class..."</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> lh == rh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// specialize for float</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&lt;float&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>&amp; lh, <span class="keyword">const</span> <span class="keyword">float</span>&amp; rh)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"in the float special class..."</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(lh - rh) &lt; <span class="number">10e-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// specialize for double</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&lt;double&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsEqual</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; lh, <span class="keyword">const</span> <span class="keyword">double</span>&amp; rh)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"in the double special class..."</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(lh - rh) &lt; <span class="number">10e-6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&lt;T1, int&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特化为指针、引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// specialize for _Tp*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;_Tp*&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp*                        pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp;                        reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// specialize for const _Tp*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const _Tp*&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>参见blog里RAII的部分</p>
<hr>
<h4 id="库函数和系统调用区别"><a href="#库函数和系统调用区别" class="headerlink" title="库函数和系统调用区别"></a>库函数和系统调用区别</h4><p>库函数是语言本身的一部分，而系统函数是内核提供给应用程序的接口，属于系统的一部分。函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分。</p>
<p>区别：可移植性 / 库函数属于过程调用，调用开销较小，系统调用需要在用户空间和内核上下文环境间切换，开销较大 / 库函数在用户地址空间执行，系统调用在内核地址空间执行</p>
<hr>
<h4 id="pragma-once-的作用"><a href="#pragma-once-的作用" class="headerlink" title="pragma once 的作用"></a>pragma once 的作用</h4><p>为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式。</p>
<p> //方式一：</p>
<p> #ifndef <strong>SOMEFILE_H</strong></p>
<p>#define  <strong>SOMEFILE_H</strong></p>
<p> … … // 声明、定义语句</p>
<p>#endif</p>
<p>  //方式二：</p>
<p>#pragmaonce</p>
<p> … … // 声明、定义语句</p>
<p>（1）#ifndef</p>
<p>ifndef的方式受C/C++语言标准支持。它不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含。</p>
<p>  当然，缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷。</p>
<p>  由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得编译时间相对较长，因此一些编译器逐渐开始支持#pragma once的方式。</p>
<p>（2）#pragma once</p>
<p>pragma once 一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。</p>
<p>  你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。</p>
<p>  其好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些。</p>
<hr>
<h4 id="回调函数-amp-可重入函数"><a href="#回调函数-amp-可重入函数" class="headerlink" title="回调函数 &amp; 可重入函数"></a>回调函数 &amp; 可重入函数</h4><p>回调就是一种利用函数指针进行函数调用的过程，使用回调函数实际上就是在调用某个函数（通常是API函数）时，将自己的一个函数（这个函数为回调函数）的地址作为参数传递给那个函数。而那个函数在需要的时候，利用传递的地址调用回调函数，这时你可以利用这个机会在回调函数中处理消息或完成一定的操作</p>
<p>可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如<a href="http://baike.baidu.com/view/261041.htm" target="_blank" rel="noopener">全局变量</a>区，<a href="http://baike.baidu.com/view/994002.htm" target="_blank" rel="noopener">中断向量表</a>等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ReStartercc</p>
              <p class="site-description motion-element" itemprop="description">Contact restartercc@gmail.com</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ReStartercc</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
